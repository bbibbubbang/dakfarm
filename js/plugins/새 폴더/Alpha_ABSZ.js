/*:
 * @plugindesc (v.0.9.4.1)[PRO] Active Battle System
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * Alpha ABS Z plugin is still in development
 *
 * Documentation: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 *
 * Quick Start guide:
 * https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * ----------------------------------------------------------- 
 * Alpha ABS Z plugin content:
 *
 * Plugin: js/plugins/Alpha_ABSZ.js
 * Fonts: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * Images: img/Alpha/ *all files*
 * Data: data/AABSZ/ *all files*
 *
 *
 * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text Controls Settings
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc Controls and keybingind settings
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text Is Allow Dodge?
 * @type boolean
 * @default true
 * @desc Allow player make dodge action?
 * 
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text Configuration
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc Dodge action configuration
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text ABS System
 * 
 * @param colPrecissionLevel:int
 * @parent absSettingsGroup
 * @text Collision precision
 * @type number
 * @default 90
 * @min 0 
 * @max 99
 * @desc The higher the value, the easier it is to hit the target in close range combat
 * 
 * @param morePreciseProjAnim:b
 * @parent absSettingsGroup
 * @text More precise animations
 * @type boolean
 * @default true
 * @desc Is use more precise locations for projectiles hit animations
 * 
 * @param isUseExtCollisionsSystem:b
 * @parent absSettingsGroup
 * @text Is Use Extended Collisions?
 * @type boolean
 * @default false
 * @desc [BETA] New collisions system for projectiles
 * 
 * @param getExtCollisionShowLayerKey
 * @parent isUseExtCollisionsSystem:b
 * @text Show/Hide collisions layer
 * @default c
 * @desc [DEV only] Keyboard key for show/hide collisions layer
 * 
 * @param getTerrainTagColliders:structA
 * @parent isUseExtCollisionsSystem:b
 * @text Terrain Tags auto colliders
 * @type struct<AAColTerrain>[]
 * @default []
 * @desc You can specify default collider per Terrain Tag
 * 
 * @param getRegionIdColliders:structA
 * @parent isUseExtCollisionsSystem:b
 * @text Regions auto colliders
 * @type struct<AAColRegion>[]
 * @default []
 * @desc You can specify default collider per map region ID
 * 
 * @param getDefaultEventCollider:struct
 * @parent isUseExtCollisionsSystem:b
 * @text Default collider for Event
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"0","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"1"}
 * @desc Default collider for all Events
 * 
 * 
 * @param spacer|network @text‏‏‎ ‎@desc ===============================================
 * 
 * @param networkSettingsGroup
 * @text Multiplayer
 * @default [Alpha  NETZ plugin required]
 * @desc Require Alpha NET Z plugin
 * 
 * @param netGameMode
 * @parent networkSettingsGroup
 * @type select
 * @text Game Mode
 * @default PvE
 * @option PvE
 * @option PvP
 * @desc Default gamemode PvE - players versus monsters, PvP - player vs players
 * 
 * @param netPvPKilledCE
 * @parent networkSettingsGroup
 * @text On Killed Event
 * @type common_event
 * @default 0
 * @desc Common Event when player is killed by another player in PvP mode.
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text Common Parameters
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text Fonts
 * @type text[]
 * @default []
 * @desc Font files names for preload (from fonts\ folder), without extension
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text Is global UI?
 * @on Yes (global)
 * @off No (only savegame)
 * @default false
 * @desc If True - changes made to UI (via UI Editor or script calls) will saves globaly and applies again when game starts
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text Custom Gauges
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc Custom gauges, used in uAPI script calls, read Wiki for more information
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text Pop Up Settings
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text Is Enable?
 * @on Yes (enabled)
 * @off No (disabled)
 * @default true
 * @desc Is Pop Up system enabled? false - not any Pop Up's at all
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text Text for Miss
 * @default Miss
 * @desc Text for Miss PopUp
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Experience Pop Up
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc Settings for Experience Pop Up
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Gold Pop Up
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Settings for Gold Pop Up
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text Pop Up Table
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc Damage (skills) PopUp's visual settings
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text Buffs And States Settings
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Is show Buffs on UI?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Show player actor's buffs on UI (left top corner by default)?
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text Buffs positions
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc Buffs icons positions. You can add or remove icons positions. Positions count = visible buffs count.
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Visual Settings
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Buff icon visual settings
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Is show States on UI?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Show player actor's states on UI (left top corner by default)?
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text States positions
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc States icons positions. You can add or remove icons positions. Positions count = visible states count.
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Visual Settings
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Status icon visual settings
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text State Icons on Characters
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Player?
 * @on Yes (show)
 * @off No
 * @default false
 * @desc Is state icons will be visible above player character?
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Enemies?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Is state icons will be visible above enemies?
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Allies?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Is state icons will be visible above party members?
 * 
 * @param stateIconsMargins:struct
 * @text Margins
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc Position of state icon, relative character
 * 
 * @param stateIconsScale:int
 * @text Icon scale
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc Default icons size is 32px. This is scale that will be applied to default size.
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text State Icons on Enemy UI
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text States positions
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc States icons positions. You can add or remove icons positions. Positions count = visible states count.
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text Icon scale
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc Default icons size is 32px. This is scale that will be applied to default size.
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text Skill Panel settings
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text Add Skill On Learning?
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc When player learn new skill, add skill on skills panel automatically?
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text Add Item On Pick up?
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc When player pick up new item, add item on skills panel automatically?
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text Remove Zero Items?
 * @type boolean
 * @default false
 * @desc Remove an item from the skill panel if the count of item is 0 
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text Outline effect?
 * @type boolean
 * @on Yes (quality)
 * @off No (performance)
 * @default true
 * @desc Outline glow effects for skill slots (when activated, ready, disabled) Turn OFF for better performance.
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Primary Attack Slot
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc Required. Skill slot for primary attack (main weapon)
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Secondary Attack Slot
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc Required. Skill slot for secondary attack
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text Skill Slots
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc Optional. Skill slots.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text Skill Slot Visual
 * @type struct<LSkillSlotItemVisual> 
 * @desc Skill Slot visual settings
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text Player and Party settings
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Shake on Damage?
 * @type boolean
 * @on Shake
 * @off No
 * @default true
 * @desc Is shake screen when player receive damage?
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text Low HP screen effect?
 * @type boolean
 * @on Show
 * @off No
 * @default true
 * @desc Flash screen when player HP is low. Blood splatter effect.
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text Effect Settings
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc Blood splatter effect settings
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text On Death Event
 * @type common_event
 * @default 0
 * @desc Common Event when player is dead. If 0 - Game Over screen.
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text Show Death Motion
 * @type select
 * @option Never
 * @value 0
 * @option Always
 * @value 1
 * @option If not have AnimaX
 * @value 2
 * @default 1
 * @desc Show character (player or ally) dead motion [from SV Battler] sprite? 
 * 
 * @param partyExpGainMode
 * @parent playerAndPartySettingsGroup
 * @text How gain Exp?
 * @type select
 * @option To player only
 * @value player
 * @option For all
 * @value party
 * @option For all divided
 * @value partyDivided
 * @option One who kill
 * @value killer
 * @default partyDivided
 * @desc How gain exp (for killed enemies) to party?
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Use Custom LevelUp?
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc Are show custom level up efffect instead of default one?
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text Level Up Settings
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text UI Elements Settings
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text Gauges
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text HP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player HP gauge visual settings
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text MP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player MP gauge visual settings
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text TP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player TP gauge visual settings
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text EXP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player Exp gauge visual settings
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text Enemies settings
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text UI Elements Settings
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text Gauges
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text Mini HP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc HP gauge above enemies on map (default one)
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text Customs
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [PRO] You can assign custom gauge to certain enemy by <miniHpGaugeStyle> ABS parameter
 * 
 * @param enemyInfoVisualSettings:struct
 * @text Enemy Info
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc Enemy Info visual settings [information when you select\hover enemy]
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 * @param enemyAIUpdateThreadMS:int
 * @parent enemySettingsGroup
 * @text AI Think Interval
 * @type number
 * @min 1
 * @max 200
 * @default 100
 * @desc Enemy AI logic update interval, in milliseconds!. Less value, AI more quicker takes decisions.
 * 
 * @param enemyAIUpdateVisionIntervalFR:int
 * @parent enemySettingsGroup
 * @text AI Vision Interval
 * @type number
 * @min 1
 * @max 32
 * @default 4
 * @desc Enemy vision check interval, in FRAMES!. Less value, AI more quicker check around for enemies
 * 
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text No Pass Vision Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the enemies can not see. Global, for all enemies.
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text No Pass Vision Terrains
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the enemies can not see. Global, for all enemies.
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Bonuses defenitions for bonusOnDeadIds ABS parameter
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text Spawning Settings
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Map ID
 * @type number
 * @min 0
 * @default 0
 * @desc [Required] Map ID with events templates for spawning. 0 - spawn system not will works
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text Is spawn above events?
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc Is spawning enemies above another events (or enemies) allowed?
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text Is use region cache?
 * @type boolean
 * @on Yes (more performance)
 * @off No
 * @default true
 * @desc If you dinamycally change region Id's on map during game, set this parameter to NO (false)
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Points
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc Spawning points definitions for <absSpawnPoint:ID> event comment. Read Wiki for more information.
 * 
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text Map settings
 * 
 * @param mapScrolling:s
 * @text Map Scrolling
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc Mouse map scrolling settings
 * 
 * @param map_noProjectilePass:intA
 * @parent mapSettingsGroup
 * @text No Pass Projectiles Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the projectiles can not pass. Global, for all projectiles.
 * 
 * @param map_noProjectilePass2:intA
 * @parent mapSettingsGroup
 * @text No Pass Projectiles Terrains
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the projectiles can not pass. Global, for all projectiles.
 * 
 * @param miniHpGaugeSetings:s
 * @text Mini HP Gauges
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc Mini HP gauges above ABS events settings
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV] Animation Scalling
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [MV Only] Animation auto scalling factor when animation playing on Map or on ABS character (event, player). Set 1 to 100% (as in Animation Editor)
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text Battle Auto BGM
 * @type struct<BattleAutoBGM>
 * @desc BGM for autoplay when player engage in battle. You can specify per map with <battleAutoBgm:NAME> notetag in Map
 * @default {"name":"","delay:i":"0.50"}
 * 
 * @param spacer|mz3d @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mz3dSettingsGroup
 * @text MZ3D Settings
 * 
 * 
 * @param ANIMATION_DEPTH:b
 * @parent mz3dSettingsGroup
 * @text Animation Depth
 * @desc Whether projectile impact animations should have depth enabled
 * @type boolean
 * @default true
 * 
 * @param ANIMATION_SCALE:i
 * @parent mz3dSettingsGroup
 * @text Animation Scale
 * @desc Scale for projectile impact animations
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param WALL_HIT_BEHAVIOR:b
 * @parent mz3dSettingsGroup
 * @text Wall Hit Behavior
 * @desc When a projectile hits a wall, whether it should hit the base of the wall or the top of the wall.
 * @type boolean
 * @on Base
 * @off Top
 * @default true
 * 
 * @param PROJECTILE_Z_OFF:i
 * @parent mz3dSettingsGroup
 * @text Projectile Z Offset
 * @desc offset for z-position of projectiles
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param PROJECTILE_CLIMB_HEIGHT:i
 * @parent mz3dSettingsGroup
 * @text Projectile Climb Height
 * @desc Projectiles will collide with walls higher than this
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param PROJECTILE_CLIMB_TIME:i
 * @parent mz3dSettingsGroup
 * @text Projectile Climb Time
 * @desc When projectile climbs to a higher elevation, how long it takes to reach new height. Higher value = slower
 * @type number
 * @default 5
 * 
 * @param PROJECTILE_FALL_TIME:i
 * @parent mz3dSettingsGroup
 * @text Projectile Fall Time
 * @desc When projectile is fired from high elevation, how long it takes to reach ground. Higher value = slower
 * @type number
 * @default 25
 * 
 * @param WEAPON_POSITION_X:i
 * @parent mz3dSettingsGroup
 * @text Weapon Position X
 * @desc horizontal position of weapon sprite
 * @type number
 * @decimals 3
 * @default .5
 * 
 * @param WEAPON_POSITION_Z:i
 * @parent mz3dSettingsGroup
 * @text Weapon Position Z
 * @desc vertical position of weapon sprite
 * @type number
 * @decimals 3
 * @default .333
 * 
 * @param WEAPON_SCALE:i
 * @parent mz3dSettingsGroup
 * @text Weapon Scale
 * @desc scale of weapon sprite
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param WEAPON_INHERIT_SCALE:b
 * @parent mz3dSettingsGroup
 * @text Weapon Inherit Scale
 * @desc Whether weapon sprite should inherit scale from character sprite
 * @type boolean
 * @default true
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 
 * @command ABSEventSettings
 * @text ABS Enemy Configurate
 * @desc Configurate enemy ABS parameters for this certaint event
 * 
 * @arg MainGroup
 * @text Main Group
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text View Radius
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc On how many map cells sees enemy
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text Return Radius
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc How far can the enemy move away from the place where the battle begins
 * 
 * @arg noMoveInBattle
 * @parent MainGroup
 * @text No Move in Battle
 * @type boolean
 * @default false
 * @desc If TRUE -> enemy can't moving during battle
 * 
 * @arg noApproach
 * @parent MainGroup
 * @text No Approach Target
 * @type boolean
 * @default false
 * @desc If TRUE -> enemy can't approach target during battle
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text On Death
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy is die
 * 
 * @arg onSeeTarget
 * @parent MainGroup
 * @text On See Target
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy is see target 
 * 
 * @arg onHit
 * @parent MainGroup
 * @text On Hit
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy get hitted (get health damage > 0)
 * 
 * @arg expVar
 * @parent MainGroup
 * @text Exp Variable
 * @type variable
 * @default 0
 * @desc If any -> experience will be given from this variable. 0 - from Database settings 
 * 
 * @arg autoExp
 * @parent MainGroup
 * @text Auto Exp
 * @type boolean
 * @default false
 * @desc If TRUE -> player will receive exp automatically after kill this enemy.
 * 
 * @arg notAgressive
 * @parent MainGroup
 * @text Not Agressive
 * @type boolean
 * @default false
 * @desc If TRUE -> the enemy will not attack first
 * 
 * @arg teamId
 * @parent MainGroup
 * @text  Team ID
 * @type number
 * @min 1
 * @max 10
 * @default 1
 * @desc Enemies with different team ID's will fight each other
 * 
 * @arg onDeathVar
 * @parent MainGroup
 * @text Death Variable
 * @type variable
 * @default 0
 * @desc If any -> +1 to this variable if this enemy is die 
 * 
 * @arg saveHp
 * @parent MainGroup
 * @text Save HP
 * @type boolean
 * @default false
 * @desc If TRUE -> stores enemy HP value when leave the map and restores when returns to this map
 * 
 * @arg MapGroup
 * @text Map Group
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text Shatter Effect?
 * @type boolean
 * @default true
 * @desc Is play sprite shatter effect when enemy is die?
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text Dead Switch
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc Will turn ON this self.switch when enemy is die ( 0 - nothing )
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text Erase on Dead?
 * @type boolean
 * @default true
 * @desc Erase Event when enemy is die? Only if NOT HAVE Dead Switch
 * 
 * @arg heavy
 * @parent MapGroup
 * @text Is heavy
 * @type boolean
 * @default false
 * @desc If TRUE -> this enemy can't be moved by Impulse skills
 * 
 * @arg weaponMotionType
 * @parent MapGroup
 * @text Weapon Motion Type
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Weapon Motion Type for skills with Weapon Motions.
 * 
 * @arg lootDropOnDeath
 * @parent MapGroup
 * @text Drop Loot
 * @type boolean
 * @default false
 * @desc If TRUE -> auto loot (from Database Drop Items and Gold) drop on Death
 * 
 * @arg VisualGroup
 * @text Visual Group
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text Show UI Info?
 * @type boolean
 * @default true
 * @desc Is show portrait UI when enemy is under cursor?
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text Face Name
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc Image name for portrait UI
 * 
 * @arg faceIndex
 * @parent faceName
 * @text Face Index
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Face index on face image for portrait UI
 * 
 * @arg miniHpGaugeStyle
 * @parent VisualGroup
 * @text Mini HP Gauge Style
 * @type number
 * @default
 * @desc Enemy HP gauge style from Gauges -> Customs plugin parameter
 * 
 * @arg AnimationGroup
 * @text Animation Group
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text Hit Animation
 * @type animation
 * @default 1
 * @desc Hit animation on character when enemy attacks
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */
/*:ru
 * @plugindesc (v.0.9.4.1)[PRO] Активная боевая система
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * Плагин Alpha ABS Z находится в разработке
 *
 * Документация: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 *
 * С чего начать:
 * https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * ----------------------------------------------------------- 
 * Содержимое плагина (необходимые файлы):
 *
 * Файл плагина: js/plugins/Alpha_ABSZ.js
 * Шрифты в папке: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * Изображения: img/Alpha/ *все файлы*
 * Данные (настройки): data/AABSZ/ *все файлы*
 *
 * Скопируйте эти файлы и папки в себе проект чтобы Alpha ABS Z работал корректно
 *
  * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text Управление
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc Настройки управления и привязки кнопок
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text Is Allow Dodge?
 * @type boolean
 * @default true
 * @desc Может ли игрок совершать перекат?
 * 
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text Configuration
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc Настройки переката
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text Система
 * 
 * @param colPrecissionLevel:int
 * @parent absSettingsGroup
 * @text Точность коллизий
 * @type number
 * @default 90
 * @min 0
 * @max 99
 * @desc Чем выше значение, тем легче поразить (попасть по) цель в ближнем бою
 * 
 * @param morePreciseProjAnim:b
 * @parent absSettingsGroup
 * @text More precise animations
 * @type boolean
 * @default true
 * @desc Анимации попадания всех снарядов (projectiles) будут более точными (без привязки к персонажам)
 * 
 * @param isUseExtCollisionsSystem:b
 * @parent absSettingsGroup
 * @text Is Use Extended Collisions?
 * @type boolean
 * @default false
 * @desc [BETA] Использовать новую систему столкновений
 * 
 * @param getExtCollisionShowLayerKey
 * @parent isUseExtCollisionsSystem:b
 * @text Show/Hide collisions layer
 * @default c
 * @desc [DEV only] Клавиша для отображения/скрытия слоя коллизий
 * 
 * @param getTerrainTagColliders:structA
 * @parent isUseExtCollisionsSystem:b
 * @text Terrain Tags auto colliders
 * @type struct<AAColTerrain>[]
 * @default []
 * @desc Коллайдер по умолчанию для тега местности
 * 
 * @param getRegionIdColliders:structA
 * @parent isUseExtCollisionsSystem:b
 * @text Regions auto colliders
 * @type struct<AAColRegion>[]
 * @default []
 * @desc Коллайдер по умолчанию для региона
 * 
 * @param getDefaultEventCollider:struct
 * @parent isUseExtCollisionsSystem:b
 * @text Default collider for Event
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"0","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"1"}
 * @desc Коллайдер по умолчанию для событий
 * 
 * 
 * @param spacer|network @text‏‏‎ ‎@desc ===============================================
 * 
 * @param networkSettingsGroup
 * @text Мультиплеер
 * @default [Alpha NETZ plugin required]
 * @desc Требуется плагин Alpha NET Z
 * 
 * @param netGameMode
 * @parent networkSettingsGroup
 * @type select
 * @text Режим игры
 * @default PvE
 * @option PvE
 * @option PvP
 * @desc PvE - игроки против монстров, PvP - игроки против игроков
 * 
 * @param netPvPKilledCE
 * @parent networkSettingsGroup
 * @text Общее событие при смерти
 * @type common_event
 * @default 0
 * @desc Общее событие для данного игрока когда он убит другим игроком в PvP режиме
 * 
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text Общие настройки
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text Шрифты
 * @type text[]
 * @default []
 * @desc Дополнительные шрифты для Вашей игры (из папки fonts\ folder), указывать без расширения (только название)
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text Глобальный UI?
 * @on Да (глобальный)
 * @off Нет (файл сохранения)
 * @default false
 * @desc Если ВКЛ, то изменения UI (через UI Editor или вызовом скриптов) будут сохранены в конфиг и применены при старте игры снова
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text Custom Gauges
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc Custom gauges, used in uAPI script calls, read Wiki for more information
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text Всплывающие сообщения
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text Включены?
 * @on Да 
 * @off Нет 
 * @default true
 * @desc Если Нет (ВЫКЛ), то в игре не будет всплывающих сообщений боевой системы АБС
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text Промах
 * @default Промах
 * @desc Текст для промаха
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Опыт
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc Настройки всплывающего сообщения с опытом
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Золото
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Настройки всплывающего сообщения с золотом
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text Таблица
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc Настройки всплывающих сообщений для разных видов урона и навыков
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text Бафы и состояния
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Показывать бафы на UI?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать активные бафы персонажа игрока на экране? (левый вверхний угол - по умолчанию)
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text Позиции
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc Позиции иконок текущих бафов игрока. Можно добавлять или удалять. Кол-во позиций = сколько бафов будет на экране.
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Настройки
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Визуальные настройки отображения бафов
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Показывать состояния на UI?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать активные состояния персонажа игрока на экране? (левый вверхний угол - по умолчанию)
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text Позиции
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc Позиции иконок текущих состояний игрока. Можно добавлять или удалять. Кол-во позиций = сколько состояний будет на экране.
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Настройки
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Визуальные настройки отображения состояний
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text Иконки над персонажами
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Над игроком?
 * @on Да
 * @off Нет
 * @default false
 * @desc Показывать иконки состояний над игроком?
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Enemies?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать иконки состояний над врагами?
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Allies?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать иконки состояний над сопартийцами?
 * 
 * @param stateIconsMargins:struct
 * @text Позиция
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc Позиция иконки состояния, относительно персонажа
 * 
 * @param stateIconsScale:int
 * @text Масштаб
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc Размер (масштаб) иконки состояния. Стандартный размер 32 пикселя.
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text Иконки на UI противника
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text Позиции иконок
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc Позиции иконок текущих состояний игрока. Можно добавлять или удалять. Кол-во позиций = сколько состояний будет на экране.
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text Масштаб
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc Размер (масштаб) иконки состояния. Стандартный размер 32 пикселя.
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text Панель навыков
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text Добавлять при изучении?
 * @type boolean
 * @on Добавлять
 * @off Нет
 * @default true
 * @desc Когда игрок изучил новый навык, добавлять его автоматически на панель навыков?
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text Добавлять предмет?
 * @type boolean
 * @on Добавлять
 * @off Нет
 * @default true
 * @desc Когда игрок получил предмет, добавлять его автоматически на панель навыков?
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text Удалять предметы?
 * @type boolean
 * @default false
 * @desc Удалять предмет из панели навыков, если предмета нет больше в инвентаре? (количество = 0)
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text Эффект подсветки?
 * @type boolean
 * @on Да (качество)
 * @off Нет (+ производительность)
 * @default true
 * @desc Эффект подсветки слотов навыков. ВЫКЛ чтобы увеличить производительность.
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Главная атака
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc Обязательный. Слот навыка для главной атаки (левая кнопка мыши)
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Вторичная атака
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc Обязательный. Слот навыка для вторичной атаки (правая кнопка мыши)
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text Слоты
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc Опционально. Слоты для навыков. Можно удалять или добавлять.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text Визуальные настройки
 * @type struct<LSkillSlotItemVisual> 
 * @desc Визуальные настройки (общие) для всех слотов навыков.
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text Игрок и партия
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text Тряска при уроне?
 * @type boolean
 * @on Тряска
 * @off Нет
 * @default true
 * @desc Активировать эффект тряски экрана когда игрок получает урон?
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text Эффект когда присмерти?
 * @type boolean
 * @on Показывать
 * @off Нет
 * @default true
 * @desc Эффект мерцания экрана когда у игрока мало здоровья.
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text Effect Settings
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc Настройки эффекта. Порог здоровья для активации, цвет, доп. картинка.
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text При смерти игрока
 * @type common_event
 * @default 0
 * @desc Общее событие при смерти игрока. Если 0 - то сразу экран Game Over
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text Show Death Motion
 * @type select
 * @option Нет
 * @value 0
 * @option Всегда
 * @value 1
 * @option Если нет AnimaX
 * @value 2
 * @default 1
 * @desc Показывать Dead Motion SV Battler спрайт персонажа (игрок или союзник только)
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Use Custom LevelUp?
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc Показывать пользовательский эффект при новом уровне?
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text Настройки эффекта
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text Интерфейс
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text Основные хар-ки
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса здоровья HP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы здоровья игрока
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса маны MP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы маны игрока
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса TP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы TP игрока
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса опыта
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы опыта игрока
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text Настройки врагов
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text Интерфейс
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text Основные хар-ки
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text Полоса HP на карте
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Настройки полосы здоровья на карте (над головой)
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text Пользовательские
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [PRO] Исп. параметр <miniHpGaugeStyle> чтобы назначить индивидуальную полоску здоровья для конкретного врага
 * 
 * @param enemyInfoVisualSettings:struct
 * @text Информация о враге
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc Визаульные настройки окошка информации о враге [когда наводишь мышку на врага]
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 * @param enemyAIUpdateThreadMS:int
 * @parent enemySettingsGroup
 * @text AI Think Interval
 * @type number
 * @min 1
 * @max 200
 * @default 100
 * @desc Enemy AI logic update interval, in milliseconds!. Less value, AI more quicker takes decisions.
 * 
 * @param enemyAIUpdateVisionIntervalFR:int
 * @parent enemySettingsGroup
 * @text AI Vision Interval
 * @type number
 * @min 1
 * @max 32
 * @default 4
 * @desc Enemy vision check interval, in FRAMES!. Less value, AI more quicker check around for enemies
 * 
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text Регионы без обзора
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc Номера регионов, через которые враг НЕ видит. Глобальная настройка, для всех врагов.
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text Территории без обзора
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc Тэги территорий (1-7) через которые враг НЕ видит. Глобальная настройка, для всех врагов.
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Доп. бонусы из врагов для параметра bonusOnDeadIds (см. Wiki Flying Bonuses)
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text Настройки спавна
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text Карта спавна
 * @type number
 * @min 0
 * @default 0
 * @desc [Необходимо] Номер карты, на которой будут хранится шаблоны событий для спавна. 0 - система не будет работать
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text Поверх событий?
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc Можно ли спавнить врагов поверх событий или других врагов?
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text Кэш регионов
 * @type boolean
 * @on Да (производительность)
 * @off Нет
 * @default true
 * @desc Если какой-либо плагин динамически меняет номера регионов в течении игры, то ВЫКЛ этот параметр
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Points
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc Набор точек спавна для события с <absSpawnPoint:ID>. Читайте Wiki документацию.
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text Карта
 * 
 * @param mapScrolling:s
 * @text Прокрутка карты
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc Настройки прокрутки карты
 * 
 * @param map_noProjectilePass:intA
 * @parent mapSettingsGroup
 * @text Твёрдые регионы
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc Номера регионов, через которые НЕ могут проходить летающие навыки. Глобальная, для всех карт.
 * 
 * @param map_noProjectilePass2:intA
 * @parent mapSettingsGroup
 * @text Твёрдые Территории
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc Тэги территорий (1-7), через которые НЕ могут проходить летающие навыки. Глобальная, для всех карт.
 * 
 * 
 * @param miniHpGaugeSetings:s
 * @text Мини полоска здоровья
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc Настройки отображения мини полоски здоровья над АБС событиями
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV] Animation Scalling
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [Только для MV] Автоматический масштаб анимаций, которые будут вопроизводится на карте или на АБС персонаже. 1 - как в настройках анимации.
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text Battle Auto BGM
 * @type struct<BattleAutoBGM>
 * @desc BGM для боя (autoplay). Можно задать для каждой карты через <battleAutoBgm:NAME> в заметке карты
 * @default {"name":"","delay:i":"0.50"}
 * 
 * @param mz3dSettingsGroup
 * @text Настройки MZ3D
 * 
 * @param ANIMATION_DEPTH:b
 * @parent mz3dSettingsGroup
 * @text Глубина анимации
 * @desc Включать ли глубину для анимации попадания снаряда
 * @type boolean
 * @default true
 * 
 * @param ANIMATION_SCALE:i
 * @parent mz3dSettingsGroup
 * @text Масштаб анимации
 * @desc Масштаб для анимации попадания снаряда
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param WALL_HIT_BEHAVIOR:b
 * @parent mz3dSettingsGroup
 * @text Поведение при попадании в стену
 * @desc При попадании снаряда в стену, он должен попасть в основание стены или в верхнюю часть стены.
 * @type boolean
 * @on Основание
 * @off Верх
 * @default true
 * 
 * @param PROJECTILE_Z_OFF:i
 * @parent mz3dSettingsGroup
 * @text Смещение Z для снаряда
 * @desc Смещение по оси Z для снарядов
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param PROJECTILE_CLIMB_HEIGHT:i
 * @parent mz3dSettingsGroup
 * @text Высота подъема снаряда
 * @desc Снаряды будут сталкиваться со стенами выше этого значения
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param PROJECTILE_CLIMB_TIME:i
 * @parent mz3dSettingsGroup
 * @text Время подъема снаряда
 * @desc Когда снаряд поднимается на большую высоту, время, за которое он достигает новой высоты. Большее значение = медленнее
 * @type number
 * @default 5
 * 
 * @param PROJECTILE_FALL_TIME:i
 * @parent mz3dSettingsGroup
 * @text Время падения снаряда
 * @desc Когда снаряд выпускается с высокой точки, время, за которое он достигает земли. Большее значение = медленнее
 * @type number
 * @default 25
 * 
 * @param WEAPON_POSITION_X:i
 * @parent mz3dSettingsGroup
 * @text Позиция оружия по X
 * @desc Горизонтальное положение спрайта оружия
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param WEAPON_POSITION_Z:i
 * @parent mz3dSettingsGroup
 * @text Позиция оружия по Z
 * @desc Вертикальное положение спрайта оружия
 * @type number
 * @decimals 3
 * @default 0.333
 * 
 * @param WEAPON_SCALE:i
 * @parent mz3dSettingsGroup
 * @text Масштаб оружия
 * @desc Масштаб спрайта оружия
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param WEAPON_INHERIT_SCALE:b
 * @parent mz3dSettingsGroup
 * @text Наследование масштаба оружия
 * @desc Должен ли спрайт оружия наследовать масштаб от спрайта персонажа
 * @type boolean
 * @default true
 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 
 * @command ABSEventSettings
 * @text Настройки АБС врага
 * @desc Настройки АБС параметров для текущего события (не все)
 * 
 * @arg MainGroup
 * @text Основные
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text Область видимости
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc Как далеко (клетки карты) видит данный враг
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text Область возврата
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc Как далеко может отойти враг в бою от начальной точки (где он начал бой)
 * 
 * @arg noMoveInBattle
 * @parent MainGroup
 * @text Остановка в бою
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не двигается во время битвы
 * 
 * @arg noApproach
 * @parent MainGroup
 * @text Нет преследованию
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не преследует цель во время битвы
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text Смерть
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг погибает
 * 
 * @arg onSeeTarget
 * @parent MainGroup
 * @text Вижу цель
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг увидел цель
 * 
 * @arg onHit
 * @parent MainGroup
 * @text Получил урон
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг получил урон
 * 
 * @arg expVar
 * @parent MainGroup
 * @text Опыт из переменной
 * @type variable
 * @default 0
 * @desc Если > 0, то -> опыт игрок получит из переменной. 0 - из базы данных 
 * 
 * @arg autoExp
 * @parent MainGroup
 * @text Авто опыт
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> игрок получит опыт автоматически после убийства врага
 * 
 * @arg notAgressive
 * @parent MainGroup
 * @text Спокойный
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не атакует первым, только в ответ
 * 
 * @arg teamId
 * @parent MainGroup
 * @text Команда
 * @type number
 * @min 1
 * @max 10
 * @default 1
 * @desc Враги с разным Team ID сражаются друг с другом
 * 
 * @arg onDeathVar
 * @parent MainGroup
 * @text Учёт смерти
 * @type variable
 * @default 0
 * @desc Если > 0, то -> +1 к этой переменной при смерти врага
 * 
 * @arg saveHp
 * @parent MainGroup
 * @text Сохранять здоровье
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> сохранить кол-во здоровья данному врагу (при смене карты)
 * 
 * @arg MapGroup
 * @text Карта
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text Эффект разбития?
 * @type boolean
 * @default true
 * @desc Проигрывать эффект разбития спрайта когда враг погибает?
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text Переключатель
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc Данный переключатель будет ВКЛ, когда враг погибает (0 - ничего)
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text Удалять при смерти?
 * @type boolean
 * @default true
 * @desc Удалять данное событие когда враг погибает? Только если переключатель = 0
 * 
 * @arg heavy
 * @parent MapGroup
 * @text Тяжёлый
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> нельзя сдвинуть импульсом
 * 
 * @arg weaponMotionType
 * @parent MapGroup
 * @text Weapon Motion Type
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Weapon Motion Type для навыков, которые используют данный функционал (см. Wiki)
 * 
 * @arg lootDropOnDeath
 * @parent MapGroup
 * @text Выбросить лут
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> выбросить лут (предметы) автоматически после смерти
 * 
 * @arg VisualGroup
 * @text Визаульные настройки
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text Показывать на UI?
 * @type boolean
 * @default true
 * @desc Показывать информацию о данном противнике на UI ?
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text Портрет
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc Название файла изборажения с портретом для данного врага
 * 
 * @arg faceIndex
 * @parent faceName
 * @text Индекс
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Индекс лица на файле изображения портрета
 * 
 * @arg miniHpGaugeStyle
 * @parent VisualGroup
 * @text Mini HP Gauge Style
 * @type number
 * @default
 * @desc Пользователский стиль (имя) полоски здоровья (из параметров плагина)
 * 
 * @arg AnimationGroup
 * @text Анимация
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text Анимация при ударе
 * @type animation
 * @default 1
 * @desc Анимация удара на персонаже (игроке), когда данный враг атакует его
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */
/*:zh-cn
 * @plugindesc (v.0.9.4.1)[PRO] Active Battle System
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * 注：此插件目前仍在继续研发之中

 * ----------------------------------------------------------- 
 * 官方网站: https://github.com/KageDesu/Alpha-ABS-Z
 * 说明文档: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 * 新手说明：https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * (注：以上站点均为英文，浏览时可用谷歌浏览器自动翻译页面成中文)
 *
 *
 包含的文件：
 * 插件: js/plugins/Alpha_ABSZ.js
 * 字体: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * 图片: img/Alpha/ *all files*
 * 数据（设置）：data/AABSZ/ 所有文件
 *
 * 中文翻译:古火乐(QQ:452901928)
 *
  * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text 控制设置
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc 操控和键盘设置
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text 是否允许躲闪？
 * @type boolean
 * @default true
 * @desc 是否允许玩家进行躲闪操作？
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text 配置
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc 躲闪动作配置
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text 战斗系统
 * 
 * @param colPrecissionLevel:int
 * @parent absSettingsGroup
 * @text 碰撞精确度
 * @type number
 * @default 90
 * @min 0 
 * @max 99
 * @desc 数值越大越容易击中目标
 * 
 *  @param morePreciseProjAnim:b
 *  @parent absSettingsGroup
 *  @text 更多精细动画
 *  @type boolean
 *  @default true
 *  @desc 是否为投射物的打击效果使用更多精细位置动画
 * 
 *  @param isUseExtCollisionsSystem:b
 *  @parent absSettingsGroup
 *  @text 是否使用扩展碰撞？
 *  @type boolean
 *  @default false
 *  @desc [BETA测试] 新的投射物碰撞检测系统
 * 
 *  @param getExtCollisionShowLayerKey
 *  @parent isUseExtCollisionsSystem:b
 *  @text 显示/隐藏碰撞层
 *  @default c
 *  @desc [开发者专用] 键盘快捷键显示/隐藏碰撞层
 * 
 *  @param getTerrainTagColliders:structA
 *  @parent isUseExtCollisionsSystem:b
 *  @text 地形标志自动碰撞检测
 *  @type struct<AAColTerrain>[]
 *  @default []
 *  @desc 你可以为每个地形标志自定义碰撞检测
 * 
 *  @param getRegionIdColliders:structA
 *  @parent isUseExtCollisionsSystem:b
 *  @text 区域自动碰撞检测
 *  @type struct<AAColRegion>[]
 *  @default []
 *  @desc 你可以为每个地图的区域ID自定义默认的碰撞检测
 * 
 *  @param getDefaultEventCollider:struct
 *  @parent isUseExtCollisionsSystem:b
 *  @text 事件的默认碰撞体
 *  @type struct<AAColliderConfig>
 *  @default {"type":"b","dx:int":"0","dy:int":"0","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"1"}
 *  @desc 所有事件的默认碰撞体
 * 
 * 
 * @param spacer|network @text‏‏‎ ‎@desc ===============================================
 * 
 * @param networkSettingsGroup
 * @text 联网游戏
 * @default [Alpha  NETZ plugin required]
 * @desc 需要 Alpha NET Z plugin 联网插件
 * 
 * @param netGameMode
 * @parent networkSettingsGroup
 * @type select
 * @text 游戏模式
 * @default PvE
 * @option PvE
 * @option PvP
 * @desc 默认是PvE（玩家打怪）, PvP（玩家打玩家）
 * 
 * @param netPvPKilledCE
 * @parent networkSettingsGroup
 * @text 被杀时公共事件
 * @type common_event
 * @default 0
 * @desc 玩家在PVP模式下被杀时执行的公共事件
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text 通用参数
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text 字体
 * @type text[]
 * @default []
 * @desc 预加载的字体 (位置：fonts\ 文件夹), 不要带扩展名
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text 启用全局UI
 * @on Yes (global)
 * @off No (only savegame)
 * @default false
 * @desc 如果设置为Yes那么修改UI（UI编辑器或脚本）时将对所有游戏存档生效
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text 自定义血槽
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc 自定义血槽, 可使用uAPI脚本指令，详情参见wiki
 * 
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text 伤害飘字提示
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text 是否启用？
 * @on Yes (enabled)
 * @off No (disabled)
 * @default true
 * @desc 若选No则表示完全不显示伤害飘字
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text 文本：【闪避】
 * @default Miss
 * @desc 闪避时的飘字内容
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text 获得经验
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc 获得经验值时的飘字
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Gold Pop Up
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Settings for Gold Pop Up
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text 伤害数字
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc 伤害数字飘字设置
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text BUFF和状态设置
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text 在UI上是否显示BUFF？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否显示角色BUFF (默认在左上角)?
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text BUFF图标位置
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc BUFF图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text 可视化设置
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":"%1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc BUFF图标可视化设置
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text 在UI上是否显示状态
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否显示角色状态 (默认在左上角)?
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text 状态位置
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc 状态图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text 属性可视化设置
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc 状态图标属性设置
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text 角色上面的状态图标
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在角色头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default false
 * @desc 是否在角色头顶上显示状态图标？
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在怪物头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否在怪物头顶上显示状态图标？
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在队友头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否在队友头顶上显示状态图标？
 * 
 * @param stateIconsMargins:struct
 * @text 对齐
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc 相对于角色，状态图标的偏移量
 * 
 * @param stateIconsScale:int
 * @text 图标大小
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc 默认大小为32像素，实际大小=默认大小*这个比例
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text 怪物界面上的状态图标
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text 状态图标位置
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc 状态图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text 图标大小
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc 默认大小为32像素，实际大小=默认大小*这个比例
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text 技能面板设置
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text 学习技能后是否增加技能？
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc 学习技能时是否自动在技能栏上出现技能
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text 获得物品时出现物品图标？
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc 当玩家获得新物品时，是否在技能栏上出现物品图标？
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text 删除数量为0个的物品？
 * @type boolean
 * @default false
 * @desc 当某物品数量为0时是否从技能栏上删除？
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text 是否启用描边效果？
 * @type boolean
 * @on Yes (quality)
 * @off No (performance)
 * @default true
 * @desc 技能栏外描边效果，开启后会消耗一定性能
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text 主要攻击栏
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc 必选项. 技能栏上的主要攻击（默认攻击）
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text 次要攻击栏
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc 必选项. 技能栏上的次要攻击（非默认攻击）
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text 技能栏
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc 可选项. 技能栏.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text 技能栏显示
 * @type struct<LSkillSlotItemVisual> 
 * @desc 技能栏显示设置
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text 角色和伙伴设置
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text 受伤时是否晃动？
 * @type boolean
 * @on Shake
 * @off No
 * @default true
 * @desc 角色受伤时是否晃动屏幕？
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text 角色HP过低时是否显示屏幕红色警告效果
 * @type boolean
 * @on Show
 * @off No
 * @default true
 * @desc 角色HP过低时屏幕显示警告闪烁效果/图片
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text 设置
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text 死亡时运行公共事件
 * @type common_event
 * @default 0
 * @desc 角色死亡时运行什么公共事件，为0则直接游戏结束
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text 显示死亡动画
 * @type select
 * @option Never
 * @value 0
 * @option Always
 * @value 1
 * @option If not have AnimaX
 * @value 2
 * @default 1
 * @desc 是否使用SV侧面战斗图来显示角色的死亡动画
 * 
 *  @param partyExpGainMode
 *  @parent playerAndPartySettingsGroup
 *  @text 如何获得经验值？
 *  @type select
 *  @option To player only
 *  @value player
 *  @option For all
 *  @value party
 *  @option For all divided
 *  @value partyDivided
 *  @option One who kill
 *  @value killer
 *  @default partyDivided
 *  @desc 队伍杀怪后如何分配经验?(从上到下依次是：仅玩家、所有人相等、所有人均分、最后一击者)
 * 
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text 是否使用自定义的升级效果？
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 是否使用自定义的升级效果而不用默认的？
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text 升级设置
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text UI元素设置
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text 血条蓝条
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 血条设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色血条显示设置
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 蓝条显示设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色蓝条显示设置
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 怒条显示设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色怒条（TP）显示设置
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 经验条设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色经验条显示设置
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text 怪物设置
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text UI元素设置
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text 怪物血条
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text 怪物头顶小血条
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 怪物头顶小血条（默认）
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text 自定义血条
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [专业版功能] 你可以使用<miniHpGaugeStyle>标签来给特定怪物自定义血条
 * 
 * @param enemyInfoVisualSettings:struct
 * @text 怪物信息
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc 怪物信息面板（当选中或悬浮时）
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 *  @param enemyAIUpdateThreadMS:int
 *  @parent enemySettingsGroup
 *  @text AI思考间隔周期
 *  @type number
 *  @min 1
 *  @max 200
 *  @default 100
 *  @desc 单位毫秒，数值越小AI思考速度越快
 * 
 *  @param enemyAIUpdateVisionIntervalFR:int
 *  @parent enemySettingsGroup
 *  @text AI视野检测周期
 *  @type number
 *  @min 1
 *  @max 32
 *  @default 4
 *  @desc 单位是游戏帧，数值越小则AI检测周围敌人越频繁
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text 怪物视觉盲区ID
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc 所有怪物均无法看见的视觉盲区ID集合
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text 怪物移动禁区ID
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc 地形标记（1到7）用于标记所有怪物均无法前进的区域
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Bonuses defenitions for bonusOnDeadIds ABS parameter
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text 出怪设置
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text 出怪模版地图ID
 * @type number
 * @min 0
 * @default 0
 * @desc [必选项] 用于生成怪物事件的模版地图， 0表示关闭出怪功能
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text 是否允许在其他事件上面出怪
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 是否允许在其他事件的位置上面出怪？
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text 是否启用区域缓存?
 * @type boolean
 * @on Yes (more performance)
 * @off No
 * @default true
 * @desc 如果在游戏过程中动态调整区域ID那么请关闭此选项
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text 出怪点
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc 用于命令<absSpawnPoint:ID>的出怪点. （查阅wiki手册以获取更详细说明）
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text 地图设置
 * 
 * @param mapScrolling:s
 * @text 地图滚动
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc 鼠标滚动地图的功能
 * 
 * @param map_noProjectilePass:intA
 * @parent mapSettingsGroup
 * @text 子弹无法穿越的区域ID合集
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc 子弹无法穿越的区域ID合集（全局所有子弹）
 * 
 * @param map_noProjectilePass2:intA
 * @parent mapSettingsGroup
 * @text 子弹无法穿越的地形标志ID合集
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc 子弹无法穿越的地形标志ID合集（1到7，全局所有子弹）
 * 
 * @param miniHpGaugeSetings:s
 * @text 迷你血条
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc 在ABS事件上显示的小血条
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV]动画缩放
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [仅限MV]在地图和ABS事件上播放的动画的缩放比例
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text 战斗自动播放BGM
 * @type struct<BattleAutoBGM>
 * @desc 当玩家进入战斗时是否自动播放BGM，你可以在地图的描述区使用<battleAutoBgm:NAME>为每个地图自定义BGM名称
 * @default {"name":"","delay:i":"0.50"}
 * 
 * @param spacer|mz3d @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mz3dSettingsGroup
 * @text MZ3D 设置
 * 
 * @param ANIMATION_DEPTH:b
 * @parent mz3dSettingsGroup
 * @text 动画深度
 * @desc 是否启用弹丸撞击动画的深度
 * @type boolean
 * @default true
 * 
 * @param ANIMATION_SCALE:i
 * @parent mz3dSettingsGroup
 * @text 动画缩放
 * @desc 弹丸撞击动画的缩放比例
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param WALL_HIT_BEHAVIOR:b
 * @parent mz3dSettingsGroup
 * @text 墙撞行为
 * @desc 当弹丸撞击墙壁时，它是撞击墙的底部还是顶部。
 * @type boolean
 * @on 底部
 * @off 顶部
 * @default true
 * 
 * @param PROJECTILE_Z_OFF:i
 * @parent mz3dSettingsGroup
 * @text 弹丸 Z 偏移
 * @desc 弹丸的 z 位置偏移
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param PROJECTILE_CLIMB_HEIGHT:i
 * @parent mz3dSettingsGroup
 * @text 弹丸攀爬高度
 * @desc 弹丸将与高于此高度的墙壁碰撞
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param PROJECTILE_CLIMB_TIME:i
 * @parent mz3dSettingsGroup
 * @text 弹丸攀爬时间
 * @desc 当弹丸爬到更高的高度时，达到新高度所需的时间。值越大=越慢
 * @type number
 * @default 5
 * 
 * @param PROJECTILE_FALL_TIME:i
 * @parent mz3dSettingsGroup
 * @text 弹丸下落时间
 * @desc 当弹丸从高处射出时，达到地面的时间。值越大=越慢
 * @type number
 * @default 25
 * 
 * @param WEAPON_POSITION_X:i
 * @parent mz3dSettingsGroup
 * @text 武器位置 X
 * @desc 武器精灵的水平位置
 * @type number
 * @decimals 3
 * @default 0.5
 * 
 * @param WEAPON_POSITION_Z:i
 * @parent mz3dSettingsGroup
 * @text 武器位置 Z
 * @desc 武器精灵的垂直位置
 * @type number
 * @decimals 3
 * @default 0.333
 * 
 * @param WEAPON_SCALE:i
 * @parent mz3dSettingsGroup
 * @text 武器缩放
 * @desc 武器精灵的缩放比例
 * @type number
 * @decimals 3
 * @default 1
 * 
 * @param WEAPON_INHERIT_SCALE:b
 * @parent mz3dSettingsGroup
 * @text 武器继承缩放
 * @desc 武器精灵是否应继承角色精灵的缩放比例
 * @type boolean
 * @default true
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * @command ABSEventSettings
 * @text ABS怪物配置
 * @desc Configurate enemy ABS parameters for this certaint event
 * 
 * @arg MainGroup
 * @text 主要部分
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text 视野半径
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc 怪物默认可以看多少地图格子
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text  返回半径
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc 怪物追玩家多少格就会返回初始位置
 * 
 *  @arg noMoveInBattle
 *  @parent MainGroup
 *  @text 战斗时无法移动
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则敌人在战斗中无法移动
 * 
 *  @arg noApproach
 *  @parent MainGroup
 *  @text 不会接近目标
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则敌人在战斗中不会接近目标
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text 死亡命令
 * @type text
 * @default
 * @desc 当怪物死亡时执行什么ABS脚本
 * 
 *  @arg onSeeTarget
 *  @parent MainGroup
 *  @text 检测目标触发脚本
 *  @type text
 *  @default
 *  @desc 当敌人检测到目标时执行的ABS脚本(SAction)
 * 
 *  @arg onHit
 *  @parent MainGroup
 *  @text 被击触发脚本
 *  @type text
 *  @default
 *  @desc 当敌人被击时(受到伤害＞0)检测到目标时执行的ABS脚本(SAction)
 * 
 *  @arg expVar
 *  @parent MainGroup
 *  @text 经验值变量
 *  @type variable
 *  @default 0
 *  @desc 如果设置为0，则读取数据库配置，如果不为0，则该数字为变量ID，读取该变量数值作为经验值
 * 
 *  @arg autoExp
 *  @parent MainGroup
 *  @text 自动获取经验
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则玩家杀怪后自动获取经验值
 * 
 *  @arg notAgressive
 *  @parent MainGroup
 *  @text 无主动攻击
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则怪物不会主动攻击玩家
 * 
 *  @arg teamId
 *  @parent MainGroup
 *  @text  队伍ID
 *  @type number
 *  @min 1
 *  @max 10
 *  @default 1
 *  @desc 拥有不同队伍ID的怪物会彼此互相攻击
 * 
 *  @arg onDeathVar
 *  @parent MainGroup
 *  @text 死亡变量
 *  @type variable
 *  @default 0
 *  @desc 如果不设置为0，则怪物死了以后这个数值会+1
 * 
 *  @arg saveHp
 *  @parent MainGroup
 *  @text 保留HP
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，玩家离开地图后再返回，怪物的HP会保留
 * 
 * 
 * @arg MapGroup
 * @text 地图部分
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text 碎裂效果?
 * @type boolean
 * @default true
 * @desc 当怪物死亡时是否播放破碎效果？
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text 死亡开关
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc 怪物死亡后将会开启哪个自开关 (0表示不开)
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text 死亡后清除？
 * @type boolean
 * @default true
 * @desc 怪物死亡后是否清除？（仅对未开启死亡开事件有效）
 * 
 *  @arg heavy
 *  @parent MapGroup
 *  @text 是否属于重物
 *  @type boolean
 *  @default false
 *  @desc 设置为重物时，无法被击退技能击退
 * 
 *  @arg weaponMotionType
 *  @parent MapGroup
 *  @text 武器动作类型
 *  @type number
 *  @min 0
 *  @max 100
 *  @default 0
 *  @desc 为武器技能设置武器动作类型
 * 
 *  @arg lootDropOnDeath
 *  @parent MapGroup
 *  @text 掉落
 *  @type boolean
 *  @default false
 *  @desc 设置为真时，怪物死后将会按照数据库的物品和金币来进行自动掉落
 * 
 * @arg VisualGroup
 * @text 可视化部分
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text 是否显示UI面板？
 * @type boolean
 * @default true
 * @desc 当鼠标悬浮怪物时是否显示其角色UI面板？
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text 脸图名称
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc 显示的脸图UI文件名
 * 
 * @arg faceIndex
 * @parent faceName
 * @text 脸图索引
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc 显示的脸图索引值（0到7）
 * 
 *  @arg miniHpGaugeStyle
 *  @parent VisualGroup
 *  @text 迷你血槽样式
 *  @type number
 *  @default
 *  @desc 怪物的小血槽样式，自定义插件参数
 * 
 * @arg AnimationGroup
 * @text 动画部分
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text 被击动画
 * @type animation
 * @default 1
 * @desc 当怪物攻击时播放的被击动画
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */

/*~struct~LStateIconSettings:

 @param visible:b
 @text Is Visible?
 @type boolean 
 @on Yes
 @off No
 @desc Will be this element visible?
 @default true 

 @param position:s
 @text Position
 @type struct<XY> 
 @desc Position on screen
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text Is Editable?
 @type boolean
 @default true
 @desc Can player edit this element in UI Editor?

 @param textFormat:str
 @text Time Left Format
 @type text 
 @desc %1 will be replaced by remaining time (in seconds)
 @default %1 

 @param textFormatA:str
 @text Actions Count Format
 @type text 
 @desc %1 will be replaced by remaining actions count [States only]
 @default A:%1 

 @param text:struct
 @text Time Text
 @type struct<CText> 
 @desc Timer or Actions count text settings
 @default {} 

 @param icon:s
 @text Icon
 @type struct<str6> 
 @desc Icon settings
 @default {} 

*/


/*~struct~LStateIconSettings:ru

 @param visible:b
 @text Видимый?
 @type boolean 
 @on Да, видимый
 @off Нет
 @desc Является ли данный элемент видимым?
 @default true 

 @param position:s
 @text Позиция
 @type struct<XY> 
 @desc Позиция на экране в пикселях
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text Редактируемый?
 @type boolean
 @default true
 @desc Может ли игрок редактировать этот элемент в UI редакторе?

 @param textFormat:str
 @text Осталось времени
 @type text 
 @desc Формат строки, сколько осталось времени. %1 будет заменён на оставшееся количество секунд
 @default %1 

 @param textFormatA:str
 @text Осталось действий
 @type text 
 @desc Формат строки. %1 будет заменён на оставшееся количество действия до конца состояния [Только для состояний]
 @default A:%1 

 @param text:struct
 @text Время (текст)
 @type struct<CText> 
 @desc Настройки текста остатка времени (действий)
 @default {} 

 @param icon:s
 @text Иконка
 @type struct<str6> 
 @desc Настройки иконки
 @default {} 

*/

/*~struct~LDamagePopUpVisualSettings:
 * @param id
 * @text ID
 * @default
 * @desc Unique ID for refer to this settings in <popUpStyleId:X> parameter
 *
 * @param randDX:int
 * @text Rand DX
 * @type number
 * @default 0
 * @min 0
 * @desc Random value in pixels (> 0) to add to X at Pop Up start (x +- DX)
 *
 * @param randDY:int
 * @text Rand DY
 * @type number
 * @default 0
 * @min 0
 * @desc Random value in pixels (> 0) to add to Y at Pop Up start (y + DY)
 *
 * @param stayTime:int
 * @text Life Time
 * @type number
 * @default 12
 * @min 1
 * @desc Life time before PopUp starts disapear
 *
 * @param changeFontSize:int
 * @text Final Font Size
 * @type number
 * @default 22
 * @min 1
 * @desc Final value of font size. Can be more, equal or less that in Value text settings 
 *
 *
 * @param noFlyUp:bool
 * @text Is NO Fly?
 * @type boolean
 * @default false
 * @on Stay still
 * @off Fly Up
 * @desc Will be pop up stay still? False - will fly up to disapear
 * 
 * @param noFadeOut:bool
 * @text Is NO Fade?
 * @type boolean
 * @default false
 * @on No Fade
 * @off Fade out
 * @desc Will be pop up stay opaque all time? False - will fade out to disapear
 * 
 * @param text:struct
 * @text Value Text
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc Text settings. TextBox Size parameter NOT uses.
 *
 * @param image:struct
 * @text Extra image
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/

/*~struct~LDamagePopUpVisualSettings:ru
 * @param id
 * @text ID
 * @default
 * @desc Уникальный ID данного стиля, ипользуется в параметре <popUpStyleId:X>
 *
 * @param randDX:int
 * @text Случ. X
 * @type number
 * @default 0
 * @min 0
 * @desc Случайное значение в пикселях, которое будет добавлено к координате Х (+-) на старте
 *
 * @param randDY:int
 * @text Случ. Y
 * @type number
 * @default 0
 * @min 0
 * @desc Случайное значение в пикселях, которое будет добавлено к координате Y (+-) на старте
 *
 * @param stayTime:int
 * @text Время жизни
 * @type number
 * @default 12
 * @min 1
 * @desc Время жизни в секундах перед тем как сообщение начнёт исчезать
 *
 * @param changeFontSize:int
 * @text Размер текста (конец)
 * @type number
 * @default 22
 * @min 1
 * @desc Конечное значение размера текста. Может быть больше, меньше, или равно (чтобы не изменялсь) значение в настройках текста
 *
 *
 * @param noFlyUp:bool
 * @text Статическое?
 * @type boolean
 * @default false
 * @on На месте
 * @off Летит
 * @desc Будет ли сообщение стоять на месте? ВЫКЛ - будет взлетать вверх при истечении срока жизни
 * 
 * @param noFadeOut:bool
 * @text Всегда видимое?
 * @type boolean
 * @default false
 * @on Всегда
 * @off Исчезает
 * @desc Будет ли сообщение всегда НЕ прозрачным? ВЫКЛ - будет исчезать при истечении срока жизни
 * 
 * @param text:struct
 * @text Текст
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc Настройки текста. Параметр - размер текста не используется.
 *
 * @param image:struct
 * @text Доп. изображение
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/


/*~struct~LDPUImage:
 * @param name
 * @text Name
 * @type file
 * @dir img/pictures/
 * @require 1
 * @default
 * @desc Optional. Addition image file for Pop Up Item.
 * 
 * @param margins:struct
 * @text Margin
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"0"}
 * @desc Position of image, relative Pop Up item
 *
 * @param fadeInSpeed:int
 * @text Fade speed
 * @type number
 * @default 20
 * @min 1
 * @desc Image fade in speed. Image starts transparent. Set to 255 to show image opaque immediately
 */

 /*~struct~LDPUExp:

    @param active:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is need show Pop Up when EXP given to character? No - disable at all

    @param styleId
    @text Settings ID
    @default Experience
    @desc Pop Up Settings ID from Pop Up Table parameter

    @param textFormat
    @text Text Format
    @default +%1 exp
    @desc Pop Up Text, %1 will be replaced to experience value

    @param aboveChar:b
    @text Is Above Character?
    @type boolean
    @on Yes (above char)
    @off No (above enemy)
    @default false
    @desc Exp Pop Up show above character or above killed enemy?

    @param bindToChar:b
    @text Bind to char?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc Pop Up will stay above character or (if false) on screen (and moved with screen)
 */

/*~struct~LDPUGold:

    @param popUpStyle:s
    @text Settings
    @type struct<LDamagePopUpVisualSettings> 
    @desc Pop Up Style settings
    @default {}

    @param textFormat
    @text Text Format
    @default %2%1
    @desc Pop Up Text, %1 will be replaced to gold value, %2 with - or +

    @param bindToChar:b
    @text Bind to char?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc Pop Up will stay above character or (if false) on screen (and moved with screen)
 */


/*~struct~LMiniHpGaugeSettings:
    @param active:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is need show Mini HP gauges for ABS events on map? No - disable at all

    @param showOnlyOnHover:b
    @text Is Show only on Hover?
    @type boolean
    @on Yes (hover)
    @off No (always)
    @default true
    @desc Is show Mini HP gauge only when event hovered? No - always

    @param showOnDamage:b
    @text Is Show on Damage?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is show Mini HP gauge for short time when ABS event receive damage?

    @param showWhenNotFull:b
    @text Is for damaged only?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc Is show Mini HP gauge for only for damaged ABS events (HP != 100%)?
*/
/*~struct~LMapScrollSettings:
    @param isEnabled:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc Is Map Scrolling enabled by default? For enable or disable during game you can use uAPI script calls.

    @param scrollZone:int
    @text Activation Border Size
    @type number
    @min 10
    @max 50
    @default 10
    @desc Scroll activation borders size on screen edges, in pixels

    @param speed:int
    @text Scrolling speed
    @type number
    @min 1
    @max 10
    @default 5
    @desc Camera scrolling speed

    @param delay:int
    @text Delay
    @type number
    @min 0
    @default 30
    @desc Delay in frames (60 = 1 second) before starts scrolling

    @param resetOnMove:b
    @text Reset when moving?
    @type boolean
    @on Reset
    @off No
    @default true
    @desc Center camera (reset scroll) when player starts moving?

    @param resetOnAction:b
    @text Reset on action?
    @type boolean
    @on Reset
    @off No
    @default true
    @desc Center camera (reset scroll) when player affected by any skill (get damage, attacked)?
*/
/*~struct~LSkillSlotItem:
 * @param position:struct
 * @text Position
 * @type struct<XY2>
 * @default
 * @desc Skill slot position on screen
 *
 * @param symbol
 * @text Key
 * @default
 * @desc Keyboard key for activate skill slot
 *
 * @param isEditable:b
 * @text Is editable?
 * @type boolean
 * @default true
 * @desc Can player edit slot? Open skills or items select menu
 *
 * @param isAutoset:b
 * @text Is auto?
 * @type boolean
 * @default true
 * @desc Can skill or item automatically been assign to this slot?
 *
 * @param filter:str
 * @text Filter
 * @parent isAutoset:b
 * @type combo
 * @option Any
 * @option Items
 * @option Skills
 * @default Any
 * @desc Filter works for auto assign only. (Is Auto - ON)
 *
 * @param specifiedIds:str
 * @text Specified Ids
 * @parent isAutoset:b
 * @default
 * @desc Slot can accept only this items or skill (depends on filter) ID's (separated by comma). Empty - all
 *
 * @param style:struct
 * @text Visual Settings
 * @type struct<LSkillSlotItemVisual> 
 * @default
 * @desc Skill Slot can have own visual settings. Or leave empty for default settings (Parameter: Skill Slot Visual)
 */

/*~struct~LInputSettings:

    @param LMBMapTouchMode
    @text LMB Map Touch
    @type select
    @option Primary attack
    @option Default (move)
    @option Nothing
    @default Default (move)
    @desc TODO: wiki page?

    @param RMBMapTouchMode
    @text RMB Map Touch
    @type select
    @option Default (menu)
    @option Secondary attack
    @option Move
    @option Turn
    @option Nothing
    @default Turn
    @desc TODO: wiki page?

    @param LMBTargetTouchMode
    @text LMB Target Touch
    @type select
    @option Primary attack
    @option Default (move)
    @option Smart attack (Primary)
    @option Turn
    @default Smart attack (Primary)
    @desc TODO: wiki page?

    @param RMBTargetTouchMode
    @text RMB Target Touch
    @type select
    @option Secondary attack
    @option Move
    @option Smart attack (Secondary)
    @option Turn
    @default Smart attack (Secondary)
    @desc TODO: wiki page?

    @param moveType
    @text Movement
    @type select
    @option WASD and Arrows
    @option Arrows only
    @default WASD and Arrows
    @desc Keyboard keys for character movement

    @param isDiagonalMovement:b
    @text Diagonal Movement?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (For Player and Allies)

    @param isDiagonalMovementAI:b
    @text Diagonal Movement for AI?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (for Enemies (Events))

    @param isStaticAtkRot:b
    @text Attack when rotation?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Always only attack (no move) when rotating if mouse clicked on map?

    @param multiTouch:b
    @text Allow MultiTouch?
    @type boolean
    @default false
    @on Yes
    @off No
    @desc [For devices with touchscreen] Allow multitouch control?

    @param keybingind
    @text Key Bindings

    @param kbReload
    @text Reload
    @parent keybingind
    @default R
    @desc TODO:

    @param kbCommandMenu
    @text Commands
    @parent keybingind
    @default C
    @desc TODO:

    @param kbRotate
    @text Rotate
    @parent keybingind
    @default Control
    @desc TODO:

*/
/*~struct~LActorGauge:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this gauge visible at start?
 * 
 * @param position:struct
 * @text Position
 * @type struct<XY2>
 * @default
 * @desc Position on screen
 * 
 * @param label
 * @text Label
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Label image for gauge, optional
 * 
 * @param labelMargins:struct
 * @text Label Margins
 * @type struct<XY>
 * @default
 * @desc Position of label, relative gauge
 *
 * @param isCanBeEdited:bool
 * @text Is Editable?
 * @type boolean
 * @default true
 * @desc Can player edit this gauge in UI Editor?
 *
 * @param isHideWithMessage:bool
 * @text Is Hide by Msg?
 * @type boolean
 * @default true
 * @desc Hide this UI element when message window appears?
 * 
 * @param text:struct
 * @text Value Text
 * @type struct<CText>
 * 
 * @param gauge:struct
 * @text Gauge
 * @type struct<CGauge>
 * 
 * 
*/
/*~struct~CGauge:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this gauge visible?
 *
 * @param vertical:bool
 * @text Is Vertical?
 * @type boolean
 * @default false
 * @desc Gauge will use vertical fill?
 * 
 * @param fill
 * @text Fill Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Gaguge fill image, required!
 * 
 * @param foreground
 * @text Foreground Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Image above gauge fill, optional
 * 
 * @param mask
 * @text Mask Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Whole gauge image mask, optional
 * 
 * @param backColor:css
 * @type string
 * @text Background Color
 * @default #000000
 * @desc Text color in HEX format (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text Background Opacity
 * @default 255
 * @desc from 0 to 255, 0 - transparent, 255 - opaque
 */
/*~struct~CText:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this text visible?
 * 
 * @param size:struct
 * @text TextBox Size
 * @type struct<WH>
 * @default
 * @desc Size of text zone
 * 
 * @param margins:struct
 * @text Margin
 * @type struct<XY>
 * @default
 * @desc Position of text, relative parent
 * 
 * @param alignment:str
 * @text Alignment
 * @type combo
 * @option center
 * @option right
 * @option left
 * @default center
 * @desc Text alignment
 * 
 * @param outline:struct
 * @text Text Outline
 * @type struct<Outline>
 * @default
 * @desc Text outline settings
 * 
 * @param font:struct
 * @type struct<Font>
 * @text Font Settings
 * @default
 * @desc Text font settings
 * 
 * @param textColor:css
 * @type string
 * @text Text Color
 * @default #FFFFFF
 * @desc Text color in HEX format (#000000)
 * 
 */
/*~struct~XY:
 * @param x:int
 * @text X
 * @type number
 * @default 0
 * @min -1000
 *
 * @param y:int
 * @text Y
 * @type number
 * @default 0
 * @min -1000
 */
/*~struct~XY2:
 * @param x:e
 * @text X
 * @type text
 * @default 0
 * @desc Number or script (example: Graphics.width / 2)
 *
 * @param y:e
 * @text Y
 * @type text
 * @default 0
 * @desc Number or script (example: $gameVariables.value(12) * 2)
 */
/*~struct~WH:
 * @param w:int
 * @text Width
 * @type number
 * @default 100
 * @min 0
 *
 * @param h:int
 * @text Height
 * @type number
 * @default 100
 * @min 0
 */
/*~struct~Font:
 * @param face:str
 * @text Face
 * @type combo
 * @option AABS_0
 * @option AABS_1
 * @option AABS_2
 * @option AABS_3
 * @default AABS_0
 *
 * @param size:int
 * @text Size
 * @type number
 * @default 24
 * @min 1
 * 
 * @param italic:bool
 * @text IsItalic
 * @type boolean
 * @default false
 */
/*~struct~Outline:
 * @param color:css
 * @text Color
 * @type text
 * @default #000000
 * @desc Outline color in HEX (#000000) or empty "" (black)
 *
 * @param width:int
 * @text Width
 * @type number
 * @default 3
 * @min 0
 * @desc Outline stroke width in px
 */
 /*~struct~str6:

 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this element visible? 


 @param index:i
 @text Icon Index
 @type number 
 @min 0
 @desc Icon index on IconSet
 @default 0 

 @param size:i
 @text Icon Size
 @type number 
 @min 2
 @desc Icon Size in PX (default icons size is 32)
 @default 32 

*/

/*~struct~LEnemyCustomMiniGauge:
    @param id
    @text ID
    @desc Use in parameter <miniHpGaugeStyle:ID>
    @default custom1

    @param gauge:struct
    @text Settings
    @type struct<LActorGauge>
    @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
    @desc Mini HP gauge settings for this style
*/

/*~struct~LSkillSLotItemVisualIcon:

 @param visible:b
 @text 
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 


 @param size:i
 @text 
 @type number 
 @min 0
 @desc 
 @default 32 


 @param index:i
 @text 
 @type number 
 @min 0
 @desc 
 @default 0 

*/

/*~struct~LSkillSlotItemVisual:

 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this skill slot visible?


 * @param isCanBeEdited:bool
 * @text Is Editable?
 * @type boolean
 * @default true
 * @desc Can player edit this skill slot in UI Editor? 


 * @param isHideWithMessage:bool
 * @text Is Hide by Msg?
 * @type boolean
 * @default true
 * @desc Hide this UI element when message window appears? 

 @param outlineGroup
 @text Outline

 @param outlineMargins:s
 @parent outlineGroup
 @text Outline Margin
 @type struct<XY> 
 @desc Outline effect color margin
 @default {} 


 @param outlinePulseSpeed:i
 @parent outlineGroup
 @text Pulse Speed
 @type number 
 @min 1
 @max 255
 @desc Pulse effect speed in frames
 @default 40 


 @param selectedOutlineColor:str
 @parent outlineGroup
 @text Selected
 @type text 
 @desc Color for outline when skill slot is selected (in HEX format)
 @default #fcba03 


 @param clickedOutlineColor:str
 @parent outlineGroup
 @text Click
 @type text 
 @desc Color for outline when skill slot is clicked \ activated (in HEX format)
 @default #0b03fc 


 @param readyOutlineColor:str
 @parent outlineGroup
 @text Ready
 @type text 
 @desc Color for outline when skill slot is ready to use (in HEX format)
 @default #21b53c 


 @param badOutlineColor:str
 @parent outlineGroup
 @text Forbidden
 @type text 
 @desc Color for outline when skill slot is can't be used (in HEX format)
 @default #d61a1a 


 @param icon:s
 @text Icon settings
 @type struct<LSkillSLotItemVisualIcon> 
 @desc Skill and Item icons on skill slot settings. Icon Index is ignored.
 @default {} 

 @param iconMargins:s
 @text Icon Margin
 @parent icon:s
 @type struct<XY> 
 @desc Icon margins
 @default {} 

 @param symbolText:s
 @text Symbol Text
 @type struct<CText> 
 @desc Symbol (key) text settings
 @default {} 


 @param timeText:s
 @text Time Text
 @type struct<CText> 
 @desc Timer text settings
 @default {} 


 @param countText:s
 @text Count Text
 @type struct<CText> 
 @desc Count text settings
 @default {} 

*/


/*~struct~LUIFaceElement:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible?


 @param faceName
 @text Face Image
 @type file
 @require 1
 @dir img/face/
 @desc Face image name
 @default  


 @param faceIndex:i
 @parent faceName
 @text Index
 @type number 
 @min 0
 @desc Index on Face Image
 @default 0 


 @param mirror:b
 @text Mirror
 @type boolean 
 @on Yes
 @off No
 @desc Is mirror face image (from left to right)?
 @default false 


 @param size:i
 @text Size
 @type number 
 @desc Face size in px (default RPG Maker faces size is 144)
 @default 74 


 @param margins:s
 @text Margins
 @type struct<XY> 
 @desc Face image margins
 @default {}

*/
/*~struct~LUIImageElement:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible? 


 @param image
 @text Image
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default 


 @param margins:s
 @text Margins
 @type struct<XY> 
 @desc Image margins
 @default {}

*/

/*~struct~LEnemyInfoVisual:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible? 


 @param position:struct
 @text Position
 @type struct<XY2>
 @default
 @desc Position on screen


 @param image
 @text Background
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default Enemy_Background 


 @param isCanBeEdited:bool
 @text Is Editable?
 @type boolean
 @default true
 @desc Can player edit this element in UI Editor? 


 @param isHideWithMessage:bool
 @text Is Hide by Msg?
 @type boolean
 @default true
 @desc Hide this UI element when message window appears? 


 @param nameFormat
 @text Name Format
 @type text 
 @desc %1 will be replaced by Enemy Name
 @default %1


 @param levelFormat
 @text Level Format
 @type text 
 @desc %1 will be replaced by Enemy Level
 @default Lv. %1 


 @param hpTextFormat
 @text HP Format
 @type text 
 @desc %1 - HP, %2 - MHP, %3 - Rate in %
 @default %1 / %2 


 @param nameText:s
 @parent nameFormat
 @text Text
 @type struct<CText> 
 @desc Enemy name text style
 @default {} 


 @param hpText:s
 @parent hpTextFormat
 @text Text
 @type struct<CText> 
 @desc Enemy HP text style
 @default {} 


 @param levelText:s
 @parent levelFormat
 @text Text
 @type struct<CText> 
 @desc Enemy level text style
 @default {} 


 @param gauge:s
 @text HP gauge
 @type struct<CGauge> 
 @desc Enemy HP gauge style
 @default {} 

 @param gaugeMargins:s
 @parent gauge:s
 @text Margins
 @type struct<XY> 
 @desc HP gauge margins
 @default {}

 @param face:s
 @text Face
 @type struct<LUIFaceElement> 
 @desc Enemy Face settings. Face Name and Index not used.
 @default {} 


 @param battleState:s
 @text Battle Icon
 @type struct<LUIImageElement> 
 @desc Enemy In Battle State Icon Image
 @default {} 


 @param foregroundImage:s
 @text Foreground
 @type struct<LUIImageElement> 
 @desc Foreground image
 @default {} 

*/

/*~struct~LSpawnPoint:

 @param id:str
 @text ID
 @type text 
 @desc Unique spawn point ID for <absSpawnPoint:ID> event comment
 @default spawnPoint

 @param spawnPointType:str
 @text Spawn Type
 @type select
 @option self
 @option region
 @option player
 @desc Self - spawn around self (event). Region - spawn in certain region. Player - spawn around player.
 @default self 

 @param spawnRadius:str
 @parent spawnPointType:str
 @text Radius or Region
 @type text
 @desc Radius (self, player) or Region (for region type) [Extended Value]
 @default 3

 @param spawnMax:str
 @text Max
 @type text 
 @desc Maximum spawned enemies count. 0 - not limits. [Extended Value]
 @default 3


 @param spawnAliveMax:str
 @parent spawnMax:str
 @text Max alive
 @type text 
 @desc Max. alive spawned enemies at same time. 0 - not limits. [Extended Value]
 @default 2 


 @param spawnRate:str
 @text Rate
 @type text 
 @desc Spawn once at (Rate) seconds. Minimum 1. [Extended Value]
 @default 4

 @param spawnEnemiesId:str
 @text Events to spawn
 @type text 
 @desc Enemies events (from Spawn Map) id's for spawn. [Extended Value]
 @default 1, 2, 3


 @param conditionSwitch:i
 @text Switch
 @type switch 
 @desc 0 - no any. If Switch if FALSE -> not spawn.
 @default 0

 @param visorRadius:i
 @text Visor
 @type number 
 @min 0
 @desc 0 - always. X - player should be in this range from spawn point for spawning process.
 @default 3


 @param endCommonEvent:i
 @text On Reach Max
 @type common_event 
 @desc Call common event when spawned Max count is reached
 @default 0

*/


/*~struct~LCustomLevelUpSettings:

 @param databaseAnimationId:i
 @text Animation [DB]
 @type animation 
 @min 0
 @desc 0 - no animation.
 @default 0

 @param imageSeqAnimationName:str
 @text Animation [File]
 @type file
 @dir img/pictures/
 @desc Optional, Rule: filename(frames,delay).png
 @default

 @param imageSeqAnimationMargins:s
 @parent imageSeqAnimationName:str
 @text Margins
 @type struct<XY> 
 @desc 
 @default {} 

 @param extraSE:str
 @text Sound Effect
 @type file
 @dir audio/se/
 @require 1
 @desc Optional, leave empty for nothing
 @default

 @param isShowPopUp:b
 @text Is Show PopUp?
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 

 @param popUpText:str
 @parent isShowPopUp:b
 @text Text
 @type text
 @desc %1 will be replaced by new level value (number)
 @default Level %1! 

 @param popUpStyle:s
 @parent isShowPopUp:b
 @text Settings
 @type struct<LDamagePopUpVisualSettings> 
 @desc Pop Up Style settings
 @default {} 

 @param commonEvent:i
 @text Common Event
 @type common_event 
 @min 0
 @desc Common event call on Level Up
 @default 0 

 @param scriptAction:str
 @text Script Action
 @type text 
 @desc Script action on Level Up (relative to character)
 @default

*/



/*~struct~LBloodSplatterEffectSettings:
 @param BS_Picture
 @text Effect Image
 @type file
 @dir img/pictures/
 @require 1
 @desc Optional. Image for effect.
 
 @param BS_Color
 @text Effect Color
 @type string
 @default #F98822
 @desc HEX value or empty
 
 @param BS_Opacity:int
 @text Effect Opacity
 @type number
 @min 0
 @max 255
 @default 124
 @desc From 0 (transparent) to 255 (opaque)
 
 @param BS_HpRate:int
 @text HP Rate
 @type number
 @min 1
 @max 99
 @default 15
 @desc Percentage of health at which the effect is activated
 */

 /*~struct~FlyBonus:
    @param image:str
    @text Image
    @type file
    @dir img/pictures/
    @require 1 
    @desc Bonus image, supports animated
    @default bonusGreen 

    @param actionSE:str
    @text Action SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when player got bonus
    @default  

    @param spawnSE:str
    @text Appear SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when bonus is appears
    @default  

    @param startOffsetRadiusInPx:i
    @text Offset
    @type number 
    @min 0
    @max 48
    @desc Appear position max offset in PX from start point
    @default 16 

    @param stayFrames:i
    @text Delay
    @type number 
    @min 0
    @desc Delay in frames! before bonus fly to the player
    @default 12 

    @param flySpeed:i
    @text Speed
    @type number 
    @min 1
    @max 100
    @desc Fly speed (in PX)
    @default 8

    @param actionSA:str
    @text SAction
    @type text 
    @desc Optional. SAction executed on player when received this bonuse.
    @default

    @param hpGainE
    @text HP Gain
    @desc Optional. How many HP this bonus gain to the player. EVal supported.
    @default 25 

    @param mpGainE
    @text MP Gain
    @desc Optional. How many MP this bonus gain to the player. EVal supported.
    @default 0

    @param expGainE
    @text EXP Gain
    @desc Optional. How many EXP this bonus gain to the player. EVal supported.
    @default 0 

    @param goldGainE
    @text Gold Gain
    @desc Optional. How many Gold this bonus gain to the player. EVal supported.
    @default 0
 */

 /*~struct~LDodgeActionSettings:

@param dodgeKey
@text Keyboard key
@default f

@param dodgeSwitch:i
@text Enable Switch
@type switch
@desc When this Switch is TRUE, player can do Dodge. 0 - always can

@param isInvincible:b
@text Is Invincible?
@type boolean
@desc If TRUE, player can't receive any damage while in Dodge motion

@param stepsCount:i
@text Move steps
@type number
@min 1
@max 2
@default 2
@desc How far player will move while dodge (1 or 2)

@param delayBetweenStepMS:i
@text Delay MS
@type number
@min 0
@default 100
@desc Delay (in miliseconds) between every move step in dodge

@param dodgeMoveSpeed:i
@text Speed
@type number
@min 4
@default 5
@desc Player move speed in dodge action

@param dodgeRestTimerFrames:i
@text Recharge Time
@type number
@min 0
@default 30
@desc Dodge action recharge time (in FRAMES)

@param dodgeRestVariable:i
@parent dodgeRestTimerFrames:i
@text Recharge Var
@type variable
@default 0
@desc If > 0, then will be used recharge time (in FRAMES) from this Variable.
 */


/*~struct~BattleAutoBGM:

 @param name
 @text BGM
 @type file
 @require 1
 @dir audio/BGM/
 @desc Leave empty if you don't need battle auto BGM at all or want use from Map's notetag
 @default

@param delay:i
@text Delay
@type number
@decimals 2
@min 0
@default 0.5
@desc Delay IN SECONDS (fade in / out) music before starts or ends

 */

 /*~struct~CGaugeCustom:
 * @param id
 * @text Unique ID
 * @default myGauge
 * @desc ID for refer to this gauge settings from uAPI script call
 *
 * @param vertical:bool
 * @text Is Vertical?
 * @type boolean
 * @default false
 * @desc Gauge will use vertical fill?
 * 
 * @param fill
 * @text Fill Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Gaguge fill image, required!
 * 
 * @param foreground
 * @text Foreground Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Image above gauge fill, optional
 * 
 * @param mask
 * @text Mask Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Whole gauge image mask, optional
 * 
 * @param backColor:css
 * @type string
 * @text Background Color
 * @default #000000
 * @desc Text color in HEX format (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text Background Opacity
 * @default 255
 * @desc from 0 to 255, 0 - transparent, 255 - opaque
 *
 *
 * @param gaugeCaption
 * @text Caption
 *
 * @param text:struct
 * @parent gaugeCaption
 * @type struct<CText> 
 * @text Text Settings
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"200\",\"h:int\":\"30\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"2\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"24\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 *
 * @param textFormat
 * @parent gaugeCaption
 * @text Format
 * @default $1 / $2
 * @desc Write $1 for current value, $2 for max value, $3 for %
 */

 
 /*~struct~AAColTerrain:
 
 * @param terrainTag:int
 * @type number
 * @min 1
 * @max 7
 * @text Terrain Tag
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig> 
 * @text Collider
 * @default
 * @desc Collider for all map cells with specified terrain tag

 */

 /*~struct~AAColRegion:
 
 * @param regionId:int
 * @type number
 * @min 1
 * @max 255
 * @text Region Id
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig> 
 * @text Collider
 * @default
 * @desc Collider for all map cells with specified region id

 */

 /*~struct~AAColliderConfig:
 *  
 * @param type
 * @type select
 * @option Box (rectangle)
 * @value b
 * @option Circle
 * @value c
 * @text Type
 * @default b
 * @desc Collider type. Box (rectangle) or Circle
 *
 * @param dx:int
 * @type number
 * @text Offset by X
 * @default 0
 *
 * @param dy:int
 * @type number
 * @text Offset by Y
 * @default 0
 *
 * @param onlyForBox
 * @text Only for Box
 *
 * @param width:int
 * @parent onlyForBox
 * @type number
 * @text Width
 * @min 1
 * @default 48
 *
 * @param height:int
 * @parent onlyForBox
 * @type number
 * @min 1
 * @text Height
 * @default 48
 *
 * @param onlyForCircle
 * @text Only for Circle
 *
 * @param radius:int
 * @parent onlyForCircle
 * @type number
 * @min 1
 * @text Radius
 * @default 16
 */

/*~struct~LStateIconSettings:zh-cn

 @param visible:b
 @text 是否可见？
 @type boolean 
 @on Yes
 @off No
 @desc 此元素是否可见？
 @default true 

 @param position:s
 @text 位置
 @type struct<XY> 
 @desc 屏幕上的位置
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text 是否可编辑？
 @type boolean
 @default true
 @desc 玩家是否可以在UI编辑器里编辑此元素？

 @param textFormat:str
 @text 剩余时间格式
 @type text 
 @desc 显示剩余时间时，%1符号将被替换为XX秒
 @default %1

 @param textFormatA:str
 @text 动作数量格式
 @type text 
 @desc %1 将被剩余动作数量替代 [仅限状态]
 @default A:%1

 @param text:struct
 @text 时间文本
 @type struct<CText> 
 @desc 计时器和动作显示数量格式
 @default {} 

 @param icon:s
 @text 图标
 @type struct<str6> 
 @desc 图标设置
 @default {} 

*/


/*~struct~LDamagePopUpVisualSettings:zh-cn
 * @param id
 * @text ID
 * @default
 * @desc 在<popUpStyleId:X>参数中使用的唯一标识
 *
 * @param randDX:int
 * @text 随机DX距离（水平）
 * @type number
 * @default 0
 * @min 0
 * @desc 在弹出时随机追加的X轴距离（像素）
 *
 * @param randDY:int
 * @text 随机DY
距离（垂直）
 * @type number
 * @default 0
 * @min 0
 * @desc 在弹出时随机追加的Y轴距离（像素）
 *
 * @param stayTime:int
 * @text 持续时间
 * @type number
 * @default 12
 * @min 1
 * @desc 弹出数字的持续时间（帧数）
 *
 * @param changeFontSize:int
 * @text 最终字体大小
 * @type number
 * @default 22
 * @min 1
 * @desc 最终字体大小，可以比设置中的字体大或者小
 *
 *
 * @param noFlyUp:bool
 * @text 是否往上飘？
 * @type boolean
 * @default false
 * @on Stay still
 * @off Fly Up
 * @desc 选是则表示会往上飘，反之则原地不动
 * 
 * @param noFadeOut:bool
 * @text 是否取消淡出效果？
 * @type boolean
 * @default false
 * @on No Fade
 * @off Fade out
 * @desc 选是则表示固定可见度，选否则表示有淡出效果
 * 
 * @param text:struct
 * @text 文本值
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc 文本设置. 文本框大小并未使用
 *
 * @param image:struct
 * @text 额外图片
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/


/*~struct~LDPUImage:zh-cn
 * @param name
 * @text 名称
 * @type file
 * @dir img/pictures/
 * @require 1
 * @default
 * @desc 可选项. 弹出物品提示时的额外图片
 * 
 * @param margins:struct
 * @text 对齐
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"0"}
 * @desc 相对的弹出物品提示的图片相对位置
 *
 * @param fadeInSpeed:int
 * @text 消失速度
 * @type number
 * @default 20
 * @min 1
 * @desc 图片消失速度，图片开始是透明的，设置为255表示一直可见
 */

 /*~struct~LDPUExp:zh-cn

    @param active:b
    @text 是否启用？
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 角色获得经验时是否有提示? 选No表示关闭此功能

    @param styleId
    @text 设置ID
    @default Experience
    @desc 按照设置的参数ID弹出的样式

    @param textFormat
    @text 文本格式
    @default +%1 exp
    @desc 弹出文字, %1会被替换成经验值

    @param aboveChar:b
    @text 是否在角色上面?
    @type boolean
    @on Yes (above char)
    @off No (above enemy)
    @default false
    @desc 是在角色头上还是在怪物头上出现?

    @param bindToChar:b
    @text 与角色绑定?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc 飘出的数字是跟随角色还是跟随屏幕？
 */

    /*~struct~LDPUGold:zh-cn

    @param popUpStyle:s
    @text Settings
    @type struct<LDamagePopUpVisualSettings> 
    @desc Pop Up Style settings
    @default {}

    @param textFormat
    @text Text Format
    @default %2%1
    @desc Pop Up Text, %1 will be replaced to gold value, %2 with - or +

    @param bindToChar:b
    @text 与角色绑定?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc 飘出的数字是跟随角色还是跟随屏幕？
 */


/*~struct~LMiniHpGaugeSettings:zh-cn
    @param active:b
    @text 是否启用?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 在ABS事件上是否显示血条? 选No关闭此功能

    @param showOnlyOnHover:b
    @text 是否仅在悬浮状态下显示?
    @type boolean
    @on Yes (hover)
    @off No (always)
    @default true
    @desc 选是表示仅为悬浮显示? 选No表示永远显示

    @param showOnDamage:b
    @text 在受伤时显示?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 在ABS事件受伤时显示一小段时间？

    @param showWhenNotFull:b
    @text 是否只为不满血的显示?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc 是否只显示非满血的事件?
*/
/*~struct~LMapScrollSettings:zh-cn
    @param isEnabled:b
    @text 是否启用?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc 默认是否启用鼠标滚屏？（游戏中可通过uAPi脚本来开关控制）

    @param scrollZone:int
    @text 激活边缘大小
    @type number
    @min 10
    @max 50
    @default 10
    @desc 在屏幕边缘时激活滚屏功能的像素大小

    @param speed:int
    @text 滚屏速度
    @type number
    @min 1
    @max 10
    @default 5
    @desc 镜头滚动速度

    @param delay:int
    @text 延迟
    @type number
    @min 0
    @default 30
    @desc 滚屏延迟帧数(60帧 = 1秒)

    @param resetOnMove:b
    @text 当角色移动时是否恢复？
    @type boolean
    @on Reset
    @off No
    @default true
    @desc 当角色开始移动时是否镜头恢复到角色为中心？

    @param resetOnAction:b
    @text 当角色有动作时是否恢复？
    @type boolean
    @on Reset
    @off No
    @default true
    @desc 当角色开始动作时（攻击或被攻击）是否镜头恢复到角色为中心？
*/
/*~struct~LSkillSlotItem:zh-cn
 * @param position:struct
 * @text 位置
 * @type struct<XY2>
 * @default
 * @desc 技能栏在屏幕中的位置
 *
 * @param symbol
 * @text 快捷键
 * @default
 * @desc 激活技能栏的快捷键
 *
 * @param isEditable:b
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 角色是否可以编辑技能栏? 也就是打开技能或物品的选择菜单
 *
 * @param isAutoset:b
 * @text 是否自动装配快捷栏?
 * @type boolean
 * @default true
 * @desc 技能或物品是否会自动的装配到这个快捷栏中？
 *
 * @param filter:str
 * @text 筛选
 * @parent isAutoset:b
 * @type combo
 * @option Any
 * @option Items
 * @option Skills
 * @default Any
 * @desc 筛选功能仅为开启自动装配功能时有用. (自动筛选=开启此功能)
 *
 * @param specifiedIds:str
 * @text 指定的ID集合
 * @parent isAutoset:b
 * @default
 * @desc 技能栏只能放置某些特定的物品或技能（用半角逗号分隔），不填表示都接受
 *
 * @param style:struct
 * @text 可视化设置
 * @type struct<LSkillSlotItemVisual> 
 * @default
 * @desc 技能栏可以有自定义的显示效果。留空表示不用此功能 (参数: 技能栏可视化)
 */

/*~struct~LInputSettings:zh-cn

    @param LMBMapTouchMode
    @text 鼠标左键（点地图）
    @type select
    @option Primary attack
    @option Default (move)
    @option Nothing
    @default Default (move)
    @desc 

    @param RMBMapTouchMode
    @text 鼠标右键（点地图）
    @type select
    @option Default (menu)
    @option Secondary attack
    @option Move
    @option Turn
    @option Nothing
    @default Turn
    @desc 

    @param LMBTargetTouchMode
    @text 鼠标左键（点怪）
    @type select
    @option Primary attack
    @option Default (move)
    @option Smart attack (Primary)
    @option Turn
    @default Smart attack (Primary)
    @desc 

    @param RMBTargetTouchMode
    @text 鼠标右键（点怪）
    @type select
    @option Secondary attack
    @option Move
    @option Smart attack (Secondary)
    @option Turn
    @default Smart attack (Secondary)
    @desc 

    @param moveType
    @text 移动
    @type select
    @option WASD and Arrows
    @option Arrows only
    @default WASD and Arrows
    @desc 控制角色移动的快捷键

    @param isDiagonalMovement:b
    @text 斜向移动？
    @type boolean
    @default true
    @on Yes
    @off No
    @desc 是否允许8方向移动

    @param isDiagonalMovementAI:b
    @text Diagonal Movement for AI?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (for Enemies (Events))

    @param isStaticAtkRot:b
    @text 角色转身时是否可攻击？
    @type boolean
    @default true
    @on Yes
    @off No
    @desc 当用鼠标点击地图时是否只攻击不移动（转身时）

    @param multiTouch:b
    @text 是否允许多点触控？
    @type boolean
    @default false
    @on Yes
    @off No
    @desc [仅限触摸屏]是否允许多点触控式的操作？

    @param keybingind
    @text 键位绑定

    @param kbReload
    @text 装填子弹
    @parent keybingind
    @default R
    @desc

    @param kbCommandMenu
    @text 命令
    @parent keybingind
    @default C
    @desc

    @param kbRotate
    @text 转向
    @parent keybingind
    @default Control
    @desc

*/
/*~struct~LActorGauge:zh-cn
 * @param visible:bool
 * @text 是否可见？
 * @type boolean
 * @default true
 * @desc 初始时此能量槽是否可见？
 * 
 * @param position:struct
 * @text 位置
 * @type struct<XY2>
 * @default
 * @desc 屏幕位置
 * 
 * @param label
 * @text 标签
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 可选项，能量槽的标签图片
 * 
 * @param labelMargins:struct
 * @text 标签偏移量
 * @type struct<XY>
 * @default
 * @desc 相对于能量槽标签图片的偏移量
 *
 * @param isCanBeEdited:bool
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 玩家是否可以在UI编辑器中编辑？
 *
 * @param isHideWithMessage:bool
 * @text 是否隐藏？
 * @type boolean
 * @default true
 * @desc 当对话窗口弹出时是否
隐藏？
 * 
 * @param text:struct
 * @text 文本值
 * @type struct<CText>
 * 
 * @param gauge:struct
 * @text 能量槽
 * @type struct<CGauge>
 * 
 * 
*/
/*~struct~CGauge:zh-cn
 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此能量槽是否可见?
 *
 * @param vertical:bool
 * @text 是否为垂直显示?
 * @type boolean
 * @default false
 * @desc 此能量槽是否为垂直填充?
 * 
 * @param fill
 * @text 填充图像
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 需要提供一个填充图像
 * 
 * @param foreground
 * @text 前景图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 在能量槽上方的图片, 可选项
 * 
 * @param mask
 * @text 遮罩图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 整体遮罩图片, 可选项
 * 
 * @param backColor:css
 * @type string
 * @text 背景色
 * @default #000000
 * @desc 16进制颜色 (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text 背景可见度
 * @default 255
 * @desc 输入0到255的值, 0=透明, 255=不透明
 */
/*~struct~CText:zh-cn
 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 当前文本是否可见?
 * 
 * @param size:struct
 * @text 文本框大小
 * @type struct<WH>
 * @default
 * @desc 文本框区域大小
 * 
 * @param margins:struct
 * @text 偏移
 * @type struct<XY>
 * @default
 * @desc 基于父类的文本框偏移位置
 * 
 * @param alignment:str
 * @text 对齐方式
 * @type combo
 * @option center
 * @option right
 * @option left
 * @default center
 * @desc 居中，右对齐，左对齐
 * 
 * @param outline:struct
 * @text 文本描边
 * @type struct<Outline>
 * @default
 * @desc 文本描边设定
 * 
 * @param font:struct
 * @type struct<Font>
 * @text 字体设定
 * @default
 * @desc 字体设定
 * 
 * @param textColor:css
 * @type string
 * @text 字体颜色
 * @default #FFFFFF
 * @desc 字体颜色16进制代码 (#000000)
 * 
 */
/*~struct~XY:zh-cn
 * @param x:int
 * @text X
 * @type number
 * @default 0
 * @min -1000
 *
 * @param y:int
 * @text Y
 * @type number
 * @default 0
 * @min -1000
 */
/*~struct~XY2:zh-cn
 * @param x:e
 * @text X
 * @type text
 * @default 0
 * @desc 此处应输入脚本 (例如: Graphics.width / 2)
 *
 * @param y:e
 * @text Y
 * @type text
 * @default 0
 * @desc 此处应输入脚本 (例如: $gameVariables.value(12) * 2)
 */
/*~struct~WH:zh-cn
 * @param w:int
 * @text 宽度
 * @type number
 * @default 100
 * @min 0
 *
 * @param h:int
 * @text 高度
 * @type number
 * @default 100
 * @min 0
 */
/*~struct~Font:zh-cn
 * @param face:str
 * @text 字体
 * @type combo
 * @option AABS_0
 * @option AABS_1
 * @option AABS_2
 * @option AABS_3
 * @default AABS_0
 *
 * @param size:int
 * @text 大小
 * @type number
 * @default 24
 * @min 1
 * 
 * @param italic:bool
 * @text 斜体
 * @type boolean
 * @default false
 */
/*~struct~Outline:zh-cn
 * @param color:css
 * @text 颜色
 * @type text
 * @default #000000
 * @desc Outline color in HEX (#000000) or empty "" (black)
 *
 * @param width:int
 * @text 宽度
 * @type number
 * @default 3
 * @min 0
 * @desc 字体描边厚度
 */
 /*~struct~str6:zh-cn

 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此元素是否可见? 


 @param index:i
 @text 图标索引
 @type number 
 @min 0
 @desc 在图标集中的索引值
 @default 0 

 @param size:i
 @text 图标大小
 @type number 
 @min 2
 @desc 图标大小 (默认是32)
 @default 32 

*/

/*~struct~LEnemyCustomMiniGauge:zh-cn
    @param id
    @text ID
    @desc 在此命令中使用：<miniHpGaugeStyle:ID>
    @default custom1

    @param gauge:struct
    @text 设置
    @type struct<LActorGauge>
    @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
    @desc 当前样式的迷你HP血条显示设置
*/

/*~struct~LSkillSLotItemVisualIcon:zh-cn

 @param visible:b
 @text 
 @type boolean 
 @on Yes
 @off No
 @desc 可视化
 @default true 


 @param size:i
 @text 
 @type number 
 @min 0
 @desc 尺寸
 @default 32 


 @param index:i
 @text 
 @type number 
 @min 0
 @desc 索引
 @default 0 

*/

/*~struct~LSkillSlotItemVisual:zh-cn

 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此技能栏是否可见?


 * @param isCanBeEdited:bool
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 玩家是否可通过UI编辑器来编辑此技能栏? 


 * @param isHideWithMessage:bool
 * @text 显示文本时是否隐藏?
 * @type boolean
 * @default true
 * @desc 当显示对话文本时，此界面是否隐藏? 

 @param outlineGroup
 @text 描边

 @param outlineMargins:s
 @parent outlineGroup
 @text 描边偏移量
 @type struct<XY> 
 @desc 描边颜色的偏移量设置
 @default {} 


 @param outlinePulseSpeed:i
 @parent outlineGroup
 @text 脉冲速度
 @type number 
 @min 1
 @max 255
 @desc 描边的脉冲速度（游戏帧）
 @default 40 


 @param selectedOutlineColor:str
 @parent outlineGroup
 @text 已选中
 @type text 
 @desc 已选中的技能栏描边效果的颜色，16进制代码
 @default #fcba03 


 @param clickedOutlineColor:str
 @parent outlineGroup
 @text 已点击
 @type text 
 @desc 已激活/已点击的技能栏描边效果的颜色，16进制代码
 @default #0b03fc 


 @param readyOutlineColor:str
 @parent outlineGroup
 @text 已准备
 @type text 
 @desc 已准备就绪的技能栏描边效果的颜色，16进制代码
 @default #21b53c 


 @param badOutlineColor:str
 @parent outlineGroup
 @text 已禁用
 @type text 
 @desc 已禁用的技能栏描边效果的颜色，16进制代码
 @default #d61a1a 


 @param icon:s
 @text 图标设置
 @type struct<LSkillSLotItemVisualIcon> 
 @desc 技能栏上的技能和物品的图标设置，图标索引已被忽略
 @default {} 

 @param iconMargins:s
 @text 图标偏移量
 @parent icon:s
 @type struct<XY> 
 @desc 图标偏移量
 @default {} 

 @param symbolText:s
 @text 符号文本
 @type struct<CText> 
 @desc 符号 (键位) 文本设置
 @default {} 


 @param timeText:s
 @text 时间文本
 @type struct<CText> 
 @desc 计时文本设置
 @default {} 


 @param countText:s
 @text 计数文本
 @type struct<CText> 
 @desc 计数文本设置
 @default {} 

*/


/*~struct~LUIFaceElement:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见?


 @param faceName
 @text 脸图
 @type file
 @require 1
 @dir img/face/
 @desc 脸图文件名
 @default  


 @param faceIndex:i
 @parent faceName
 @text 索引
 @type number 
 @min 0
 @desc 脸图索引
 @default 0 


 @param mirror:b
 @text 镜像
 @type boolean 
 @on Yes
 @off No
 @desc 是否镜像显示脸图？
 @default false 


 @param size:i
 @text 大小
 @type number 
 @desc 脸图大小（RM默认是144）
 @default 74 


 @param margins:s
 @text 偏移量
 @type struct<XY> 
 @desc 脸图偏移量
 @default {}

*/
/*~struct~LUIImageElement:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见? 


 @param image
 @text 图片
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default 


 @param margins:s
 @text 偏移量
 @type struct<XY> 
 @desc 图片偏移量
 @default {}

*/

/*~struct~LEnemyInfoVisual:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见? 


 @param position:struct
 @text 位置
 @type struct<XY2>
 @default
 @desc 位于屏幕中的位置


 @param image
 @text 背景
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default Enemy_Background 


 @param isCanBeEdited:bool
 @text 是否可编辑?
 @type boolean
 @default true
 @desc 玩家是否可通过UI编辑器来编辑此元素? 


 @param isHideWithMessage:bool
 @text 是否在对话时隐藏?
 @type boolean
 @default true
 @desc 当对话界面出现时此元素是否被隐藏? 


 @param nameFormat
 @text 名称格式
 @type text 
 @desc %1将会被怪物名称替换掉
 @default %1


 @param levelFormat
 @text 等级格式
 @type text 
 @desc %1将会被怪物等级替换掉
 @default Lv. %1 


 @param hpTextFormat
 @text 血量格式
 @type text 
 @desc %1 - HP, %2 - 最大HP, %3 - 百分比%
 @default %1 / %2 


 @param nameText:s
 @parent nameFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物名称文本样式
 @default {} 


 @param hpText:s
 @parent hpTextFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物HP文本样式
 @default {} 


 @param levelText:s
 @parent levelFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物等级文本样式
 @default {} 


 @param gauge:s
 @text HP血条
 @type struct<CGauge> 
 @desc 怪物HP血条显示样式
 @default {} 

 @param gaugeMargins:s
 @parent gauge:s
 @text 偏移量
 @type struct<XY> 
 @desc HP血条偏移量
 @default {}

 @param face:s
 @text 怪物脸图
 @type struct<LUIFaceElement> 
 @desc 怪物脸图设置，文件名和索引未被使用
 @default {} 


 @param battleState:s
 @text 战斗状态图标
 @type struct<LUIImageElement> 
 @desc 怪物进入战斗状态时的图标
 @default {} 


 @param foregroundImage:s
 @text 前景图
 @type struct<LUIImageElement> 
 @desc 前景图图片
 @default {} 

*/

/*~struct~LSpawnPoint:zh-cn

 @param id:str
 @text ID
 @type text 
 @desc 用于<absSpawnPoint:ID>命令的唯一的出生点ID
 @default spawnPoint

 @param spawnPointType:str
 @text 出生类型
 @type select
 @option self
 @option region
 @option player
 @desc Self=出生在自身周围. Region=出生在特定区域. Player=出生在玩家周围.
 @default self 

 @param spawnRadius:str
 @parent spawnPointType:str
 @text 半径和区域
 @type text
 @desc 半径（自身，玩家）或区域（用于区域类型）的[扩展属性]
 @default 3

 @param spawnMax:str
 @text 最大值
 @type text 
 @desc 可出生的最大数值. 0=不限制. [扩展属性]
 @default 3


 @param spawnAliveMax:str
 @parent spawnMax:str
 @text 最大存活怪物数量
 @type text 
 @desc 可出现的最大的存活的怪物数量. 0=不限制. [扩展属性]
 @default 2 


 @param spawnRate:str
 @text 出生速度
 @type text 
 @desc 每隔多少秒出生一次，最少为1秒 [扩展属性]
 @default 4

 @param spawnEnemiesId:str
 @text 出生的事件ID
 @type text 
 @desc 在出生地图中的用于出生的事件ID合集 [扩展属性]
 @default 1, 2, 3


 @param conditionSwitch:i
 @text 开关
 @type switch 
 @desc 0=无开关限制. 如果开关为关闭则表示不出生
 @default 0

 @param visorRadius:i
 @text 出生视野
 @type number 
 @min 0
 @desc 0=一直出生. 其他数字表示玩家在此半径内才会开始出生
 @default 3


 @param endCommonEvent:i
 @text 达到最大数量时
 @type common_event 
 @desc 达到最大数量时执行的公共事件
 @default 0

*/


/*~struct~LCustomLevelUpSettings:zh-cn

 @param databaseAnimationId:i
 @text 动画 [数据库]
 @type animation 
 @min 0
 @desc 0=无动画.
 @default 0

 @param imageSeqAnimationName:str
 @text 动画 [文件]
 @type file
 @dir img/pictures/
 @desc 可选项, 文件命名规则: 文件名(帧数,延迟).png
 @default

 @param imageSeqAnimationMargins:s
 @parent imageSeqAnimationName:str
 @text 偏移量
 @type struct<XY> 
 @desc 
 @default {} 

 @param extraSE:str
 @text 音效
 @type file
 @dir audio/se/
 @require 1
 @desc 可选项, 留空表示不显示
 @default

 @param isShowPopUp:b
 @text 是否显示飘字?
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 

 @param popUpText:str
 @parent isShowPopUp:b
 @text 文本
 @type text
 @desc %1 将被新等级（数字）的值所覆盖
 @default Level %1! 

 @param popUpStyle:s
 @parent isShowPopUp:b
 @text 设置
 @type struct<LDamagePopUpVisualSettings> 
 @desc 飘字样式设置
 @default {} 

 @param commonEvent:i
 @text 公共事件
 @type common_event 
 @min 0
 @desc 升级时执行的公共事件
 @default 0 

 @param scriptAction:str
 @text 脚本命令
 @type text 
 @desc 升级时执行的脚本命令（相对于玩家角色）
 @default

*/

/*~struct~LBloodSplatterEffectSettings:zh-cn
 @param BS_Picture
 @text 血量过低闪烁效果图片
 @type file
 @dir img/pictures/
 @require 1
 @desc 可以选择不设置此选项
 
 @param BS_Color
 @text 血量过低时闪烁颜色值
 @type string
 @default #F98822
 @desc 输入十六进制数字，或者留空表示不使用此功能
 
 @param BS_Opacity:int
 @text 血量过低时屏幕闪烁透明度
 @type number
 @min 0
 @max 255
 @default 124
 @desc 输入0到255的数字
 
 @param BS_HpRate:int
 @text 角色血量过低比例
 @type number
 @min 1
 @max 99
 @default 15
 @desc 血量达到百分之多少时显示血量警告效果
 */

 /*~struct~FlyBonus:zh-cn
    @param image:str
    @text Image
    @type file
    @dir img/pictures/
    @require 1 
    @desc Bonus image, supports animated
    @default bonusGreen 

    @param actionSE:str
    @text Action SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when player got bonus
    @default  

    @param spawnSE:str
    @text Appear SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when bonus is appears
    @default  

    @param startOffsetRadiusInPx:i
    @text Offset
    @type number 
    @min 0
    @max 48
    @desc Appear position max offset in PX from start point
    @default 16 

    @param stayFrames:i
    @text Delay
    @type number 
    @min 0
    @desc Delay in frames! before bonus fly to the player
    @default 12 

    @param flySpeed:i
    @text Speed
    @type number 
    @min 1
    @max 100
    @desc Fly speed (in PX)
    @default 8

    @param actionSA:str
    @text SAction
    @type text 
    @desc Optional. SAction executed on player when received this bonuse.
    @default

    @param hpGainE
    @text HP Gain
    @desc Optional. How many HP this bonus gain to the player. EVal supported.
    @default 25 

    @param mpGainE
    @text MP Gain
    @desc Optional. How many MP this bonus gain to the player. EVal supported.
    @default 0

    @param expGainE
    @text EXP Gain
    @desc Optional. How many EXP this bonus gain to the player. EVal supported.
    @default 0 

    @param goldGainE
    @text Gold Gain
    @desc Optional. How many Gold this bonus gain to the player. EVal supported.
    @default 0
 */
 
 /*~struct~LDodgeActionSettings:zh-cn
@param dodgeKey
@text 热键
@default f

@param dodgeSwitch:i
@text 开启开关
@type switch
@desc 当此开关打开后玩家将永久可以使用闪躲动作

@param isInvincible:b
@text 是否无敌？
@type boolean
@desc 设置为真时，玩家在躲闪过程中将处于无敌状态

@param stepsCount:i
@text 前冲距离
@type number
@min 1
@max 2
@default 2
@desc 玩家躲闪时可前冲多少距离（1格或者2格）

@param delayBetweenStepMS:i
@text 每格间隔毫秒
@type number
@min 0
@default 100
@desc 躲闪时每格的间隔时间，单位毫秒

@param dodgeMoveSpeed:i
@text 速度
@type number
@min 4
@default 5
@desc 玩家前冲时的移动速度

@param dodgeRestTimerFrames:i
@text CD时间
@type number
@min 0
@default 30
@desc 躲闪动作的CD时间（游戏帧）

@param dodgeRestVariable:i
@parent dodgeRestTimerFrames:i
@text CD时间变量
@type variable
@default 0
@desc 如果设置为非0，则此数字对应的变量数值将作为躲闪CD时间（游戏帧）
 */

/*~struct~BattleAutoBGM:zh-cn

 @param name
 @text 背景音乐BGM
 @type file
 @require 1
 @dir audio/BGM/
 @desc 如果留空则表示不启用此功能，否则将启用地图描述区的BGM设置
 @default

@param delay:i
@text 延迟
@type number
@decimals 2
@min 0
@default 0.5
@desc BGM淡出淡入的时间（单位秒）
 */
/*~struct~CGaugeCustom:zh-cn
 * @param id
 * @text 独有ID
 * @default myGauge
 * @desc 从uAPI脚本调用引用此血槽的独有ID
 *
 * @param vertical:bool
 * @text 是否垂直显示
 * @type boolean
 * @default false
 * @desc 血槽是否是垂直显示的？
 *
 * @param fill
 * @text 填充图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 血槽的填充图片，必选项
 *
 * @param foreground
 * @text 血槽前景图
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 位于血槽上层显示的前景图，非必选项
 *
 * @param mask
 * @text 蒙板图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 整体血槽的蒙板遮罩，非必选项
 *
 * @param backColor:css
 * @type string
 * @text 背景色
 * @default #000000
 * @desc 文字颜色的十六进制代码，格式(#000000)
 *
 * @param backOpacity:int
 * @type 数字
 * @min 0
 * @max 255
 * @text 背景可见度
 * @default 255
 * @desc 0表示不可见，255表示正常显示
 *
 * @param gaugeCaption
 * @text 标题
 *
 * @param text:struct
 * @parent gaugeCaption
 * @type struct<CText>
 * @text 文本设置
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"200\",\"h:int\":\"30\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"2\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"24\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 *
 * @param textFormat
 * @parent gaugeCaption
 * @text 格式
 * @default $1 / $2
 * @desc $1表示当前值，$2表示最大值，$3表示百分比
 */
 
 /*~struct~AAColTerrain:zh-cn
 
 * @param terrainTag:int
 * @type number
 * @min 1
 * @max 7
 * @text 地形标记
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig>
 * @text 碰撞体
 * @default
 * @desc 所有地图格子的碰撞体地形标志ID
 */
 /*~struct~AAColRegion:zh-cn
 
 * @param regionId:int
 * @type number
 * @min 1
 * @max 255
 * @text 区域ID
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig>
 * @text Collider
 * @default
 * @desc 所有地图格子的碰撞体区域ID
 */

 /*~struct~AAColliderConfig:zh-cn
 * 
 * @param type
 * @type select
 * @option Box (rectangle)
 * @value b
 * @option Circle
 * @value c
 * @text 类型
 * @default b
 * @desc 碰撞体类型（B=方形，C=圆形）
 *
 * @param dx:int
 * @type number
 * @text X偏移
 * @default 0
 *
 * @param dy:int
 * @type number
 * @text Y偏移
 * @default 0
 *
 * @param onlyForBox
 * @text 仅方形有效
 *
 * @param width:int
 * @parent onlyForBox
 * @type number
 * @text 宽度
 * @min 1
 * @default 48
 *
 * @param height:int
 * @parent onlyForBox
 * @type number
 * @min 1
 * @text 高度
 * @default 48
 *
 * @param onlyForCircle
 * @text 仅圆形有效
 *
 * @param radius:int
 * @parent onlyForCircle
 * @type number
 * @min 1
 * @text 半径
 * @default 16
 */


var Imported = Imported || {};
Imported.Alpha_ABSZ = true;

// * ALPHA FAMILY PLUGINS GLOBAL DEFINITION
var AA = AA || {};

AA.Utils = {};

AA.warning = function(e, msg) {
    KDCore.warning(e, msg);
};

AA.w = (e, mgs) => AA.warning(e, mgs);

AA.link = function (library) {
    this[library.name] = library;
};

AA.Version = 94;

// * Данный символ переопределяется в 1_DevSymbol_TEST как dev
AA._define = 'build'; // * По умолчанию -> сборка

// * Критическая ошибка, стоп игры
AA.cre = function(e, msg) {
    AA.w(e, msg);
    window.alert(msg || "Critical error occur!");
    SceneManager.update = () => {};
};

// * Если карта (Scene_Map) и включён режим АБС
AA.isABSMap = function() {
    return AA.isABSActive() && AA.isMap();
};

// * АБС в активном режиме
AA.isABSActive = function() {
    return AA.System.isABSActive();
};

AA.isMap = function() {
    return KDCore.Utils.isSceneMap();
};

AA.isDEV = function() {
    return AA._define == 'dev';
};

AA.isPro = function() {
    return true;
};


/*
# ==========================================================================
# ==========================================================================
#
#   EMBEDDED PHEONIX KAGEDESU PLUGINS CORE LIBRARY
#   (This plugin may not use the entire code of this library)
#
# ==========================================================================
# ==========================================================================
 * 
 * 
 */



/*!
 * pixi-filters - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:51:27 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,n,t,r,o,i,l,a){"use strict";var s=function(e,n){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)};function u(e,n){function t(){this.constructor=e}s(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}var f=function(){return(f=Object.assign||function(e){for(var n,t=arguments,r=1,o=arguments.length;r<o;r++)for(var i in n=t[r])Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i]);return e}).apply(this,arguments)};Object.create;Object.create;var c="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",m=function(e){function n(n){var t=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n")||this;return t.gamma=1,t.saturation=1,t.contrast=1,t.brightness=1,t.red=1,t.green=1,t.blue=1,t.alpha=1,Object.assign(t,n),t}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},n}(n.Filter),p=function(e){function n(n){void 0===n&&(n=.5);var t=e.call(this,c,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n")||this;return t.threshold=n,t}return u(n,e),Object.defineProperty(n.prototype,"threshold",{get:function(){return this.uniforms.threshold},set:function(e){this.uniforms.threshold=e},enumerable:!1,configurable:!0}),n}(n.Filter),d=function(e){function n(n,r,o){void 0===n&&(n=4),void 0===r&&(r=3),void 0===o&&(o=!1);var i=e.call(this,c,o?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}")||this;return i._kernels=[],i._blur=4,i._quality=3,i.uniforms.uOffset=new Float32Array(2),i._pixelSize=new t.Point,i.pixelSize=1,i._clamp=o,Array.isArray(n)?i.kernels=n:(i._blur=n,i.quality=r),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i=this._pixelSize.x/n._frame.width,l=this._pixelSize.y/n._frame.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,n,t,r);else{for(var a=e.getFilterTexture(),s=n,u=a,f=void 0,c=this._quality-1,m=0;m<c;m++)o=this._kernels[m]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,u,1),f=s,s=u,u=f;o=this._kernels[c]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,t,r),e.returnFilterTexture(a)}},n.prototype._updatePadding=function(){this.padding=Math.ceil(this._kernels.reduce((function(e,n){return e+n+.5}),0))},n.prototype._generateKernels=function(){var e=this._blur,n=this._quality,t=[e];if(e>0)for(var r=e,o=e/n,i=1;i<n;i++)r-=o,t.push(r);this._kernels=t,this._updatePadding()},Object.defineProperty(n.prototype,"kernels",{get:function(){return this._kernels},set:function(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max.apply(Math,e)):(this._kernels=[0],this._quality=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"clamp",{get:function(){return this._clamp},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._pixelSize},set:function(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._quality},set:function(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blur},set:function(e){this._blur=e,this._generateKernels()},enumerable:!1,configurable:!0}),n}(n.Filter),h=function(e){function n(t){var o=e.call(this,c,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n")||this;o.bloomScale=1,o.brightness=1,o._resolution=r.settings.FILTER_RESOLUTION,"number"==typeof t&&(t={threshold:t});var i=Object.assign(n.defaults,t);o.bloomScale=i.bloomScale,o.brightness=i.brightness;var l=i.kernels,a=i.blur,s=i.quality,u=i.pixelSize,f=i.resolution;return o._extractFilter=new p(i.threshold),o._extractFilter.resolution=f,o._blurFilter=l?new d(l):new d(a,s),o.pixelSize=u,o.resolution=f,o}return u(n,e),n.prototype.apply=function(e,n,t,r,o){var i=e.getFilterTexture();this._extractFilter.apply(e,n,i,1,o);var l=e.getFilterTexture();this._blurFilter.apply(e,i,l,1),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=l,e.applyFilter(this,n,t,r),e.returnFilterTexture(l),e.returnFilterTexture(i)},Object.defineProperty(n.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"threshold",{get:function(){return this._extractFilter.threshold},set:function(e){this._extractFilter.threshold=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),n.defaults={threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},n}(n.Filter),g=function(e){function n(n){void 0===n&&(n=8);var t=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.pixelSize},set:function(e){this.uniforms.pixelSize=e},enumerable:!1,configurable:!0}),n}(n.Filter),v=function(e){function n(n){var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n")||this;return t._thickness=2,t._angle=0,t.uniforms.lightColor=new Float32Array(3),t.uniforms.shadowColor=new Float32Array(3),Object.assign(t,{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},n),t.padding=1,t}return u(n,e),n.prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},Object.defineProperty(n.prototype,"rotation",{get:function(){return this._angle/t.DEG_TO_RAD},set:function(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightColor",{get:function(){return o.rgb2hex(this.uniforms.lightColor)},set:function(e){o.hex2rgb(e,this.uniforms.lightColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightAlpha",{get:function(){return this.uniforms.lightAlpha},set:function(e){this.uniforms.lightAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowColor",{get:function(){return o.rgb2hex(this.uniforms.shadowColor)},set:function(e){o.hex2rgb(e,this.uniforms.shadowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowAlpha",{get:function(){return this.uniforms.shadowAlpha},set:function(e){this.uniforms.shadowAlpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),y=function(e){function n(n,o,s,u){void 0===n&&(n=2),void 0===o&&(o=4),void 0===s&&(s=r.settings.FILTER_RESOLUTION),void 0===u&&(u=5);var f,c,m=e.call(this)||this;return"number"==typeof n?(f=n,c=n):n instanceof t.Point?(f=n.x,c=n.y):Array.isArray(n)&&(f=n[0],c=n[1]),m.blurXFilter=new a.BlurFilterPass(!0,f,o,s,u),m.blurYFilter=new a.BlurFilterPass(!1,c,o,s,u),m.blurYFilter.blendMode=i.BLEND_MODES.SCREEN,m.defaultFilter=new l.AlphaFilter,m}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.defaultFilter.apply(e,n,t,r),this.blurXFilter.apply(e,n,o,1),this.blurYFilter.apply(e,o,t,0),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurX",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurY",{get:function(){return this.blurYFilter.blur},set:function(e){this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),n}(n.Filter),b=function(e){function n(t){var r=e.call(this,c,"uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n")||this;return r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),n.defaults={center:[.5,.5],radius:100,strength:1},n}(n.Filter),x=function(e){function t(n,t,r){void 0===t&&(t=!1),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}")||this;return o.mix=1,o._size=0,o._sliceSize=0,o._slicePixelSize=0,o._sliceInnerSize=0,o._nearest=!1,o._scaleMode=null,o._colorMap=null,o._scaleMode=null,o.nearest=t,o.mix=r,o.colorMap=n,o}return u(t,e),t.prototype.apply=function(e,n,t,r){this.uniforms._mix=this.mix,e.applyFilter(this,n,t,r)},Object.defineProperty(t.prototype,"colorSize",{get:function(){return this._size},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"colorMap",{get:function(){return this._colorMap},set:function(e){var t;e&&(e instanceof n.Texture||(e=n.Texture.from(e)),(null===(t=e)||void 0===t?void 0:t.baseTexture)&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=i.MIPMAP_MODES.OFF,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"nearest",{get:function(){return this._nearest},set:function(e){this._nearest=e,this._scaleMode=e?i.SCALE_MODES.NEAREST:i.SCALE_MODES.LINEAR;var n=this._colorMap;n&&n.baseTexture&&(n.baseTexture._glTextures={},n.baseTexture.scaleMode=this._scaleMode,n.baseTexture.mipmap=i.MIPMAP_MODES.OFF,n._updateID++,n.baseTexture.emit("update",n.baseTexture))},enumerable:!1,configurable:!0}),t.prototype.updateColorMap=function(){var e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)},t.prototype.destroy=function(n){void 0===n&&(n=!1),this._colorMap&&this._colorMap.destroy(n),e.prototype.destroy.call(this)},t}(n.Filter),_=function(e){function n(n,t){void 0===n&&(n=0),void 0===t&&(t=1);var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n")||this;return r._color=0,r._alpha=1,r.uniforms.color=new Float32Array(3),r.color=n,r.alpha=t,r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.color;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this._alpha},set:function(e){this.uniforms.alpha=e,this._alpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),C=function(e){function n(n,t,r){void 0===n&&(n=16711680),void 0===t&&(t=0),void 0===r&&(r=.4);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n")||this;return o._originalColor=16711680,o._newColor=0,o.uniforms.originalColor=new Float32Array(3),o.uniforms.newColor=new Float32Array(3),o.originalColor=n,o.newColor=t,o.epsilon=r,o}return u(n,e),Object.defineProperty(n.prototype,"originalColor",{get:function(){return this._originalColor},set:function(e){var n=this.uniforms.originalColor;"number"==typeof e?(o.hex2rgb(e,n),this._originalColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._originalColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"newColor",{get:function(){return this._newColor},set:function(e){var n=this.uniforms.newColor;"number"==typeof e?(o.hex2rgb(e,n),this._newColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._newColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),S=function(e){function n(n,t,r){void 0===t&&(t=200),void 0===r&&(r=200);var o=e.call(this,c,"precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n")||this;return o.uniforms.texelSize=new Float32Array(2),o.uniforms.matrix=new Float32Array(9),void 0!==n&&(o.matrix=n),o.width=t,o.height=r,o}return u(n,e),Object.defineProperty(n.prototype,"matrix",{get:function(){return this.uniforms.matrix},set:function(e){var n=this;e.forEach((function(e,t){n.uniforms.matrix[t]=e}))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"width",{get:function(){return 1/this.uniforms.texelSize[0]},set:function(e){this.uniforms.texelSize[0]=1/e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return 1/this.uniforms.texelSize[1]},set:function(e){this.uniforms.texelSize[1]=1/e},enumerable:!1,configurable:!0}),n}(n.Filter),F=function(e){function n(){return e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")||this}return u(n,e),n}(n.Filter),z=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n")||this;return r.time=0,r.seed=0,r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"curvature",{get:function(){return this.uniforms.curvature},set:function(e){this.uniforms.curvature=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineWidth",{get:function(){return this.uniforms.lineWidth},set:function(e){this.uniforms.lineWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineContrast",{get:function(){return this.uniforms.lineContrast},set:function(e){this.uniforms.lineContrast=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"verticalLine",{get:function(){return this.uniforms.verticalLine},set:function(e){this.uniforms.verticalLine=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},n}(n.Filter),O=function(e){function n(n,t){void 0===n&&(n=1),void 0===t&&(t=5);var r=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n")||this;return r.scale=n,r.angle=t,r}return u(n,e),Object.defineProperty(n.prototype,"scale",{get:function(){return this.uniforms.scale},set:function(e){this.uniforms.scale=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n}(n.Filter),P=function(e){function i(o){var l=e.call(this)||this;l.angle=45,l._distance=5,l._resolution=r.settings.FILTER_RESOLUTION;var a=o?f(f({},i.defaults),o):i.defaults,s=a.kernels,u=a.blur,m=a.quality,p=a.pixelSize,h=a.resolution;l._tintFilter=new n.Filter(c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),l._tintFilter.uniforms.color=new Float32Array(4),l._tintFilter.uniforms.shift=new t.Point,l._tintFilter.resolution=h,l._blurFilter=s?new d(s):new d(u,m),l.pixelSize=p,l.resolution=h;var g=a.shadowOnly,v=a.rotation,y=a.distance,b=a.alpha,x=a.color;return l.shadowOnly=g,l.rotation=v,l.distance=y,l.alpha=b,l.color=x,l._updatePadding(),l}return u(i,e),i.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this._tintFilter.apply(e,n,o,1),this._blurFilter.apply(e,o,t,r),!0!==this.shadowOnly&&e.applyFilter(this,n,t,0),e.returnFilterTexture(o)},i.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},i.prototype._updateShift=function(){this._tintFilter.uniforms.shift.set(this.distance*Math.cos(this.angle),this.distance*Math.sin(this.angle))},Object.defineProperty(i.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"distance",{get:function(){return this._distance},set:function(e){this._distance=e,this._updatePadding(),this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"rotation",{get:function(){return this.angle/t.DEG_TO_RAD},set:function(e){this.angle=e*t.DEG_TO_RAD,this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"alpha",{get:function(){return this._tintFilter.uniforms.alpha},set:function(e){this._tintFilter.uniforms.alpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"color",{get:function(){return o.rgb2hex(this._tintFilter.uniforms.color)},set:function(e){o.hex2rgb(e,this._tintFilter.uniforms.color)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e,this._updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),i.defaults={rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},i}(n.Filter),A=function(e){function n(n){void 0===n&&(n=5);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n")||this;return t.strength=n,t}return u(n,e),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),n}(n.Filter),T=function(e){function r(t){var o=e.call(this,c,"// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n")||this;return o.offset=100,o.fillMode=r.TRANSPARENT,o.average=!1,o.seed=0,o.minSize=8,o.sampleSize=512,o._slices=0,o._offsets=new Float32Array(1),o._sizes=new Float32Array(1),o._direction=-1,o.uniforms.dimensions=new Float32Array(2),o._canvas=document.createElement("canvas"),o._canvas.width=4,o._canvas.height=o.sampleSize,o.texture=n.Texture.from(o._canvas,{scaleMode:i.SCALE_MODES.NEAREST}),Object.assign(o,r.defaults,t),o}return u(r,e),r.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,n,t,r)},r.prototype._randomizeSizes=function(){var e=this._sizes,n=this._slices-1,t=this.sampleSize,r=Math.min(this.minSize/t,.9/this._slices);if(this.average){for(var o=this._slices,i=1,l=0;l<n;l++){var a=i/(o-l),s=Math.max(a*(1-.6*Math.random()),r);e[l]=s,i-=s}e[n]=i}else{i=1;var u=Math.sqrt(1/this._slices);for(l=0;l<n;l++){s=Math.max(u*i*Math.random(),r);e[l]=s,i-=s}e[n]=i}this.shuffle()},r.prototype.shuffle=function(){for(var e=this._sizes,n=this._slices-1;n>0;n--){var t=Math.random()*n>>0,r=e[n];e[n]=e[t],e[t]=r}},r.prototype._randomizeOffsets=function(){for(var e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)},r.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},r.prototype.redraw=function(){var e,n=this.sampleSize,t=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,n);for(var o=0,i=0;i<this._slices;i++){e=Math.floor(256*this._offsets[i]);var l=this._sizes[i]*n,a=e>0?e:0,s=e<0?-e:0;r.fillStyle="rgba("+a+", "+s+", 0, 1)",r.fillRect(0,o>>0,n,l+1>>0),o+=l}t.baseTexture.update(),this.uniforms.displacementMap=t},Object.defineProperty(r.prototype,"sizes",{get:function(){return this._sizes},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._sizes[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"offsets",{get:function(){return this._offsets},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._offsets[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"slices",{get:function(){return this._slices},set:function(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"direction",{get:function(){return this._direction},set:function(e){if(this._direction!==e){this._direction=e;var n=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(n),this.uniforms.cosDir=Math.cos(n)}},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),r.prototype.destroy=function(){var e;null===(e=this.texture)||void 0===e||e.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null},r.defaults={slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},r.TRANSPARENT=0,r.ORIGINAL=1,r.LOOP=2,r.CLAMP=3,r.MIRROR=4,r}(n.Filter),w=function(e){function n(t){var r=this,o=Object.assign({},n.defaults,t),i=o.outerStrength,l=o.innerStrength,a=o.color,s=o.knockout,u=o.quality,f=Math.round(o.distance);return(r=e.call(this,c,"varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi,""+(1/u/f).toFixed(7)).replace(/__DIST__/gi,f.toFixed(0)+".0"))||this).uniforms.glowColor=new Float32Array([0,0,0,1]),Object.assign(r,{color:a,outerStrength:i,innerStrength:l,padding:f,knockout:s}),r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.glowColor)},set:function(e){o.hex2rgb(e,this.uniforms.glowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"outerStrength",{get:function(){return this.uniforms.outerStrength},set:function(e){this.uniforms.outerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerStrength",{get:function(){return this.uniforms.innerStrength},set:function(e){this.uniforms.innerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"knockout",{get:function(){return this.uniforms.knockout},set:function(e){this.uniforms.knockout=e},enumerable:!1,configurable:!0}),n.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1},n}(n.Filter),D=function(e){function n(r){var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n".replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n"))||this;o.parallel=!0,o.time=0,o._angle=0,o.uniforms.dimensions=new Float32Array(2);var i=Object.assign(n.defaults,r);return o._angleLight=new t.Point,o.angle=i.angle,o.gain=i.gain,o.lacunarity=i.lacunarity,o.alpha=i.alpha,o.parallel=i.parallel,o.center=i.center,o.time=i.time,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.time=this.time,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e;var n=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(n),this._angleLight.y=Math.sin(n)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gain",{get:function(){return this.uniforms.gain},set:function(e){this.uniforms.gain=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lacunarity",{get:function(){return this.uniforms.lacunarity},set:function(e){this.uniforms.lacunarity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha=e},enumerable:!1,configurable:!0}),n.defaults={angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0],alpha:1},n}(n.Filter),j=function(e){function n(n,r,o){void 0===n&&(n=[0,0]),void 0===r&&(r=5),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i.kernelSize=5,i.uniforms.uVelocity=new Float32Array(2),i._velocity=new t.ObservablePoint(i.velocityChanged,i),i.setVelocity(n),i.kernelSize=r,i.offset=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=this.velocity,i=o.x,l=o.y;this.uniforms.uKernelSize=0!==i||0!==l?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"velocity",{get:function(){return this._velocity},set:function(e){this.setVelocity(e)},enumerable:!1,configurable:!0}),n.prototype.setVelocity=function(e){if(Array.isArray(e)){var n=e[0],t=e[1];this._velocity.set(n,t)}else this._velocity.copyFrom(e)},n.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y,this.padding=1+(Math.max(Math.abs(this._velocity.x),Math.abs(this._velocity.y))>>0)},Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.uOffset},set:function(e){this.uniforms.uOffset=e},enumerable:!1,configurable:!0}),n}(n.Filter),M=function(e){function n(n,t,r){void 0===t&&(t=.05),void 0===r&&(r=n.length);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(/%maxColors%/g,r.toFixed(0)))||this;return o._replacements=[],o._maxColors=0,o.epsilon=t,o._maxColors=r,o.uniforms.originalColors=new Float32Array(3*r),o.uniforms.targetColors=new Float32Array(3*r),o.replacements=n,o}return u(n,e),Object.defineProperty(n.prototype,"replacements",{get:function(){return this._replacements},set:function(e){var n=this.uniforms.originalColors,t=this.uniforms.targetColors,r=e.length;if(r>this._maxColors)throw new Error("Length of replacements ("+r+") exceeds the maximum colors length ("+this._maxColors+")");n[3*r]=-1;for(var i=0;i<r;i++){var l=e[i],a=l[0];"number"==typeof a?a=o.hex2rgb(a):l[0]=o.rgb2hex(a),n[3*i]=a[0],n[3*i+1]=a[1],n[3*i+2]=a[2];var s=l[1];"number"==typeof s?s=o.hex2rgb(s):l[1]=o.rgb2hex(s),t[3*i]=s[0],t[3*i+1]=s[1],t[3*i+2]=s[2]}this._replacements=e},enumerable:!1,configurable:!0}),n.prototype.refresh=function(){this.replacements=this._replacements},Object.defineProperty(n.prototype,"maxColors",{get:function(){return this._maxColors},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),R=function(e){function n(t,r){void 0===r&&(r=0);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n")||this;return o.seed=0,o.uniforms.dimensions=new Float32Array(2),"number"==typeof t?(o.seed=t,t=void 0):o.seed=r,Object.assign(o,n.defaults,t),o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.seed=this.seed,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"sepia",{get:function(){return this.uniforms.sepia},set:function(e){this.uniforms.sepia=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratch",{get:function(){return this.uniforms.scratch},set:function(e){this.uniforms.scratch=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchDensity",{get:function(){return this.uniforms.scratchDensity},set:function(e){this.uniforms.scratchDensity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchWidth",{get:function(){return this.uniforms.scratchWidth},set:function(e){this.uniforms.scratchWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},n}(n.Filter),E=function(e){function n(t,r,o){void 0===t&&(t=1),void 0===r&&(r=0),void 0===o&&(o=.1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n".replace(/\$\{angleStep\}/,n.getAngleStep(o)))||this;return i._thickness=1,i.uniforms.thickness=new Float32Array([0,0]),i.uniforms.outlineColor=new Float32Array([0,0,0,1]),Object.assign(i,{thickness:t,color:r,quality:o}),i}return u(n,e),n.getAngleStep=function(e){var t=Math.max(e*n.MAX_SAMPLES,n.MIN_SAMPLES);return(2*Math.PI/t).toFixed(7)},n.prototype.apply=function(e,n,t,r){this.uniforms.thickness[0]=this._thickness/n._frame.width,this.uniforms.thickness[1]=this._thickness/n._frame.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.outlineColor)},set:function(e){o.hex2rgb(e,this.uniforms.outlineColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this.padding=e},enumerable:!1,configurable:!0}),n.MIN_SAMPLES=1,n.MAX_SAMPLES=100,n}(n.Filter),I=function(e){function n(n){void 0===n&&(n=10);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.size},set:function(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e},enumerable:!1,configurable:!0}),n}(n.Filter),k=function(e){function n(n,t,r,o){void 0===n&&(n=0),void 0===t&&(t=[0,0]),void 0===r&&(r=5),void 0===o&&(o=-1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i._angle=0,i.angle=n,i.center=t,i.kernelSize=r,i.radius=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n}(n.Filter),L=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n")||this;return r.time=0,r.uniforms.amplitude=new Float32Array(2),r.uniforms.waveLength=new Float32Array(2),r.uniforms.alpha=new Float32Array(2),r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"mirror",{get:function(){return this.uniforms.mirror},set:function(e){this.uniforms.mirror=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"boundary",{get:function(){return this.uniforms.boundary},set:function(e){this.uniforms.boundary=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"waveLength",{get:function(){return this.uniforms.waveLength},set:function(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]},enumerable:!1,configurable:!0}),n.defaults={mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},n}(n.Filter),N=function(e){function n(n,t,r){void 0===n&&(n=[-10,0]),void 0===t&&(t=[0,10]),void 0===r&&(r=[0,0]);var o=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n")||this;return o.red=n,o.green=t,o.blue=r,o}return u(n,e),Object.defineProperty(n.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),n}(n.Filter),X=function(e){function n(t,r,o){void 0===t&&(t=[0,0]),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n")||this;return i.center=t,Object.assign(i,n.defaults,r),i.time=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"wavelength",{get:function(){return this.uniforms.wavelength},set:function(e){this.uniforms.wavelength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"brightness",{get:function(){return this.uniforms.brightness},set:function(e){this.uniforms.brightness=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"speed",{get:function(){return this.uniforms.speed},set:function(e){this.uniforms.speed=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),n.defaults={amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},n}(n.Filter),B=function(e){function n(n,t,r){void 0===t&&(t=0),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n")||this;return o._color=0,o.uniforms.dimensions=new Float32Array(2),o.uniforms.ambientColor=new Float32Array([0,0,0,r]),o.texture=n,o.color=t,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"texture",{get:function(){return this.uniforms.uLightmap},set:function(e){this.uniforms.uLightmap=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.ambientColor;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.ambientColor[3]},set:function(e){this.uniforms.ambientColor[3]=e},enumerable:!1,configurable:!0}),n}(n.Filter),G=function(e){function n(n,r,o,i){void 0===n&&(n=100),void 0===r&&(r=600);var l=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n")||this;return l.uniforms.blur=n,l.uniforms.gradientBlur=r,l.uniforms.start=o||new t.Point(0,window.innerHeight/2),l.uniforms.end=i||new t.Point(600,window.innerHeight/2),l.uniforms.delta=new t.Point(30,30),l.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),l.updateDelta(),l}return u(n,e),n.prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},Object.defineProperty(n.prototype,"blur",{get:function(){return this.uniforms.blur},set:function(e){this.uniforms.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.uniforms.gradientBlur},set:function(e){this.uniforms.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.uniforms.start},set:function(e){this.uniforms.start=e,this.updateDelta()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.uniforms.end},set:function(e){this.uniforms.end=e,this.updateDelta()},enumerable:!1,configurable:!0}),n}(n.Filter),K=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=e/t,this.uniforms.delta.y=n/t},n}(G),q=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=-n/t,this.uniforms.delta.y=e/t},n}(G),W=function(e){function n(n,t,r,o){void 0===n&&(n=100),void 0===t&&(t=600);var i=e.call(this)||this;return i.tiltShiftXFilter=new K(n,t,r,o),i.tiltShiftYFilter=new q(n,t,r,o),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.tiltShiftXFilter.apply(e,n,o,1),this.tiltShiftYFilter.apply(e,o,t,r),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.tiltShiftXFilter.blur},set:function(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.tiltShiftXFilter.gradientBlur},set:function(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.tiltShiftXFilter.start},set:function(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.tiltShiftXFilter.end},set:function(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e},enumerable:!1,configurable:!0}),n}(n.Filter),Y=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n")||this;return Object.assign(r,n.defaults,t),r}return u(n,e),Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.offset},set:function(e){this.uniforms.offset=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n.defaults={radius:200,angle:4,padding:20,offset:new t.Point},n}(n.Filter),Z=function(e){function n(t){var r,o=Object.assign(n.defaults,t),i=o.maxKernelSize,l=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(t[r[o]]=e[r[o]])}return t}(o,["maxKernelSize"]);return r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace("${maxKernelSize}",i.toFixed(1)))||this,Object.assign(r,l),r}return u(n,e),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.uStrength},set:function(e){this.uniforms.uStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerRadius",{get:function(){return this.uniforms.uInnerRadius},set:function(e){this.uniforms.uInnerRadius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n.defaults={strength:.1,center:[0,0],innerRadius:0,radius:-1,maxKernelSize:32},n}(n.Filter);return e.AdjustmentFilter=m,e.AdvancedBloomFilter=h,e.AsciiFilter=g,e.BevelFilter=v,e.BloomFilter=y,e.BulgePinchFilter=b,e.CRTFilter=z,e.ColorMapFilter=x,e.ColorOverlayFilter=_,e.ColorReplaceFilter=C,e.ConvolutionFilter=S,e.CrossHatchFilter=F,e.DotFilter=O,e.DropShadowFilter=P,e.EmbossFilter=A,e.GlitchFilter=T,e.GlowFilter=w,e.GodrayFilter=D,e.KawaseBlurFilter=d,e.MotionBlurFilter=j,e.MultiColorReplaceFilter=M,e.OldFilmFilter=R,e.OutlineFilter=E,e.PixelateFilter=I,e.RGBSplitFilter=N,e.RadialBlurFilter=k,e.ReflectionFilter=L,e.ShockwaveFilter=X,e.SimpleLightmapFilter=B,e.TiltShiftAxisFilter=G,e.TiltShiftFilter=W,e.TiltShiftXFilter=K,e.TiltShiftYFilter=q,e.TwistFilter=Y,e.ZoomBlurFilter=Z,Object.defineProperty(e,"__esModule",{value:!0}),e}({},PIXI,PIXI,PIXI,PIXI.utils,PIXI,PIXI.filters,PIXI.filters);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=pixi-filters.js.map


// Generated by CoffeeScript 2.6.1
// ==========================================================================
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ KDCore.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
// * LIBRARY WITH MZ AND MZ SUPPORT
//! {OUTER FILE}

//?rev 18.06.24
var KDCore;

window.Imported = window.Imported || {};

Imported.KDCore = true;

KDCore = KDCore || {};

// * Двузначные числа нельзя в версии, сравнение идёт по первой цифре поулчается (3.43 - нельзя, можно 3.4.3)
//%[МЕНЯТЬ ПРИ ИЗМЕНЕНИИ]
KDCore._fileVersion = '3.5.4';

KDCore.nuiVersion = '1.1.0';

// * Методы и библиотеки данной версии
KDCore._loader = 'loader_' + KDCore._fileVersion;

KDCore[KDCore._loader] = [];

// * Добавить библиотеку на загрузку
KDCore.registerLibraryToLoad = function(lib) {
  return KDCore[KDCore._loader].push(lib);
};

if ((KDCore.Version != null) && KDCore.Version >= KDCore._fileVersion) {
  // * ПРОПУСКАЕМ ЗАГРУЗКУ, так как уже загруженна более новая
  console.log('XDev KDCore ' + KDCore._fileVersion + ' skipped by new or exists version');
  KDCore._requireLoadLibrary = false;
} else {
  KDCore.Version = KDCore._fileVersion;
  KDCore.LIBS = KDCore.LIBS || {};
  KDCore.register = function(library) {
    return this.LIBS[library.name] = library;
  };
  window.KDCore = KDCore;
  // * ТРЕБУЕТСЯ ЗАГРУЗКА БИБЛИОТЕК
  KDCore._requireLoadLibrary = true;
}


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Array.prototype.delete = function() {
    var L, a, ax, what;
    what = void 0;
    a = arguments;
    L = a.length;
    ax = void 0;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };
  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };
  Array.prototype.sample = function() {
    if (this.length === 0) {
      return [];
    }
    return this[KDCore.SDK.rand(0, this.length - 1)];
  };
  Array.prototype.first = function() {
    return this[0];
  };
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
  Array.prototype.shuffle = function() {
    var k, n, v;
    n = this.length;
    while (n > 1) {
      n--;
      k = KDCore.SDK.rand(0, n + 1);
      v = this[k];
      this[k] = this[n];
      this[n] = v;
    }
  };
  Array.prototype.count = function() {
    return this.length;
  };
  Array.prototype.isEmpty = function() {
    return this.length === 0;
  };
  // * Ищет элемент, у которого поле ID == id
  Array.prototype.getById = function(id) {
    return this.getByField('id', id);
  };
  // * Ищет элемент, у которого поле FIELD (имя поля) == value
  Array.prototype.getByField = function(field, value) {
    var e;
    try {
      return this.find(function(item) {
        return item[field] === value;
      });
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  Object.defineProperty(Array.prototype, "delete", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "max", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "min", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "sample", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "first", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "last", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "shuffle", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "count", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "isEmpty", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "getById", {
    enumerable: false
  });
  return Object.defineProperty(Array.prototype, "getByField", {
    enumerable: false
  });
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Number.prototype.do = function(method) {
    return KDCore.SDK.times(this, method);
  };
  Number.prototype.clamp = function(min, max) {
    return Math.min(Math.max(this, min), max);
  };
  return Number.prototype.any = function(number) {
    return (number != null) && typeof number === 'number' && number > 0;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  String.prototype.toCss = function() {
    return KDCore.Color.FromHex(this).CSS;
  };
  String.prototype.toCSS = function() {
    return this.toCss();
  };
  String.prototype.isEmpty = function() {
    return this.length === 0 || !this.trim();
  };
  String.isNullOrEmpty = function(str) {
    if (str != null) {
      return str.toString().isEmpty();
    } else {
      return true;
    }
  };
  String.any = function(str) {
    return !String.isNullOrEmpty(str);
  };
  return String.prototype.replaceAll = function(search, replacement) {
    var target;
    target = this;
    return target.split(search).join(replacement);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.isMV = function() {
    return Utils.RPGMAKER_NAME.contains("MV");
  };
  KDCore.isMZ = function() {
    return !KDCore.isMV();
  };
  KDCore.warning = function(msg, error) {
    if (msg != null) {
      console.warn(msg);
    }
    if (error != null) {
      console.warn(error);
    }
  };
  KDCore.makeid = function(length) {
    var characters, charactersLength, i, result;
    result = '';
    characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    charactersLength = characters.length;
    i = 0;
    while (i < length) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
      i++;
    }
    return result;
  };
  return KDCore.makeId = function() {
    return KDCore.makeid(...arguments);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var SDK;
  //?[DEPRECATED]
  // * SDK
  //------------------------------------------------------------------------------
  SDK = function() {
    throw new Error('This is a static class');
  };
  SDK.rand = function(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
  };
  SDK.setConstantToObject = function(object, constantName, constantValue) {
    object[constantName] = constantValue;
    if (typeof object[constantName] === 'object') {
      Object.freeze(object[constantName]);
    }
    Object.defineProperty(object, constantName, {
      writable: false
    });
  };
  SDK.convertBitmapToBase64Data = function(bitmap) {
    return bitmap._canvas.toDataURL('image/png');
  };
  SDK.times = function(times, method) {
    var i, results;
    i = 0;
    results = [];
    while (i < times) {
      method(i);
      results.push(i++);
    }
    return results;
  };
  SDK.toGlobalCoord = function(layer, coordSymbol = 'x') {
    var node, t;
    t = layer[coordSymbol];
    node = layer;
    while (node) {
      t -= node[coordSymbol];
      node = node.parent;
    }
    return (t * -1) + layer[coordSymbol];
  };
  SDK.canvasToLocalX = function(layer, x) {
    while (layer) {
      x -= layer.x;
      layer = layer.parent;
    }
    return x;
  };
  SDK.canvasToLocalY = function(layer, y) {
    while (layer) {
      y -= layer.y;
      layer = layer.parent;
    }
    return y;
  };
  SDK.isInt = function(n) {
    return Number(n) === n && n % 1 === 0;
  };
  SDK.isFloat = function(n) {
    return Number(n) === n && n % 1 !== 0;
  };
  SDK.checkSwitch = function(switchValue) {
    if (switchValue === 'A' || switchValue === 'B' || switchValue === 'C' || switchValue === 'D') {
      return true;
    }
    return false;
  };
  SDK.toNumber = function(string, none = 0) {
    var number;
    if (string == null) {
      return none;
    }
    number = Number(string);
    if (isNaN(number)) {
      return none;
    }
    return number;
  };
  SDK.isString = function(value) {
    return typeof value === "string";
  };
  SDK.isArray = function(value) {
    return Array.isArray(value);
  };
  //@[EXTEND]
  return KDCore.SDK = SDK;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var __alias_Bitmap_blt_kdCore, __alias_Bitmap_fillAll_kdCore;
  //@[ALIAS]
  __alias_Bitmap_fillAll_kdCore = Bitmap.prototype.fillAll;
  Bitmap.prototype.fillAll = function(color) {
    if (color instanceof KDCore.Color) {
      return this.fillRect(0, 0, this.width, this.height, color.CSS);
    } else {
      return __alias_Bitmap_fillAll_kdCore.call(this, color);
    }
  };
  //@[ALIAS]
  __alias_Bitmap_blt_kdCore = Bitmap.prototype.blt;
  Bitmap.prototype.blt = function(source, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (this._needModBltDWH > 0) {
      dh = dw = this._needModBltDWH;
      __alias_Bitmap_blt_kdCore.call(this, source, sx, sy, sw, sh, dx, dy, dw, dh);
      this._needModBltDWH = null;
    } else {
      __alias_Bitmap_blt_kdCore.call(this, ...arguments);
    }
  };
  Bitmap.prototype.drawIcon = function(x, y, icon, size = 32, noSmoth = false) {
    var bitmap;
    bitmap = null;
    if (icon instanceof Bitmap) {
      bitmap = icon;
    } else {
      bitmap = KDCore.BitmapSrc.LoadFromIconIndex(icon).bitmap;
    }
    this._context.imageSmoothingEnabled = !noSmoth;
    this.drawOnMe(bitmap, x, y, size, size);
    this._context.imageSmoothingEnabled = true;
  };
  Bitmap.prototype.drawOnMe = function(bitmap, x = 0, y = 0, sw = 0, sh = 0) {
    if (sw <= 0) {
      sw = bitmap.width;
    }
    if (sh <= 0) {
      sh = bitmap.height;
    }
    this.blt(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, sw, sh);
  };
  Bitmap.prototype.drawInMe = function(bitmap) {
    return Bitmap.prototype.drawOnMe(bitmap, 0, 0, this.width, this.height);
  };
  return Bitmap.prototype.drawTextFull = function(text, position = 'center') {
    return this.drawText(text, 0, 0, this.width, this.height, position);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.EasingFuncs = KDCore.EasingFuncs || {};
  return (function() {
    var _;
    _ = KDCore.EasingFuncs;
    _.linear = function(t, b, c, d) {
      return c * t / d + b;
    };
    _.easeInQuad = function(t, b, c, d) {
      return c * (t /= d) * t + b;
    };
    _.easeOutQuad = function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    };
    _.easeInOutQuad = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      } else {
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      }
    };
    _.easeInCubic = function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    };
    _.easeOutCubic = function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    };
    return _.easeInOutCubic = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      } else {
        return c / 2 * ((t -= 2) * t * t + 2) + b;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  // * Нахожусь ли Я в точке по диагонале (рядом), относительно char
  _.kdInDiagonalPointRelativeTo = function(char) {
    var e, x, y;
    try {
      if (char == null) {
        return false;
      }
      ({x, y} = char);
      if (x === this.x - 1 && ((y === this.y - 1) || (y === this.y + 1))) {
        return true; // * left up or down
      }
      if (x === this.x + 1 && (y === this.y - 1 || y === this.y + 1)) {
        return true; // * right up or down
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * В MZ нету данной функции, а она часто используется в моих плагинах
  if (!KDCore.isMZ()) {
    return;
  }
  //?[NEW] (from MV)
  return ImageManager.loadEmptyBitmap = function() {
    if (this._emptyBitmap != null) {
      return this._emptyBitmap;
    } else {
      return new Bitmap();
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var _input_onKeyDown, _input_onKeyUp, i, j, k, l;
  Input.KeyMapperPKD = {};
//Numbers
  for (i = j = 48; j <= 57; i = ++j) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i);
  }
//Letters Upper
  for (i = k = 65; k <= 90; i = ++k) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
//Letters Lower (for key code events)
  for (i = l = 97; l <= 122; i = ++l) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
  
  //@[ALIAS]
  _input_onKeyDown = Input._onKeyDown;
  Input._onKeyDown = function(event) {
    _input_onKeyDown.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode);
  };
  //@[ALIAS]
  _input_onKeyUp = Input._onKeyUp;
  Input._onKeyUp = function(event) {
    _input_onKeyUp.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode, false);
  };
  //?NEW
  Input._setStateWithMapperPKD = function(keyCode, state = true) {
    var symbol;
    symbol = Input.KeyMapperPKD[keyCode];
    if (symbol != null) {
      return this._currentState[symbol] = state;
    }
  };
  //?NEW
  Input.isCancel = function() {
    return Input.isTriggered('cancel') || TouchInput.isCancelled();
  };
  //?NEW
  return TouchInput.toPoint = function() {
    return new KDCore.Point(TouchInput.x, TouchInput.y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  PluginManager.getPluginParametersByRoot = function(rootName) {
    var pluginParameters, property;
    for (property in this._parameters) {
      if (this._parameters.hasOwnProperty(property)) {
        pluginParameters = this._parameters[property];
        if (PluginManager.isPluginParametersContentKey(pluginParameters, rootName)) {
          return pluginParameters;
        }
      }
    }
    return PluginManager.parameters(rootName);
  };
  return PluginManager.isPluginParametersContentKey = function(pluginParameters, key) {
    return pluginParameters[key] != null;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ___Sprite_alias_Move_KDCORE_2;
  Sprite.prototype.moveToCenter = function(dx = 0, dy = 0) {
    return this.move(-this.bitmap.width / 2 + dx, -this.bitmap.height / 2 + dy);
  };
  Sprite.prototype.setStaticAnchor = function(floatX = 1, floatY = 1) {
    this.x -= Math.round(this.width * floatX);
    this.y -= Math.round(this.height * floatY);
  };
  Sprite.prototype.moveToParentCenter = function() {
    if (!this.parent) {
      return;
    }
    return this.move(this.parent.width / 2, this.parent.height / 2);
  };
  ___Sprite_alias_Move_KDCORE_2 = Sprite.prototype.move;
  Sprite.prototype.move = function(x, y) {
    if (x instanceof Array) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x[0], x[1]);
    } else if (x instanceof KDCore.Point || ((x != null ? x.x : void 0) != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x.x, x.y);
    } else if ((x != null) && (x._x != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x._x, x._y);
    } else {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x, y);
    }
  };
  Sprite.prototype.isContainsPoint = function(point) {
    var rect, rx, ry;
    if (this.width === 0 || this.height === 0) {
      return false;
    }
    rx = KDCore.SDK.toGlobalCoord(this, 'x');
    ry = KDCore.SDK.toGlobalCoord(this, 'y');
    rect = this._getProperFullRect(rx, ry);
    return rect.contains(point.x, point.y);
  };
  // * Возвращает Rect с учётом Scale и Anchor спрайта
  Sprite.prototype._getProperFullRect = function(rx, ry) {
    var height, width, x, y;
    width = this.width * Math.abs(this.scale.x);
    height = this.height * Math.abs(this.scale.y);
    x = rx - this.anchor.x * width;
    y = ry - this.anchor.y * height;
    if (this.anchor.x === 0 && this.scale.x < 0) {
      x += this.width * this.scale.x;
    }
    if (this.anchor.y === 0 && this.scale.y < 0) {
      y += this.height * this.scale.y;
    }
    return new PIXI.Rectangle(x, y, width, height);
  };
  Sprite.prototype.fillAll = function(color) {
    if (color != null) {
      return this.bitmap.fillAll(color);
    } else {
      return this.fillAll(KDCore.Color.WHITE);
    }
  };
  return Sprite.prototype.removeFromParent = function() {
    if (this.parent != null) {
      return this.parent.removeChild(this);
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return TouchInput.toMapPoint = function() {
    return this.toPoint().convertToMap();
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.Utils = KDCore.Utils || {};
  return (function() {
    var _;
    _ = KDCore.Utils;
    _.getJDataById = function(id, source) {
      var d, j, len;
      for (j = 0, len = source.length; j < len; j++) {
        d = source[j];
        if (d.id === id) {
          return d;
        }
      }
      return null;
    };
    _.hasMeta = function(symbol, obj) {
      return (obj != null) && (obj.meta != null) && (obj.meta[symbol] != null);
    };
    _.getValueFromMeta = function(symbol, obj) {
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      return obj.meta[symbol];
    };
    _.getNumberFromMeta = function(symbol, obj) {
      var value;
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      if (obj.meta[symbol] === true) {
        return 0;
      } else {
        value = KDCore.SDK.toNumber(obj.meta[symbol], 0);
      }
      return value;
    };
    _.isSceneMap = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Map;
      } catch (error) {
        return false;
      }
    };
    _.isMapScene = function() {
      return this.isSceneMap();
    };
    _.isSceneBattle = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Battle;
      } catch (error) {
        return false;
      }
    };
    _.isBattleScene = function() {
      return this.isSceneBattle();
    };
    _.getEventCommentValue = function(commentCode, list) {
      var comment, e, i, item;
      try {
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                return comment;
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return null;
    };
    _.getEventCommentValueArray = function(commentCode, list) {
      var comment, comments, e, i, item;
      try {
        comments = [];
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                comments.push(comment);
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return comments;
    };
    _.getPositionPointFromJSON = function(jsonSettings) {
      return _.convertPositionPointFromJSON(jsonSettings.position);
    };
    _.convertPositionPointFromJSON = function(position) {
      var e, x, y;
      try {
        x = position[0];
        y = position[1];
        if (!KDCore.SDK.isInt(x)) {
          x = eval(x);
        }
        if (!KDCore.SDK.isInt(y)) {
          y = eval(y);
        }
        return new KDCore.Point(x, y);
      } catch (error) {
        e = error;
        console.warn('Utils.getPositionPointFromJSON', e);
        return KDCore.Point.Empty;
      }
    };
    _.jsonPos = function(jsonPosition) {
      return _.convertPositionPointFromJSON(jsonPosition);
    };
    _.jsonPosXY = function(jsonPosition) {
      var e, x, y;
      try {
        ({x, y} = jsonPosition);
        return new KDCore.Point(eval(x), eval(y));
      } catch (error) {
        e = error;
        console.warn('Utils.jsonPosXY', e);
        return KDCore.Point.Empty;
      }
    };
    _.getVar = function(id) {
      return $gameVariables.value(id);
    };
    _.setVar = function(id, value) {
      return $gameVariables.setValue(id, value);
    };
    _.addToVar = function(id, value) {
      var prevVal;
      prevVal = _.getVar(id);
      return _.setVar(id, prevVal + value);
    };
    _.playSE = function(seFileName, pitch = 100, volume = 100) {
      var sound;
      if (seFileName == null) {
        return;
      }
      if (seFileName === "") {
        return;
      }
      sound = {
        name: seFileName,
        pan: 0,
        pitch: pitch,
        volume: volume
      };
      AudioManager.playStaticSe(sound);
    };
    _.getItemTypeId = function(item) {
      if (DataManager.isWeapon(item)) {
        return 1;
      } else if (DataManager.isArmor(item)) {
        return 2;
      }
      return 0;
    };
    _.getItemByType = function(itemId, typeId) {
      var data, e;
      try {
        if ((typeId != null) && !isFinite(typeId) && KDCore.SDK.isString(typeId) && String.any(typeId)) {
          if (typeId[0] === "w") {
            typeId = 1;
          } else if (typeId[0] === "a") {
            typeId = 2;
          } else {
            typeId = 0;
          }
        }
        data = [$dataItems, $dataWeapons, $dataArmors];
        return data[typeId][itemId];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    _.loadFont = function(name) {
      if (typeof FontManager === "undefined" || FontManager === null) {
        return;
      }
      if (String.isNullOrEmpty(name)) {
        return;
      }
      if (FontManager._states[name] != null) {
        return;
      }
      FontManager.load(name, name + ".ttf");
    };
    _.convertTimeShort = function(seconds) {
      var e;
      try {
        if (seconds > 59) {
          return Math.floor(seconds / 60) + 'm';
        } else {
          return seconds;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        return seconds;
      }
    };
    _.isPointInScreen = function(point, margin = 10) {
      var maxH, maxW, screenMargin, x, y;
      ({x, y} = point);
      maxW = Graphics.width;
      maxH = Graphics.height;
      // * Граница от краёв экрана
      screenMargin = margin;
      if (x < screenMargin) {
        return false;
      }
      if (y < screenMargin) {
        return false;
      }
      if (x > (maxW - screenMargin)) {
        return false;
      }
      if (y > (maxH - screenMargin)) {
        return false;
      }
      return true;
    };
    // * Ассинхронная загрузка изображения, возвращает bitmap, когда загружен
    // * Пример использования loadImageAsync(a, b).then(метод)
    // в метод будет передан bitmap первым аргументом
    _.loadImageAsync = async function(folder, filename) {
      var promise;
      promise = new Promise(function(resolve, reject) {
        var b;
        b = ImageManager.loadBitmap("img/" + folder + "/", filename);
        return b.addLoadListener(function() {
          return resolve(b);
        });
      });
      return (await promise);
    };
    // * Преобразовать расширенное значение
    // * Значение может быть X -> X
    // * "X" -> X (цифра)
    // * "X,Y,Z,..." -> [X, Y, Z]
    // * "[X, Y, Z,...]" -> [X, Y, Z]
    // * "X|V" -> из переменной X
    // * [Y] -> случайное число из массива (рекурсивно)
    //@[2.8.1] since
    _.getEValue = function(value) {
      var e, items, randomValue, variableId;
      try {
        if (value == null) {
          return null;
        }
        if (KDCore.SDK.isString(value)) {
          if (isFinite(value)) { // * Число представленно строкой
            return Number(value);
          }
          // * Массив представлен строкой (может быть без квадратных скобок)
          if (value.contains(',') || (value.contains("[") && value.contains("]"))) {
            value = value.replace("[", "");
            value = value.replace("]", "");
            // * Преобразуем в число или строку (например если extended |V)
            items = value.split(",").map(function(item) {
              var itemT;
              itemT = item.trim();
              if (isFinite(itemT)) {
                return Number(itemT);
              } else {
                return itemT;
              }
            });
            // * Вызываем снова эту функцию, но уже с массивом
            return KDCore.Utils.getEValue(items);
          }
          if (value.contains("|V")) {
            variableId = parseInt(value);
            return $gameVariables.value(variableId);
          }
          return value; // * Просто значение в итоге
        } else if (KDCore.SDK.isArray(value)) {
          randomValue = value.sample();
          return KDCore.Utils.getEValue(randomValue);
        } else {
          return value;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return value;
      }
    };
    //@[2.8.2] since
    _.isChanceIsGood = function(chance) {
      var e;
      try {
        if (chance > 1) {
          chance /= 100;
        }
        return chance > Math.random();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[2.8.2] since
    //KEY:w:3:1:50 , KEY:i:10:2:1|V
    //OUTPUT: [GameItem, COUNT]
    _.parseItemFromConditionStr = function(conditionLine) {
      var amount, e, itemChance, itemId, parts, typeId;
      try {
        if (!conditionLine.contains(":")) {
          return null;
        }
        parts = conditionLine.split(":");
        typeId = parts[1];
        itemId = KDCore.Utils.getEValue(parts[2]);
        amount = KDCore.Utils.getEValue(parts[3]);
        if (amount <= 0) {
          return null;
        }
        try {
          itemChance = String.any(parts[4]) ? parts[4] : 100;
          itemChance = KDCore.Utils.getEValue(itemChance) / 100;
        } catch (error) {
          e = error;
          KDCore.warning(e);
          itemChance = 0;
        }
        if (itemChance <= 0) {
          return null;
        }
        if (KDCore.Utils.isChanceIsGood(itemChance)) {
          return [KDCore.Utils.getItemByType(itemId, typeId), amount];
        } else {
          return null;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    //@[3.2.1] since
    _.isValidCE = function(commonEventId) {
      var e;
      try {
        return commonEventId > 0 && ($dataCommonEvents[commonEventId] != null);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[3.2.1] since
    _.startCE = function(commonEventId) {
      var e;
      try {
        if (this.isValidCE(commonEventId)) {
          return $gameTemp.reserveCommonEvent(commonEventId);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    _.checkSwitch = function(value) {
      if (value == null) {
        return false;
      }
      if (isFinite(value)) {
        return false;
      }
      return KDCore.SDK.checkSwitch(value);
    };
    //@[3.2.1] since
    // * Вызвать с задержкой в time миллисекунд
    // * Не забываем про bind
    _.callDelayed = function(method, time = 1) {
      var e;
      try {
        if (method == null) {
          return;
        }
        setTimeout((function() {
          var e;
          try {
            return method();
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        }), time);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    //<meta:1,2,3,4> -> [1,2,3,4]
    _.getArrayOfNumbersFromMeta = function(symbol, obj) {
      var e, values;
      try {
        values = this.getArrayOfValuesFromMeta(symbol, obj);
        return values.map(function(v) {
          return Number(v);
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    //<meta:a,b,c> -> ["a", "b", "c"]
    //<meta:a> -> ["a"]
    _.getArrayOfValuesFromMeta = function(symbol, obj) {
      var e, items, values;
      try {
        values = this.getValueFromMeta(symbol, obj);
        if (String.any(values)) {
          if (values.contains(',')) {
            items = values.split(',');
            return items || [];
          } else {
            return [values];
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    // * Когда содержит одинаковый набор ключей
    //<meta:value1>
    //<meta:value2>
    //...
    // -> [value1,value2,...]
    _.getArrayOfValuesOfSameMeta = function(symbol, obj) {
      var e, j, len, line, lines, result;
      try {
        if (!this.hasMeta(symbol, obj)) {
          return [];
        }
        lines = obj.note.split("\n").filter(function(l) {
          return l.contains(symbol);
        });
        result = [];
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          try {
            line = line.replace("<" + symbol + ":", "");
            line = line.replace(">", "");
            result.push(line);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        return result;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return [];
    };
    //@[3.2.7] since
    _.getIndexIn2DArrayByIJ = function(row, col, cols) {
      return row * cols + col;
    };
    //@[3.2.7] since
    // * row - строка
    // * col - столбец
    _.getIJByIndexIn2DArray = function(index, cols) {
      var col, e, row;
      try {
        row = Math.floor(index / cols);
        col = index % cols;
        return [row, col];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0, 0];
      }
    };
    //@[3.2.7] since
    _.isSwitchIsTRUE = function(switchId) {
      var e;
      if (switchId == null) {
        return true;
      }
      if (switchId <= 0) {
        return true;
      }
      try {
        return $gameSwitches.value(switchId) === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
    //@[3.5] since
    _.convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e;
      try {
        return KDCore.UI.Builder._convertBindingValue(...arguments);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    //@[3.5] since
    _.getRealSpriteSize = function(forField = 'x', sprite = null) {
      var e, h, w;
      try {
        if (sprite == null) {
          return 0;
        }
        if (forField === 'x' || forField === 'width') {
          if (sprite.realWidth != null) {
            w = sprite.realWidth();
          } else {
            w = sprite.width;
          }
          return w;
        } else if (forField === 'y' || forField === 'height') {
          if (sprite.realHeight != null) {
            h = sprite.realHeight();
          } else {
            h = sprite.height;
          }
          return h;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[3.5] since
    _.string2hex = function(string) {
      var e;
      try {
        if (typeof string === 'string' && string[0] === '#') {
          string = string.substr(1);
        }
        return parseInt(string, 16);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0xffffff;
    };
    //@[3.5] since
    _.convertDP = function(value = 0, isHalf = false) {
      var d, e, mod, modX, modY;
      try {
        if (Graphics.width === 816 && Graphics.height === 624) {
          return value;
        }
        modX = Graphics.width / 816;
        modY = Graphics.height / 624;
        // Aprox
        mod = (modX + modY) / 2;
        if (mod === 0) {
          return 0;
        }
        if (isHalf === true) {
          if (mod < 1) {
            d = 1 - mod;
            mod += d / 2;
          } else if (mod > 1) {
            d = mod - 1;
            mod = 1 + (d / 2);
          }
        }
        return Math.round(value * mod);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[2.9.7] since
    // * Shrink number 100000 to "100k" and ect, returns STRING
    _.formatNumberToK = function(num) {
      var e;
      try {
        if (num >= 1000000000) {
          return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'G';
        }
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
        }
        if (num >= 1000) {
          return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
        }
        return num;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return num;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return Window_Base.prototype.drawFaceWithCustomSize = function(faceName, faceIndex, x, y, finalSize) {
    this.contents._needModBltDWH = finalSize;
    this.drawFace(faceName, faceIndex, x, y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__select, _;
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    //@[ALIAS]
    ALIAS__select = _.select;
    _.select = function(index) {
      var e;
      ALIAS__select.call(this, ...arguments);
      try {
        return this._pOnSelectionChanged(index);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._pOnSelectionChanged = function(newIndex) {
      var e;
      try {
        if (this._pkdLastSelectedIndex == null) {
          this._pkdLastSelectedIndex = newIndex;
          return this.pOnSelectionChanged();
        } else {
          if (this._pkdLastSelectedIndex !== newIndex) {
            this._pkdLastSelectedIndex = newIndex;
            return this.pOnSelectionChanged();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.safeSelect = function(index = 0) {
      var e;
      try {
        if (this.maxItems() > index) {
          return this.select(index);
        } else {
          return this.select(-1);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    
    // * Called only when new (different) index is selected
    _.pOnSelectionChanged = function() {};
  })();
});

// ■ END Window_Selectable.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    // * Input Extension: KDGamepad
    //------------------------------------------------------------------------------
    // * Поддержка расширенного управления через геймпад (свой модуль)
    var ALIAS___updateGamepadState, _;
    //@[DEFINES]
    _ = Input;
    // * Активировать работу модуля KDGamepad
    _.activateExtendedKDGamepad = function() {
      return _._kdIsGamepadExtended = true;
    };
    //@[ALIAS]
    ALIAS___updateGamepadState = _._updateGamepadState;
    _._updateGamepadState = function(gamepad) {
      if (Input._kdIsGamepadExtended === true) {
        KDGamepad.update();
      }
      if ((typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp.__kdgpStopDefaultGamepad : void 0) === true) {
        return;
      }
      // * Режим перемещения без DPad
      // * В оригинале игрок также ходит по DPad клавишам, что может быть не удобно
      // * например при работе с инвентарём
      if (KDGamepad.isNoDPadMoving()) {
        if (KDGamepad.isDPadAny()) {
          Input.clear();
          return;
        }
      }
      ALIAS___updateGamepadState.call(this, gamepad);
    };
    window.KDGamepad = function() {
      return new Error("This is static class");
    };
    window.addEventListener("gamepadconnected", function(event) {
      var e;
      try {
        return KDGamepad.refresh();
      } catch (error) {
        // * Можно напрямую
        //unless KDGamepad.isExists()
        //    if event.gamepad? and event.gamepad.mapping == 'standard'
        //        KDGamepad.init(event.gamepad)
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    window.addEventListener("gamepaddisconnected", function(event) {
      var e;
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        if ((event.gamepad != null) && event.gamepad === KDGamepad.gamepad) {
          return KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    KDGamepad.stopDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = true;
    };
    KDGamepad.resumeDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = null;
    };
    // * Ссылка на геймпад
    KDGamepad.gamepad = null;
    // * Подключён ли Gamepad ?
    KDGamepad.isExists = function() {
      return KDGamepad.gamepad != null;
    };
    // * Инициализация состояния кнопок
    // * Этот метод вызывается автоматически из Refresh или при подключении Gamepad
    KDGamepad.init = function(gamepad) {
      KDGamepad.gamepad = gamepad;
      this._isActive = true;
      this.buttonNames = [
        'A', // 0
        'B', // 1
        'X', // 2
        'Y', // 3
        'LB', // 4
        'RB', // 5
        'LTrigger', // 6
        'RTrigger', // 7
        'Back', // 8
        'Start', // 9
        'LStick', // 10
        'RStick', // 11
        'dUp', // 12
        'dDown', // 13
        'dLeft', // 14
        'dRight' // 15
      ];
      this.reset();
    };
    // * Аналог Input.clear
    KDGamepad.clear = function() {
      return KDGamepad.reset();
    };
    // * Сбросить состояние кнопок
    KDGamepad.reset = function() {
      this.leftStick = {
        x: 0,
        y: 0
      };
      this.rightStick = {
        x: 0,
        y: 0
      };
      this.buttons = {};
      this.buttonsPressed = {};
      this.prevButtons = {};
    };
    
    // * Остановить учёт геймпада
    KDGamepad.stop = function() {
      KDGamepad.reset();
      KDGamepad.gamepad = null;
    };
    // * Функция проверки что нажата кнопка на геймпаде
    KDGamepad._buttonPressed = function(gamepad, index) {
      var b, e;
      try {
        if (!gamepad || !gamepad.buttons || index >= gamepad.buttons.length) {
          return false;
        }
        b = gamepad.buttons[index];
        if (b == null) {
          return false;
        }
        if (typeof b === 'object') {
          // * Можно упростить
          return b.pressed;
        }
        return b === 1.0;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    // * Каждый кадр (обновление состояний)
    KDGamepad.update = function() {
      var e, gp, i, isDown, j, len, name, ref;
      if (!KDGamepad.isActive()) {
        return;
      }
      KDGamepad.refresh();
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        gp = KDGamepad.gamepad;
        ref = this.buttonNames;
        // * Проверка состояний кнопок
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          name = ref[i];
          this.buttons[name] = false;
          isDown = KDGamepad._buttonPressed(gp, i);
          if (isDown === true) {
            this.prevButtons[name] = true;
          } else {
            // * Срабатываение только при нажал - отпустил
            if (this.prevButtons[name] === true) {
              this.buttons[name] = true;
              this.prevButtons[name] = false;
            }
          }
        }
        // * Проверка стиков
        this.leftStick.x = gp.axes[0];
        this.leftStick.y = gp.axes[1];
        this.rightStick.x = gp.axes[2];
        this.rightStick.y = gp.axes[3];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Обновить и проверить состояние Gamepad
    // * Надо каждый раз это вызывать
    KDGamepad.refresh = function() {
      var e, gamepads, gp, i, isGamepadRefreshed, j, ref;
      try {
        isGamepadRefreshed = false;
        if (navigator.getGamepads) {
          gamepads = navigator.getGamepads();
        } else if (navigator.webkitGetGamepads) {
          gamepads = navigator.webkitGetGamepads();
        }
        if (gamepads != null) {
          for (i = j = 0, ref = gamepads.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            gp = gamepads[i];
            if ((gp != null) && gp.mapping === 'standard') {
              isGamepadRefreshed = true;
              if (KDGamepad.buttonNames != null) {
                KDGamepad.gamepad = gp;
              } else {
                KDGamepad.init(gp);
              }
              break;
            }
          }
        }
        if (!isGamepadRefreshed) {
          // * Если не был найден не один gamepad - отключаем систему
          KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Любое нажатие кнопки
    KDGamepad.isKeyAny = function(name) {
      return KDGamepad.isKey(name) || KDGamepad.isKeyPressed(name);
    };
    // * Нажата ли кнопка (trigger нажал - отпустил)
    KDGamepad.isKey = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.buttons[name] === true;
    };
    // * Нажата ли кнопка (continues зажата)
    KDGamepad.isKeyPressed = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.prevButtons[name] === true;
    };
    KDGamepad.isDPadAny = function() {
      return KDGamepad.isKeyAny("dLeft") || KDGamepad.isKeyAny("dRight") || KDGamepad.isKeyAny("dUp") || KDGamepad.isKeyAny("dDown");
    };
    KDGamepad.isActive = function() {
      return this._isActive === true;
    };
    // * Временно отключить обработку KDGamepad
    KDGamepad.setActive = function(_isActive) {
      this._isActive = _isActive;
      if (KDGamepad.isActive()) {
        KDGamepad.refresh();
      } else {
        KDGamepad.stop();
      }
    };
    // * Отключить перемещение игрока на DPad
    KDGamepad.setNoDPadMovingMode = function(_noDpadMoving) {
      this._noDpadMoving = _noDpadMoving;
    };
    return KDGamepad.isNoDPadMoving = function() {
      return this._noDpadMoving === true;
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var BitmapSrc;
  BitmapSrc = (function() {
    //?[DEPRECATED]
    class BitmapSrc {
      constructor() {
        this.bitmap = null;
      }

      static LoadFromIconIndex(iconIndex) {
        var bs, icon_bitmap, iconset, ph, pw, sx, sy;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[iconIndex] == null) {
          iconset = ImageManager.loadSystem('IconSet');
          if (KDCore.isMV()) {
            pw = Window_Base._iconWidth;
            ph = Window_Base._iconHeight;
          } else {
            pw = ImageManager.iconWidth;
            ph = ImageManager.iconHeight;
          }
          sx = iconIndex % 16 * pw;
          sy = Math.floor(iconIndex / 16) * ph;
          icon_bitmap = new Bitmap(pw, ph);
          icon_bitmap.addLoadListener(function() {
            icon_bitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
          });
          BitmapSrc.CACHE[iconIndex] = icon_bitmap;
        }
        bs.bitmap = BitmapSrc.CACHE[iconIndex];
        return bs;
      }

      static LoadFromImageFolder(filename) {
        var bs;
        bs = new BitmapSrc();
        bs.bitmap = ImageManager.loadPicture(filename);
        return bs;
      }

      static LoadFromBase64(data, name) {
        var bs;
        bs = new BitmapSrc();
        if (name != null) {
          if (BitmapSrc.CACHE[name] != null) {
            bs.bitmap = BitmapSrc.CACHE[name];
          } else {
            BitmapSrc.CACHE[name] = Bitmap.load(data);
            bs.bitmap = BitmapSrc.CACHE[name];
          }
        } else {
          bs.bitmap = Bitmap.load(data);
        }
        return bs;
      }

      static LoadFromMemory(symbol) {
        var bs;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[symbol] != null) {
          bs.bitmap = BitmapSrc.CACHE[symbol];
        } else {
          bs.bitmap = ImageManager.loadEmptyBitmap();
        }
        return bs;
      }

    };

    BitmapSrc.CACHE = {};

    return BitmapSrc;

  }).call(this);
  //@[EXTEND]
  return KDCore.BitmapSrc = BitmapSrc;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Changer;
  // * Класс который может плавно изменять какой-либо параметр
  // * Работает в стиле chain методов

    // * ------------------ ПРИМЕР ----------------------------------

    // * Меняем прозрачность 4 раза, туда-сюда, затем выводим done в консоль

    //@changer = new KDCore.Changer(someSprite)
  //@changer.change('opacity').from(255)
  //            .to(0).step(5).speed(1).delay(30).repeat(4).reverse()
  //            .start().done(() -> console.log('done'))
  //@changer.update()

    // * -------------------------------------------------------------
  Changer = class Changer {
    constructor(obj) {
      this.obj = obj;
      // * Количество кадров, в которые будет обновление
      this._field = null; // * название поля
      this._speed = 1; // * frames
      this._step = 1; // * шаг изменения значения
      this._from = 0; // * Начальное значение
      this._to = 0; // * Конечное значение
      this._thread = null;
      this._orienation = true; // * Направление + или - step (true = +)
      this._delay = 0; // * Задержка старта
      this._changer = null; // * Ссылка на следующий changer
      this._isRepeat = false; // * Надо ли поторить себя снова
      this._onDoneMethod = null; // * Метод будет выполнен в конце (при завершении)
      this._isPrepared = false; // * Элемента был подготовлен (установлено значение from)
    }

    start() {
      if (this._field == null) {
        return;
      }
      if (this._from === this._to) {
        return;
      }
      if (this._delay > 0) {
        this._delayThread = new KDCore.TimedUpdate(this._delay, this._startThread.bind(this));
        this._delayThread.once();
      } else {
        this._startThread();
      }
      return this;
    }

    isStarted() {
      return (this._thread != null) || (this._delayThread != null);
    }

    from(_from) {
      this._from = _from;
      return this;
    }

    to(_to) {
      this._to = _to;
      return this;
    }

    step(_step) {
      this._step = _step;
      return this;
    }

    speed(_speed) {
      this._speed = _speed;
      return this;
    }

    change(_field) {
      this._field = _field;
      return this;
    }

    // * Снова повторить (не совместим с then)
    // * Если ничего не указать, или <= 0 -> то бескончно
    repeat(_repeatCount = 0) {
      this._repeatCount = _repeatCount;
      if (this._repeatCount <= 0) {
        this._repeatCount = null;
      }
      this._isRepeat = true;
      this._changer = null;
      return this;
    }

    // * Снова повторить, но поменять местами to и from (работает только с repeat >= 2)
    reverse() {
      this._isReverse = true;
      return this;
    }

    isDone() {
      if (!this._isPrepared) {
        // * Чтобы не было выхода пока ждёт Delay
        return false;
      }
      // * Если от 255 до 0 (например)
      if (this._orienation === false) {
        // * То может быть меньше нуля (т.к. @step динамический)
        return this.value() <= this._to;
      } else {
        return this.value() >= this._to;
      }
    }

    value() {
      return this.obj[this._field];
    }

    stop() {
      this._thread = null;
      this._delayThread = null;
      if (this._changer == null) {
        // * Если есть связанный Changer, то не выполняем метод завршения
        return this._callDoneMethod();
      }
    }

    // * При ожидании, значения устанавливаются не сразу
    delay(_delay) {
      this._delay = _delay;
      return this;
    }

    // * Выполнить другой Changer после этого
    // * Не совместим с Repeat
    // * НЕЛЬЗЯ зацикливать, не будет работать
    // * Соединённый не надо обновлять вне, он обновляется в этом
    then(_changer) {
      this._changer = _changer;
      this._isRepeat = false;
      return this;
    }

    // * Этот метод будт выполнене в конце
    done(_onDoneMethod) {
      this._onDoneMethod = _onDoneMethod;
      return this;
    }

    // * Шаг можно выполнить и в ручную
    makeStep() {
      if (!this.isStarted()) {
        this._prepare();
      }
      this._makeStep();
      return this;
    }

    update() {
      var ref;
      if (this.isStarted()) {
        if (this._delay > 0) {
          if ((ref = this._delayThread) != null) {
            ref.update();
          }
        }
        if (this._thread != null) {
          this._updateMainThread();
        }
      } else {
        // * Если хоть раз был запущен
        if (this._isBeenStarted === true) {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
        }
      }
    }

    static CreateForOpacityUp(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(0).to(255).step(step);
      changer.done(function() {
        sprite.opacity = 255;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

    static CreateForOpacityDown(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(sprite.opacity).to(0).step(step);
      changer.done(function() {
        sprite.opacity = 0;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Changer.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Changer.prototype;
    _._prepare = function() {
      if (this._field == null) {
        return;
      }
      this._orienation = this._from < this._to;
      if (!this._orienation) {
        this._step *= -1;
      }
      // * Устанавливаем начальное значение
      this.obj[this._field] = this._from;
      this._isPrepared = true;
    };
    _._makeStep = function() {
      var value;
      if (this.isDone()) {
        return;
      }
      value = this.value();
      value += this._step;
      this.obj[this._field] = value;
    };
    _._startThread = function() {
      this._prepare();
      if (this.isDone()) {
        return;
      }
      this._thread = new KDCore.TimedUpdate(this._speed, this._makeStep.bind(this));
      return this._isBeenStarted = true;
    };
    _._updateChainedChanger = function() {
      if (this._changer.isStarted()) {
        this._changer.update();
        if (this._changer.isDone()) {
          this._callDoneMethod();
          this._changer.stop();
          return this._changer = null;
        }
      } else {
        return this._changer.start();
      }
    };
    _._restart = function() {
      if (!this._isCanRepeatMore()) {
        return;
      }
      if (this._repeatCount == null) {
        // * Если указано! число повторений, то onDone метод не вызываем
        this._callDoneMethod();
      }
      if (this._isReverse === true) {
        this._swapFromTo();
      }
      this._prepare();
      return this.start();
    };
    _._swapFromTo = function() {
      var t;
      t = this._from;
      this._from = this._to;
      this._to = t;
      // * Инвентируем число step
      this._step *= -1;
    };
    _._callDoneMethod = function() {
      if (this._onDoneMethod != null) {
        return this._onDoneMethod();
      }
    };
    _._isCanRepeatMore = function() {
      if (this._repeatCount == null) {
        return true;
      }
      this._repeatCount--;
      if (this._repeatCount <= 0) {
        this.stop();
        return false;
      }
      return true;
    };
    _._updateMainThread = function() {
      this._thread.update();
      if (this.isDone()) {
        if (this._isRepeat === true) {
          this._restart();
        } else {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
          this.stop();
        }
      }
    };
  })();
  // ■ END Changer.coffee
  //---------------------------------------------------------------------------

  //@[EXTEND]
  return KDCore.Changer = Changer;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color;
  Color = (function() {
    //rev 29.04.2024
    class Color {
      constructor(r1 = 255, g1 = 255, b1 = 255, a1 = 255) {
        this.r = r1;
        this.g = g1;
        this.b = b1;
        this.a = a1;
      }

      getLightestColor(lightLevel) {
        var bf, newColor, p;
        bf = 0.3 * this.R + 0.59 * this.G + 0.11 * this.B;
        p = 0;
        newColor = [0, 0, 0, 0];
        if (bf - lightLevel >= 0) {
          if (bf >= 0) {
            p = Math.abs(bf - lightLevel) / lightLevel;
          }
          newColor = this.ARR.map(function(c) {
            return c - (p * c);
          });
        } else {
          if (bf >= 0) {
            p = (lightLevel - bf) / (255 - bf);
          }
          newColor = this.ARR.map(function(c) {
            return [(255 - c) * p + c, 255].min();
          });
        }
        return new Color(newColor[0], newColor[1], newColor[2], newColor[3]);
      }

      clone() {
        return this.reAlpha(this.a);
      }

      reAlpha(newAlpha) {
        return new Color(this.r, this.g, this.b, newAlpha || 255);
      }

      static AddConstantColor(name, color) {
        color.toHex();
        color.toArray();
        color.toCSS();
        KDCore.SDK.setConstantToObject(Color, name, color);
      }

      toHex() {
        var b, g, r;
        if (this._colorHex != null) {
          return this._colorHex;
        }
        r = Math.floor(this.r).toString(16).padZero(2);
        g = Math.floor(this.g).toString(16).padZero(2);
        b = Math.floor(this.b).toString(16).padZero(2);
        return this._colorHex = '#' + r + g + b;
      }

      toArray() {
        if (this._colorArray != null) {
          return this._colorArray;
        }
        return this._colorArray = [this.r, this.g, this.b, this.a];
      }

      toCSS() {
        var na, nb, ng, nr;
        if (this._colorCss != null) {
          return this._colorCss;
        }
        nr = Math.round(this.r);
        ng = Math.round(this.g);
        nb = Math.round(this.b);
        na = this.a / 255;
        return this._colorCss = `rgba(${nr},${ng},${nb},${na})`;
      }

      toNumber() {
        return Number(this.toHex().replace("#", "0x"));
      }

      static Random() {
        var a, b, c;
        a = KDCore.SDK.rand(1, 254);
        b = KDCore.SDK.rand(1, 254);
        c = KDCore.SDK.rand(1, 254);
        return new Color(a, b, c, 255);
      }

      static FromHex(hexString) {
        var color, result, shorthandRegex;
        //Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexString = hexString.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexString);
        color = null;
        if (result != null) {
          color = {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          };
        }
        if (color != null) {
          return new Color(color.r, color.g, color.b, 255);
        } else {
          return Color.NONE;
        }
      }

    };

    Object.defineProperties(Color.prototype, {
      R: {
        get: function() {
          return this.r;
        },
        configurable: true
      },
      G: {
        get: function() {
          return this.g;
        },
        configurable: true
      },
      B: {
        get: function() {
          return this.b;
        },
        configurable: true
      },
      A: {
        get: function() {
          return this.a;
        },
        configurable: true
      },
      ARR: {
        get: function() {
          return this.toArray();
        },
        configurable: true
      },
      CSS: {
        get: function() {
          return this.toCSS();
        },
        configurable: true
      },
      HEX: {
        get: function() {
          return this.toHex();
        },
        configurable: true
      },
      OX: {
        get: function() {
          return this.toNumber();
        },
        configurable: true
      }
    });

    Color.AddConstantColor('NONE', new Color(0, 0, 0, 0));

    Color.AddConstantColor('BLACK', new Color(0, 0, 0, 255));

    Color.AddConstantColor('WHITE', new Color(255, 255, 255, 255));

    Color.AddConstantColor('RED', new Color(255, 0, 0, 255));

    Color.AddConstantColor('GREEN', new Color(0, 255, 0, 255));

    Color.AddConstantColor('BLUE', new Color(0, 0, 255, 255));

    Color.AddConstantColor('AQUA', new Color(128, 255, 255, 255));

    Color.AddConstantColor('MAGENTA', new Color(128, 0, 128, 255));

    Color.AddConstantColor('YELLOW', new Color(255, 255, 0, 255));

    Color.AddConstantColor('ORANGE', new Color(255, 128, 0, 255));

    return Color;

  }).call(this);
  //@[EXTEND]
  return KDCore.Color = Color;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color, DevLog, __TMP_LOGS__;
  Color = KDCore.Color;
  __TMP_LOGS__ = [];
  DevLog = class DevLog {
    constructor(prefix = "") {
      this.prefix = prefix;
      this._isShow = typeof DEV !== 'undefined';
      this._color = Color.BLACK;
      this._backColor = Color.WHITE;
      __TMP_LOGS__.push(this);
    }

    on() {
      this._isShow = true;
      return this;
    }

    off() {
      this._isShow = false;
      return this;
    }

    applyRandomColors() {
      this.applyRandomWithoutBackgroundColors();
      this.setBackColor(Color.Random());
      return this;
    }

    applyRandomWithoutBackgroundColors() {
      this.setColor(Color.Random());
      return this;
    }

    setColor(color) {
      this._color = color;
      return this;
    }

    setBackColor(backColor) {
      this._backColor = backColor;
      return this;
    }

    applyLibraryColors() {
      this.setColors(new Color(22, 120, 138, 0), Color.BLACK);
      return this;
    }

    setColors(color, backColor) {
      this.setColor(color);
      this.setBackColor(backColor);
      return this;
    }

    applyExtensionColors() {
      this.setColors(new Color(22, 143, 137, 0), Color.BLACK.getLightestColor(60));
      return this;
    }

    applyWarningColors() {
      this.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));
      return this;
    }

    p(text) {
      if (!this._isShow) {
        return;
      }
      if (text == null) {
        console.log("");
      }
      this._printText(text);
    }

    _printText(text) {
      text = this.prefix + " : " + text;
      if (this._isUsingColor()) {
        return this._printTextWithColors(text);
      } else {
        return console.log(text);
      }
    }

    _isUsingColor() {
      return this._color !== Color.BLACK || this._backColor !== Color.WHITE;
    }

    _printTextWithColors(text) {
      var args;
      args = ['%c' + text, `color: ${this._color.HEX} ; background: ${this._backColor.HEX};`];
      return window.console.log.apply(console, args);
    }

    static CreateForLib(library) {
      var dlog;
      dlog = new DevLog(library.name);
      dlog.applyLibraryColors();
      return dlog;
    }

    static EnableAllLogs() {
      return __TMP_LOGS__.forEach(function(log) {
        return log.on();
      });
    }

  };
  //@[EXTEND]
  return KDCore.DevLog = DevLog;
});


// Generated by CoffeeScript 2.6.1
// * Класс для глобального события игры (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.GEvent = class GEvent {
    constructor(name) {
      this.name = name;
      this.clear();
    }

    addListener(listener, isSingle = false) {
      if (listener == null) {
        return;
      }
      if (isSingle === true) {
        this.listeners = [listener];
      } else {
        this.listeners.push(listener);
      }
    }

    removeListener(listener) {
      if (listener == null) {
        return;
      }
      return this.listener.delete(listener);
    }

    call() {
      var i, l, len, ref;
      ref = this.listeners;
      for (i = 0, len = ref.length; i < len; i++) {
        l = ref[i];
        l();
      }
    }

    clear() {
      return this.listeners = [];
    }

  };
});


// Generated by CoffeeScript 2.6.1
// * Менеджер для управления глобальными событиями игры (GEvent) (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  var GEventsManager;
  // * Данный менеджер глобальный, т.е. с ним работают ВСЕ плагины, которые его используют!
  GEventsManager = function() {};
  (function() {
    var _;
    _ = GEventsManager;
    // * Существует ли событие с данным именем
    _.isEventExists = function(gEventName) {
      return this._getEventByName(gEventName) != null;
    };
    // * Получить список всех зарегестрированных событий (имён)
    _.getAllEvents = function() {
      if (this.events == null) {
        return [];
      }
      return this.events.map(function(ev) {
        return ev.name;
      });
    };
    // * Зарегестрировать событие (используется только имя события)
    _.register = function(gEventName) {
      if (this.events == null) {
        this.events = [];
      }
      this.events.push(new KDCore.GEvent(gEventName));
    };
    // * Подписаться на событие (имя события) и слушатель
    // * если isSingle == true - то у события может быть только один исполнитель
    _.subscribeFor = function(evName, listener, isSingle = false) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.addListener(listener, isSingle) : void 0;
    };
    // * Подписаться на событие (уникально) для объекта
    // * Т.е. при вызове этого метода ещё раз, если объект
    // * уже подписан на событие, ничего не будет (без дубликатов)
    //? ВНИМАНИЕ ! Если объект подписался через subscribeForX, то
    // выполнив clear по данному evName, он уже не подпишится!
    _.subscribeForX = function(context, evName, listener) {
      var e, key;
      try {
        key = "__kdCoreGEvent_" + evName;
        if (context[key] == null) {
          this.subscribeFor(evName, listener);
          return context[key] = true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Вызвать событие (по имени)
    _.call = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.call() : void 0;
    };
    _.clear = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.clear() : void 0;
    };
    _._getEventByName = function(name) {
      if (!this.events) {
        return null;
      }
      return this.events.find(function(ev) {
        return ev.name === name;
      });
    };
  })();
  //@[EXTEND]
  return KDCore.GEventsManager = GEventsManager;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.MapAnchorPoint = class MapAnchorPoint {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

    shiftY() {
      return 0;
    }

    jumpHeight() {
      return 0;
    }

    scrolledX() {
      return Game_CharacterBase.prototype.scrolledX.call(this);
    }

    scrolledY() {
      return Game_CharacterBase.prototype.scrolledY.call(this);
    }

    screenX() {
      return Game_CharacterBase.prototype.screenX.call(this);
    }

    screenY() {
      return Game_CharacterBase.prototype.screenY.call(this);
    }

    moveTo(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  //?[DEPRECATED]
  return KDCore.ParametersManager = class ParametersManager {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this._cache = {};
      this._parameters = PluginManager.getPluginParametersByRoot(this.pluginName);
    }

    isLoaded() {
      return (this._parameters != null) && this._parameters.hasOwnProperty(this.pluginName);
    }

    isHasParameter(name) {
      return this._parameters[name] != null;
    }

    getString(name) {
      return this._parameters[name];
    }

    convertField(object, fieldName) {
      var e;
      try {
        object[fieldName] = JSON.parse(object[fieldName] || 'false');
      } catch (error) {
        e = error;
        console.error('Error while convert field ' + e.name);
        object[fieldName] = false;
      }
      return object;
    }

    convertImage(object, fieldName) {
      return object[fieldName] = this.loadImage(object[fieldName]);
    }

    loadImage(filename, smooth) {
      var e, path;
      try {
        if (filename) {
          path = filename.split('/');
          filename = path.last();
          path = path.first() + '/';
          return ImageManager.loadBitmap('img/' + path, filename, 0, smooth || true);
        } else {
          return ImageManager.loadEmptyBitmap();
        }
      } catch (error) {
        e = error;
        console.error(e);
        return ImageManager.loadEmptyBitmap();
      }
    }

    getFromCacheOrInit(name, func) {
      var object;
      if (!this.isInCache(name)) {
        if (func != null) {
          object = func.call(this);
          this.putInCache(name, object);
        }
      }
      return this.getFromCache(name);
    }

    isInCache(name) {
      return this._cache.hasOwnProperty(name);
    }

    putInCache(name, object) {
      return this._cache[name] = object;
    }

    getFromCache(name) {
      return this._cache[name];
    }

    getNumber(name) {
      var number;
      number = this.getObject(name);
      if (KDCore.SDK.isInt(number)) {
        return number;
      }
      return 0;
    }

    getObject(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || '{}');
      } else {
        return {};
      }
    }

    getBoolean(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || false);
      } else {
        return false;
      }
    }

    getBooleanFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getBooleanFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getNumberFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getNumberFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getStringFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getStringFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getBooleanFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getBoolean(name);
      });
    }

    getNumberFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getNumber(name);
      });
    }

    getStringFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getString(name);
      });
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.ParamLoader = class ParamLoader {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this.paramsRaw = PluginManager.getPluginParametersByRoot(this.pluginName);
      this.params = this.parseParameters(this.paramsRaw);
    }

    parseParameters(paramSet) {
      var clearKey, key, params, typeKey, value;
      params = {};
      for (key in paramSet) {
        value = paramSet[key];
        KDCore.__ppNameToParseNext = key;
        clearKey = this.parseKey(key);
        typeKey = this.parseKeyType(key);
        params[clearKey] = this.parseParamItem(typeKey, value);
      }
      return params;
    }

    parseKey(keyRaw) {
      return keyRaw.split(":")[0];
    }

    parseKeyType(keyRaw) {
      return keyRaw.split(":")[1];
    }

    writeDetailedError() {
      var e;
      try {
        if (!String.any(KDCore.__ppNameToParseNext)) {
          return;
        }
        return console.warn("Please, check Plugin Parameter " + KDCore.__ppNameToParseNext + " in plugin " + this.pluginName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Проверка, загружены ли параметры плагина
    isLoaded() {
      return (this.paramsRaw != null) && this.paramsRaw.hasOwnProperty(this.pluginName);
    }

    // * Имя параметра без ключа
    isHasParameter(paramName) {
      return this.params[paramName] != null;
    }

    
      // * Возвращает значение параметра (def - по умолчанию, если не найден)
    getParam(paramName, def) {
      var value;
      if (this.isHasParameter(paramName)) {
        value = this.params[paramName];
        if (value != null) {
          return value;
        }
      }
      return def;
    }

    // * Данные ключи должны идти после названия параметра через :
    // * Пример: @param ShowDelay:int, @param TestBool:bool
    // * Текстовые параметры, которые надо вернуть как есть, можно без типа (text, file, combo, ...)
    parseParamItem(type, item) {
      var e;
      if (type == null) {
        return item;
      }
      try {
        switch (type) {
          case "int":
          case "i":
            return Number(item);
          case "intA":
            return this.parseArray(item, "int");
          case "bool":
          case "b":
          case "e":
            return eval(item);
          case "struct":
          case "s":
            return this.parseStruct(item);
          case "structA":
            return this.parseStructArray(item);
          case "str":
            return item;
          case "strA":
            return this.parseArray(item, "str");
          case "note":
            return this.parseNote(item);
          case "css":
            return item.toCss();
          case "color":
            return KDCore.Color.FromHex(item);
          case "json":
          case "j":
            return this.parseJson(item);
          case "jA":
            return this.parseArray(item, 'json');
          default:
            return item;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
        return item;
      }
    }

    parseArray(items, type) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseParamItem(type, p));
          } catch (error) {
            e = error;
            console.warn(e);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseStruct(item) {
      var e, parsed;
      try {
        if (item == null) {
          return null;
        }
        if (!String.any(item)) {
          return null;
        }
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return this.parseParameters(parsed);
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return null;
    }

    parseStructArray(items) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseStruct(p));
          } catch (error) {
            e = error;
            console.warn(e);
            this.writeDetailedError();
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseNote(item) {
      var e, parsed;
      try {
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return parsed;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return item;
    }

    parseJson(item) {
      var cx, e, element, elements, i, json, key, len, parsed, value;
      try {
        json = {};
        parsed = JsonEx.parse(item);
        elements = parsed.split('\n');
        for (i = 0, len = elements.length; i < len; i++) {
          element = elements[i];
          cx = "{" + element + "}";
          try {
            item = JsonEx.parse(cx);
            for (key in item) {
              value = item[key];
              json[key] = value;
            }
          } catch (error) {
            e = error;
            KDCore.warning("Parameter " + element + " have syntax errors, ignored");
          }
        }
        return json;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.writeDetailedError();
        return null; // * Чтобы default value был возвращён
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Point;
  Point = (function() {
    class Point {
      constructor(_x = 0, _y = 0) {
        this._x = _x;
        this._y = _y;
      }

      clone() {
        return new Point(this._x, this._y);
      }

      toString() {
        return "[" + this._x + " ; " + this._y + "]";
      }

      isSame(anotherPoint) {
        return this.x === anotherPoint.x && this.y === anotherPoint.y;
      }

      convertToCanvas() {
        return new Point(Graphics.pageToCanvasX(this._x), Graphics.pageToCanvasY(this._y));
      }

      convertToMap() {
        return new Point($gameMap.canvasToMapX(this._x), $gameMap.canvasToMapY(this._y));
      }

      convertToScreen() {
        return new Point(this.screenX(), this.screenY());
      }

      screenX() {
        var t, tw;
        t = $gameMap.adjustX(this._x);
        tw = $gameMap.tileWidth();
        return Math.round(t * tw + tw / 2);
      }

      screenY() {
        var t, th;
        t = $gameMap.adjustY(this._y);
        th = $gameMap.tileHeight();
        return Math.round(t * th + th);
      }

      round() {
        return new Point(Math.round(this._x), Math.round(this._y));
      }

      floor() {
        return new Point(Math.floor(this._x), Math.floor(this._y));
      }

      mapPointOnScreen() {
        var nx, ny;
        nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
        ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
        return new Point(nx, ny);
      }

      multiplyBy(val) {
        return new Point(this._x * val, this._y * val);
      }

      simple() {
        return new PIXI.Point(this.x, this.y);
      }

      delta(point) {
        var dx, dy;
        dx = point.x - this._x;
        dy = point.y - this._y;
        return new KDCore.Point(dx, dy);
      }

      static _getEmpty() {
        if (Point._emptyPoint == null) {
          Point._emptyPoint = new Point(0, 0);
        }
        return Point._emptyPoint;
      }

    };

    Object.defineProperties(Point.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        configurable: true
      },
      y: {
        get: function() {
          return this._y;
        },
        configurable: true
      }
    });

    Object.defineProperties(Point, {
      Empty: {
        get: function() {
          return Point._getEmpty();
        },
        configurable: false
      }
    });

    Array.prototype.toPoint = function() {
      return new Point(this[0], this[1]);
    };

    Object.defineProperty(Array.prototype, "toPoint", {
      enumerable: false
    });

    Sprite.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    Game_CharacterBase.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    return Point;

  }).call(this);
  //@[EXTEND]
  return KDCore.Point = Point;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return KDCore.Sprite = (function(superClass) {
    //rev 07.05.22

      //@[AUTO EXTEND]
    class Sprite extends superClass {
      constructor() {
        super(...arguments);
        this.pHandledIndex = 0;
        this._create2();
        return;
      }

      _create2() {} // * FOR CHILDRENS

      pIsSupportKeyboardHandle() {
        return false;
      }

      pIsVerticalKeyboardNavigation() {
        return true;
      }

      // * For Childrens
      isLoaded() {
        return true;
      }

      realWidth() {
        var child;
        if (this.width === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realWidth != null) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
        }
        return this.width;
      }

      realHeight() {
        var child;
        if (this.height === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realHeight != null) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
        }
        return this.height;
      }

      dataBindings() {
        return {
          x: function(v) {
            if (v != null) {
              return this.setPosition(v, this.y);
            }
          },
          y: function(v) {
            if (v != null) {
              return this.setPosition(this.x, v);
            }
          },
          position: function(v) {
            if (v != null) {
              return this.setPosition(v);
            }
          },
          anchor: function(v) {
            if (v != null) {
              return this.setCommonAnchor(v);
            }
          },
          animation: function(v) {
            if (v != null) {
              return this.addAnimationRule(v);
            }
          },
          opacity: function(v) {
            if (v != null) {
              return this.opacity = v;
            }
          },
          visible: function(v) {
            if (v != null) {
              return this.visible = v;
            }
          },
          scale: function(v) {
            if (v != null) {
              return this.scale.set(v);
            }
          },
          rotation: function(v) {
            if (v != null) {
              return this.rotation = v;
            }
          }
        };
      }

      callBinding(binding, value) {
        var e, func;
        try {
          func = this.dataBindings()[binding];
          if (func != null) {
            return func.call(this, value);
          } else {
            return console.warn("Binding " + binding + " not found!");
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      refreshBindings(dataObject = null, recursive = true) {
        var child, e, j, len, ref, results;
        try {
          if (dataObject == null) {
            dataObject = this;
          }
          KDCore.UI.Builder.RefreshBindings(this, dataObject);
          if (recursive === true) {
            ref = this.children;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              try {
                if (child.refreshBindings != null) {
                  results.push(child.refreshBindings(dataObject, true));
                } else {
                  results.push(void 0);
                }
              } catch (error) {
                e = error;
                results.push(KDCore.warning(e));
              }
            }
            return results;
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      uiConstant(name) {
        var e;
        try {
          if (this.uiConstants != null) {
            return this.uiConstants[name];
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      addLoadListener(listener) {
        var e;
        try {
          if (listener == null) {
            return;
          }
          if (this.isLoaded()) {
            try {
              return listener();
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          } else {
            return this._addLoadListener(listener);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      setPosition(x = 0, y = null, bindedObj = null) {
        var _x, _y, e;
        try {
          if (!this.isLoaded()) {
            this._requireFunc('setPosition', arguments);
            return;
          }
          // * Check first Argument as Object
          if (typeof x === 'object') {
            if (x.x != null) {
              _x = x.x;
              if (x.y != null) {
                _y = x.y;
              }
              x = _x;
              y = _y;
            } else if (x.position != null) {
              this.setPosition(x.position, null, bindedObj);
              return;
            } else if (x.margins != null) {
              this.setPosition(x.margins, null, bindedObj);
              return;
            }
          }
          if (typeof x === 'string') {
            this.x = this._getValueByStr(x, 'x', bindedObj);
            if (y == null) {
              y = x;
            }
          } else {
            this.x = x; // * Number
          }
          if (typeof y === 'string') {
            return this.y = this._getValueByStr(y, 'y', bindedObj);
          } else {
            if (y != null) {
              return this.y = y;
            }
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _getValueByStr(value = '0', forField = 'x', owner = null) {
        var dpValue, e, exValue, parentRefSize, percentValue, r, result, resultValue, v;
        try {
          if (typeof value === 'number') {
            return value;
          }
          if (isFinite(value)) {
            return Number(value);
          }
          if (typeof value !== 'string') {
            return 0;
          }
          // * NO REPLACEMENT
          if (value[0] === '$' || value[0] === '@') {
            v = KDCore.Utils.convertBindingValue(owner, value, this);
            return this._getValueByStr(v, forField, owner);
          }
          if (value.contains("prevX")) {
            value = value.replace("prevX", this._getPreviousChildData('x'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevY")) {
            value = value.replace("prevY", this._getPreviousChildData('y'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevHeight")) {
            value = value.replace("prevHeight", this._getPreviousChildData('height'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevWidth")) {
            value = value.replace("prevWidth", this._getPreviousChildData('width'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndX")) {
            value = value.replace("prevEndX", "prevX + prevWidth");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndY")) {
            value = value.replace("prevEndY", "prevY + prevHeight");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("end")) {
            value = value.replace("end", "100%");
          }
          if (value.contains("begin")) {
            if (forField === 'y') {
              value = value.replace("begin", "-height");
            } else {
              value = value.replace("begin", "-width");
            }
          }
          if (value.contains("right")) {
            value = value.replace("right", "100% - width");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("left")) {
            value = value.replace("left", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("top")) {
            value = value.replace("top", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("bottom")) {
            value = value.replace("bottom", "100% - height");
            return this._getValueByStr(value, forField, owner);
          }
          // * Replace all X%
          if (value.contains("%")) {
            r = new RegExp("(\\d+)%", "g");
            result = r.exec(value);
            while ((result != null)) {
              percentValue = Number(result[1]);
              resultValue = 0;
              if (this.parent != null) {
                parentRefSize = KDCore.Utils.getRealSpriteSize(forField, this.parent);
                resultValue = parentRefSize * (percentValue / 100.0);
              }
              value = value.replace(/(\d+)%/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all HDP
          if (value.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              value = value.replace(/(\d+)hdp/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all DP
          if (value.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              value = value.replace(/(\d+)dp/, resultValue);
              result = r.exec(value);
            }
          }
          if (value.contains('center')) {
            v = this._getValueByStr('50%', forField, owner);
            exValue = KDCore.Utils.getRealSpriteSize(forField, this);
            exValue = v - (exValue / 2);
            value = value.replace("center", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("height")) {
            exValue = KDCore.Utils.getRealSpriteSize("height", this);
            value = value.replace("height", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("width")) {
            exValue = KDCore.Utils.getRealSpriteSize("width", this);
            value = value.replace("width", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          v = eval(value);
          return this._getValueByStr(v, forField, owner);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      _getPreviousChildData(forField) {
        var e, myIndex, prevChild;
        try {
          if (this.parent == null) {
            return 0;
          }
          if (this.parent.children.length <= 1) {
            return 0;
          }
          myIndex = this.parent.children.indexOf(this);
          prevChild = this.parent.children[myIndex - 1];
          if (prevChild == null) {
            return 0;
          }
          if (forField === "x") {
            return prevChild.x;
          } else if (forField === "y") {
            return prevChild.y;
          } else {
            return KDCore.Utils.getRealSpriteSize(forField, prevChild);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      setCommonAnchor(x, y) {
        var c, e, j, len, ref;
        try {
          if (y == null) {
            y = x;
          }
          this.anchor.x = x;
          this.anchor.y = y;
          ref = this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            if (c.setCommonAnchor != null) {
              c.setCommonAnchor(x, y);
            } else {
              c.anchor.x = x;
              c.anchor.y = y;
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      zeroChild() {
        return this.children[0];
      }

      appear(step, delay = 0) {
        this.opacity = 0;
        this._opChanger = KDCore.Changer.CreateForOpacityUp(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      disapper(step, delay = 0) {
        this._opChanger = KDCore.Changer.CreateForOpacityDown(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      moveWithAnimation(dx, dy, duration = 30, easingType = 2) {
        var e;
        try {
          this._moveAnimationItem = new Game_Picture();
          this._moveAnimationItem._x = this.x;
          this._moveAnimationItem._y = this.y;
          this._moveAnimationItem.move(0, this.x + dx, this.y + dy, 1, 1, 255, 0, duration, easingType);
          this.updateMovingAnimation = this.updateMovingAnimationBody;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      assignTooltip(content, params) {
        if (this._tooltip != null) {
          this.removeChild(this._tooltip);
        }
        this._tooltip = new KDCore.UI.Sprite_UITooltip(params);
        this._tooltip.addContent(content);
        this.updateTooltip = this.updateTooltipBody;
      }

      destroyTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this.hideTooltip();
        this.removeChild(this._tooltip);
        this._tooltip = null;
        return this.updateTooltip = function() {}; // * EMPTY
      }

      showTooltip() {
        if (this._tooltip == null) {
          return;
        }
        // * Position 0, 0, becouse cursorRelative by default
        this._tooltip.activateTooltip(0, 0, this);
      }

      hideTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this._tooltip.deactivateTooltip();
      }

      //@[DYNAMIC]
      updateTooltip() {} // * EMPTY

      updateTooltipBody() {
        if (this.isUnderMouse()) {
          if (this._tooltip.isTooltipActive()) {

          } else {
            if (this.isReady() && this.visible === true && this.opacity >= 255) {
              return this.showTooltip();
            }
          }
        } else {
          if (this._tooltip.isTooltipActive()) {
            return this.hideTooltip();
          }
        }
      }

      //@[DYNAMIC]
      updateMovingAnimation() {} // * EMPTY

      updateMovingAnimationBody() {
        var e;
        try {
          if (this._moveAnimationItem == null) {
            return;
          }
          this._moveAnimationItem.update();
          this.x = this._moveAnimationItem._x;
          this.y = this._moveAnimationItem._y;
          if (this._moveAnimationItem._duration <= 0) {
            this._moveAnimationItem = null;
            this.updateMovingAnimation = function() {};
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          this.updateMovingAnimation = function() {};
        }
      }

      addAnimationRule(rule) {
        var e, r;
        try {
          if (rule == null) {
            return;
          }
          if (this._animationRules == null) {
            this._animationRules = [];
          }
          if (typeof rule === 'object' && (rule.animationConfig != null) && (rule.update != null)) {
            r = rule;
          } else {
            r = new KDCore.AnimationRule(rule, this);
          }
          this._animationRules.push(r);
          return r;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      setAnimationRule(rule) {
        var e;
        try {
          this._animationRules = [];
          return this.addAnimationRule(rule);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      update() {
        super.update();
        this._updateOpChanger();
        this.updateTooltip();
        if (this.updateMovingAnimation != null) {
          this.updateMovingAnimation();
        }
        if (this.pIsHandlerActive()) {
          this._pHandleKeyboardInputs();
        }
        if (this.devdrag === true) {
          this._pUpdateDevDrag();
        }
        if (this._animationRules != null) {
          this._pUpdateAnimationRules();
        }
      }

      _pUpdateAnimationRules() {
        var e, j, len, ref, results, rule;
        try {
          ref = this._animationRules;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            rule = ref[j];
            rule.update();
            results.push(rule.applyAnimation(this));
          }
          return results;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //@[DYNAMIC]
      _updateOpChanger() {} // * EMPTY

      b() {
        return this.bitmap;
      }

      clear() {
        return this.bitmap.clear();
      }

      add() {
        return this.addChild(...arguments);
      }

      bNew(w, h) {
        if (h == null) {
          h = w;
        }
        return this.bitmap = new Bitmap(w, h);
      }

      bImg(filename, sourceFolder) {
        var getterFunc;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder != null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
          };
        }
        return this.bitmap = getterFunc(filename);
      }

      onReady(method) {
        if (method != null) {
          return this.bitmap.addLoadListener(method);
        }
      }

      drawText() {
        return this.bitmap.drawText(...arguments);
      }

      drawTextFull(text, position = "center") {
        if (this.textSettingsPosition != null) {
          position = this.textSettingsPosition;
        }
        return this.bitmap.drawTextFull(text, position);
      }

      //?DEPRECATED
      drawTextWithSettings(text) {
        this.clear();
        this.drawTextFull(text, this.textSettingsPosition);
      }

      //? x, y, icon, size
      drawIcon() {
        return this.bitmap.drawIcon(...arguments);
      }

      moveByJson(settings) {
        var pos;
        pos = KDCore.Utils.getPositionPointFromJSON(settings);
        return this.move(pos.x, pos.y);
      }

      applyTextSettingsByJson(sprite, settings) {
        this.applyTextSettingsByExtraSettings(sprite, settings.text);
      }

      applyTextSettingsByExtraSettings(sprite, s) {
        sprite.move(s.marginX, s.marginY);
        sprite.b().fontSize = s.fontSize;
        sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
        sprite.b().outlineWidth = s.outlineWidth;
        if (s.outlineColor != null) {
          sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
        }
        if (s.fontFace != null) {
          sprite.b().fontFace = s.fontFace;
        }
        sprite.b().fontItalic = s.fontItalic;
        sprite.visible = s.visible;
      }

      isReady() {
        var i, j, ref;
        if (this.bitmap != null) {
          if (!this.bitmap.isReady()) {
            return false;
          }
        }
        for (i = j = 0, ref = this.children.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (!this.children[i].bitmap.isReady()) {
            return false;
          }
        }
        return true;
      }

      isCheckAlpha() {
        return false;
      }

      inPosition(point) {
        var e, gx, gy, pixel, result, x, y;
        result = this.isContainsPoint(point);
        if (result && this.isCheckAlpha()) {
          try {
            ({x, y} = point);
            gx = KDCore.SDK.toGlobalCoord(this, 'x');
            gy = KDCore.SDK.toGlobalCoord(this, 'y');
            pixel = this.bitmap.getAlphaPixel(x - gx, y - gy);
            result = pixel > 100;
          } catch (error) {
            e = error;
            KDCore.warning(e);
            result = true; // * ignor Alpha if error
          }
        }
        return result;
      }

      isUnderMouse() {
        return this.inPosition(TouchInput);
      }

      // * Из параметров плагина
      applyFontParam(font) {
        var b;
        if (font == null) {
          return;
        }
        b = this.b();
        if (font.size != null) {
          b.fontSize = font.size;
        }
        if (!String.isNullOrEmpty(font.face)) {
          b.fontFace = font.face;
        }
        if (font.italic != null) {
          b.fontItalic = font.italic;
        }
      }

      applyOutlineParam(outline) {
        var b;
        if (outline == null) {
          return;
        }
        b = this.b();
        if (outline.width != null) {
          b.outlineWidth = outline.width;
        }
        if (!String.isNullOrEmpty(outline.color)) {
          b.outlineColor = outline.color;
        }
      }

      activateHandlerManagment() {
        var e;
        try {
          this.handleUpAction = this.selectPreviousHandlerItem;
          this.handleDownAction = this.selectNextHandlerItem;
          return this._handleManagerActive = true;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      deactivateHandlerManagment() {
        var ref;
        this._handleManagerActive = false;
        this.handleUpAction = function() {}; // * EMPTY
        this.handleDownAction = function() {}; // * EMPTY
        if ((ref = $gameTemp.__pkdActiveKeyboardHandler) != null) {
          ref.pDeactivateHandler();
        }
        $gameTemp.__pkdActiveKeyboardHandler = null;
      }

      addChild(item) {
        var c, handlers;
        c = super.addChild(...arguments);
        if (item instanceof KDCore.Sprite && (item.pIsSupportKeyboardHandle != null) && item.pIsSupportKeyboardHandle()) {
          handlers = this._pGetAllHandlers();
          item.pHandledIndex = handlers.length - 1;
        }
        return c;
      }

      pIsAnyHandlerSelected() {
        return $gameTemp.__pkdActiveKeyboardHandler != null;
      }

      selectPreviousHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() - 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _selectedHandlerIndex() {
        return $gameTemp.__pkdActiveKeyboardHandler.pHandledIndex;
      }

      _trySelectHandler(index) {
        var e, handlerItemToSelect;
        try {
          handlerItemToSelect = this._pGetAllHandlers().find(function(i) {
            return i.pHandledIndex === index;
          });
          if (handlerItemToSelect != null) {
            handlerItemToSelect.pActivateHandler();
          }
          return this._pOnHandled();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pGetAllHandlers() {
        return this.children.filter(function(i) {
          return i instanceof KDCore.Sprite && (i.pIsSupportKeyboardHandle != null) && i.pIsSupportKeyboardHandle();
        });
      }

      selectNextHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() + 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      activeItemFilterOptions() {
        return {
          distance: 15,
          outerStrength: 4
        };
      }

      pIsHandlerActive() {
        return this._handleManagerActive === true || this._handlerActive === true;
      }

      destroy() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        return super.destroy();
      }

      _pOnHandled() {
        return Input.clear();
      }

      _pHandleKeyL(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleLeftAction != null) {
              this.handleLeftAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyU(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyR(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleRightAction != null) {
              this.handleRightAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyD(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyU(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleUpAction != null) {
              this.handleUpAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyL(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyD(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleDownAction != null) {
              this.handleDownAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyR(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyOK() {
        var e;
        try {
          if (this.handleOKAction != null) {
            this.handleOKAction();
            return this._pOnHandled();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pActivateHandler() {
        if (!this.pIsSupportKeyboardHandle()) {
          return;
        }
        if (($gameTemp.__pkdActiveKeyboardHandler != null) && $gameTemp.__pkdActiveKeyboardHandler !== this) {
          $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
        }
        this._handlerActive = true;
        this._activateHandlerVisually();
        $gameTemp.__pkdActiveKeyboardHandler = this;
      }

      _activateHandlerVisually() {
        var e;
        try {
          //@filters = [new PIXI.filters.OutlineFilter(0.8, 0x99ff99, 0.5)]
          //@filters = [new PIXI.filters.GlowFilter(2, 0.8, 0, 0x09f9, 0.5)]
          return this.filters = [new PIXI.filters.GlowFilter(this.activeItemFilterOptions())];
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pDeactivateHandler() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        this._handlerActive = false;
        this.filters = [];
      }

      _pHandleKeyboardInputs() {
        var e;
        try {
          if (Input.isTriggered('left')) {
            return this._pHandleKeyL();
          } else if (Input.isTriggered('right')) {
            return this._pHandleKeyR();
          } else if (Input.isTriggered('up')) {
            return this._pHandleKeyU();
          } else if (Input.isTriggered('down')) {
            return this._pHandleKeyD();
          } else if (Input.isTriggered('ok')) {
            return this._pHandleKeyOK();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _applyRequiredData() {
        var _n, e, func, j, len, ref;
        try {
          if (this._requiredFuncs == null) {
            return;
          }
          ref = this._requiredFuncs;
          for (j = 0, len = ref.length; j < len; j++) {
            func = ref[j];
            try {
              _n = func[0];
              if ((_n != null) && (this[_n] != null)) {
                this[_n](...func[1]);
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._requiredFuncs = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _requireFunc(name, args) {
        var e;
        try {
          if (this._requiredFuncs == null) {
            this._requiredFuncs = [];
          }
          return this._requiredFuncs.push([name, args]);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _addLoadListener(listener) {
        var e;
        try {
          if (this._loadListeners == null) {
            this._loadListeners = [];
          }
          return this._loadListeners.push(listener);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _executeLoadListeners() {
        var e, j, l, len, ref;
        try {
          if (!this._loadListeners) {
            return;
          }
          ref = this._loadListeners;
          for (j = 0, len = ref.length; j < len; j++) {
            l = ref[j];
            try {
              l();
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._loadListeners = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * DEVELOPER TOOL ====================================
      _pUpdateDevDrag() {
        if (TouchInput.isLongPressed()) {
          if (this.__ddIn === true) {
            return this._pDD_moving();
          } else {
            if (this.isUnderMouse()) {
              return this._pDD_startMove();
            }
          }
        } else {
          if (this.__ddIn === true) {
            return this._pDD_stopMove();
          }
        }
      }

      _pDD_moving() {
        this.x = TouchInput.x - this._pDDTDelta.x;
        return this.y = TouchInput.y - this._pDDTDelta.y;
      }

      _pDD_startMove() {
        var x, y;
        ({x, y} = TouchInput);
        this._pDDTDelta = {x, y};
        this.__ddIn = true;
      }

      _pDD_stopMove() {
        this.__ddIn = false;
        console.log("DD DRAG POS: ");
        return console.log(this.x, this.y);
      }

      // * STATIC ==================================================
      static WhiteRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#FFF');
      }

      static BlackRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#000');
      }

      static ColorRect(w, h, color) {
        var s;
        s = KDCore.Sprite.FromBitmap(w, h);
        s.b().fillAll(color);
        return s;
      }

      static FromImg(filename, sourceFolder) {
        var s;
        s = new KDCore.Sprite();
        s.bImg(filename, sourceFolder);
        return s;
      }

      static FromBitmap(w, h) {
        var s;
        s = new KDCore.Sprite();
        s.bNew(w, h);
        return s;
      }

      static FromTextSettings(settings) {
        var s;
        s = KDCore.Sprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
        s.applyTextSettingsByExtraSettings(s, settings);
        s.textSettingsPosition = settings.position;
        return s;
      }

      // * Загрузчик из параметров плагина (безопасный)
      static FromParams(pluginParams) {
        var e, h, height, margins, s, size, w, width;
        try {
          size = pluginParams.size;
          ({w, h} = size);
          try {
            if (String.any(w)) {
              if (isFinite(w)) {
                w = Number(w);
              } else {
                w = eval(w);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(h)) {
              if (isFinite(h)) {
                h = Number(h);
              } else {
                h = eval(h);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          ({width, height} = size);
          try {
            if (String.any(width)) {
              if (isFinite(width)) {
                w = Number(width);
              } else {
                w = eval(width);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(height)) {
              if (isFinite(height)) {
                h = Number(height);
              } else {
                h = eval(height);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          s = KDCore.Sprite.FromBitmap(w, h);
          s.textSettingsPosition = pluginParams.alignment;
          margins = pluginParams.margins;
          if (margins != null) {
            s.move(margins.x, margins.y);
          }
          s.applyFontParam(pluginParams.font);
          s.applyOutlineParam(pluginParams.outline);
          if (!String.isNullOrEmpty(pluginParams.textColor)) {
            s.b().textColor = pluginParams.textColor;
          }
          if (pluginParams.visible != null) {
            s.visible = pluginParams.visible;
          }
          return s;
        } catch (error) {
          e = error;
          console.warn('Something wrong with Text Settings!', e);
          return KDCore.Sprite.FromBitmap(60, 30);
        }
      }

    };

    return Sprite;

  }).call(this, Sprite);
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.TimedUpdate = class TimedUpdate {
    constructor(interval, method) {
      this.interval = interval;
      this.method = method;
      this._timer = 0;
      this._once = false;
    }

    update() {
      if (this.interval == null) {
        return;
      }
      if (this._timer++ >= this.interval) {
        this.call();
        this._timer = 0;
        if (this._once === true) {
          return this.stop();
        }
      }
    }

    once() {
      return this._once = true;
    }

    onUpdate(method) {
      this.method = method;
    }

    stop() {
      return this.interval = null;
    }

    isAlive() {
      return this.interval != null;
    }

    // * Рандомизировать интервал @interval (-min, +max)
    applyTimeRange(min, max) {
      var value;
      if (!this.isAlive()) {
        return;
      }
      value = KDCore.SDK.rand(min, max);
      return this.interval += value;
    }

    call() {
      if (this.method != null) {
        return this.method();
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyFrame = class AnimationKeyFrame {
    constructor(startValue, endValue, duration = 1, func = 'linear') {
      this.startValue = startValue;
      this.endValue = endValue;
      this.func = func;
      this._t = 0; // * Timer
      this._d = duration * 60; // * Convert to Frames
      this._c = this.endValue - this.startValue; // * Change
      if (this.func == null) {
        this.func = 'linear';
      }
      return;
    }

    reset() {
      return this._t = 0;
    }

    update() {
      if (this._t < this._d) {
        return this._t += 1;
      }
    }

    isEnd() {
      return this._t >= this._d || this._d <= 0;
    }

    getValue() {
      if (this._d <= 0) {
        return this.endValue;
      } else {
        return this.easingFunc()(this._t, this.startValue, this._c, this._d);
      }
    }

    easingFunc() {
      if ((this.func != null) && (KDCore.EasingFuncs[this.func] != null)) {
        return KDCore.EasingFuncs[this.func];
      } else {
        console.warn("Easing func " + this.func + " not found!");
        return this.linear;
      }
    }

    // * Default one
    linear(t, b, c, d) {
      return c * t / d + b;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyLine = class AnimationKeyLine {
    constructor(keyFramesList, totalDuration = 1, func = 'linear') {
      this.totalDuration = totalDuration;
      this.keyFrames = this._parseKeyFrames(keyFramesList, func);
      this.repeatsLeftBase = 0;
      this.repeatsLeft = 0;
      this.keyIndex = 0;
      this._relativeValue = 0;
      this._isStarted = false;
      return;
    }

    setRelativeValue(_relativeValue) {
      this._relativeValue = _relativeValue;
    }

    setRepeatsCount(repeatsLeftBase) {
      this.repeatsLeftBase = repeatsLeftBase;
      return this.repeatsLeft = this.repeatsLeftBase;
    }

    setLoop() {
      return this.setRepeatsCount(-1);
    }

    start(startDelay = 0) {
      this.startDelay = startDelay;
      if (this.startDelay === 0) {
        return this._isStarted = true;
      } else {
        return this._startTimer = this.startDelay * 60;
      }
    }

    pause() {
      this._isStarted = false;
      this._startTimer = null;
    }

    isStarted() {
      return this._isStarted === true;
    }

    complete() {
      this.keyIndex = this.keyFrames.length;
      this.repeatsLeft = 0;
    }

    reset() {
      this.repeatsLeft = this.repeatsLeftBase;
      this._resetKeyframes();
    }

    update() {
      if (this._startTimer != null) {
        this._updateStartTimer();
      }
      if (!this.isStarted()) {
        return;
      }
      if (this.isEnd()) {
        if (this.repeatsLeft === 0) { // * No repeats at all
          return;
        } else if (this.repeatsLeft < 0) { // * Infinite Loop
          this._resetKeyframes();
        } else {
          this.repeatsLeft -= 1;
          this._resetKeyframes();
        }
      }
      this.keyFrames[this.keyIndex].update();
      if (this.keyFrames[this.keyIndex].isEnd()) {
        //console.log("NEXT")
        this.keyIndex++;
      }
    }

    isEnd() {
      return this.keyIndex > this.keyFrames.length - 1;
    }

    getValue() {
      var value;
      if (this.isEnd()) {
        value = this.keyFrames.last().getValue();
      } else {
        value = this.keyFrames[this.keyIndex].getValue();
      }
      return value + this._relativeValue;
    }

    _parseKeyFrames(keyframes, func) {
      var duration, e, endValue, endValues, index, key, keyframesOutput, keys, kf, prevKey, startValue, value;
      try {
        keyframesOutput = [];
        endValues = [];
        keys = [];
        index = 0;
        for (key in keyframes) {
          value = keyframes[key];
          if (endValues.length > 0) {
            startValue = endValues[index - 1];
          } else {
            startValue = 0;
          }
          endValue = value;
          if (key === "0") {
            duration = 0;
          } else {
            prevKey = keys[index - 1];
            duration = this._calculateDuration(prevKey, key);
          }
          kf = new KDCore.AnimationKeyFrame(startValue, endValue, duration, func);
          keys[index] = key;
          endValues[index] = value;
          keyframesOutput.push(kf);
          index++;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return keyframesOutput;
    }

    _calculateDuration(rateA, rateB) {
      var d, e, timeA, timeB;
      try {
        rateA = Number(rateA) / 100.0;
        rateB = Number(rateB) / 100.0;
        timeA = this.totalDuration * rateA;
        timeB = this.totalDuration * rateB;
        d = timeB - timeA;
        return d;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    }

    _resetKeyframes() {
      var e, f, i, len, ref, results;
      try {
        this.keyIndex = 0;
        ref = this.keyFrames;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          results.push(f.reset());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateStartTimer() {
      var e;
      try {
        if (this._startTimer == null) {
          return;
        }
        this._startTimer -= 1;
        if (this._startTimer <= 0) {
          this._isStarted = true;
          return this._startTimer = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationRule = class AnimationRule {
    constructor(animationConfig, obj) {
      var delay, duration, func, keyframes, repeats;
      if (typeof animationConfig === "string") {
        animationConfig = KDCore.UI.Builder.ConvertShortcut(animationConfig);
      }
      this.animationConfig = Object.assign(this.defaultConfig(), animationConfig);
      ({keyframes, duration, func, repeats, delay} = this.animationConfig);
      this.keyLine = new KDCore.AnimationKeyLine(keyframes, duration, func);
      if (repeats == null) {
        repeats = 0;
      }
      this.keyLine.setRepeatsCount(repeats);
      if (this.animationConfig.relative === true && (obj != null)) {
        this.keyLine.setRelativeValue(obj[this.animationConfig.field]);
      }
      this.keyLine.start(delay);
      if ((obj != null) && delay <= 0) {
        this.applyAnimation(obj);
      }
      return;
    }

    setEndCallback(onEndCallback) {
      this.onEndCallback = onEndCallback;
    }

    isHaveEndCallback() {
      var e;
      try {
        if (this.animationConfig.repeats !== 0) {
          // * Callback works only for single-shot animations
          return false;
        }
        return this.onEndCallback != null;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultConfig() {
      return {
        field: "opacity",
        duration: 1,
        func: "linear",
        delay: 0,
        repeats: 0,
        relative: false,
        keyFrames: {
          "0": 0,
          "100": 255
        }
      };
    }

    update() {
      var e;
      this.keyLine.update();
      if (this.isHaveEndCallback()) {
        if (this.keyLine.isEnd()) {
          try {
            this.onEndCallback();
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
          this.onEndCallback = null;
        }
      }
    }

    applyAnimation(obj) {
      var e;
      try {
        if (obj == null) {
          return;
        }
        return obj[this.animationConfig.field] = this.keyLine.getValue();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  
    // * Button (Sprite_XButton)

    //@[AUTO EXTEND]
  //?DEPRECATED
  return KDCore.Button = class Button extends Sprite {
    constructor() {
      super();
      this._mouseIn = false;
      this._touching = false;
      this._slowUpdateActive = false;
      this._localMode = false;
      this._images = [];
      this._checkAlpha = false;
      this._textSprite = null;
      this._textPosition = 0;
      this._override = false; // * TouchClick in game messages not work anymore if TRUE
      this._clickHandlers = [];
      this._manualHided = false;
      this._manualDisabled = false;
      this._condition = null; // * Условие для Visible
      this._condition2 = null; // * Условие для Enable \ Disable
      this._disabled = false;
      this._infoData = null;
      this._isNeedShowText = false;
      return;
    }

    isMouseInButton() {
      return this._mouseIn === true;
    }

    isActive() {
      return this.visible === true;
    }

    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    setLocalMode() {
      this._realX = this.x;
      this._realY = this.y;
      return this._localMode = true;
    }

    setAlphaMode() {
      return this._checkAlpha = true;
    }

    // * above, below
    setTextPosition(position) {
      return this._textPosition = position;
    }

    setHelpText(text, size) {
      return this._createText(text, size);
    }

    setInfoData(data) {
      return this._infoData = data;
    }

    setOverrideMode() {
      return this._override = true;
    }

    isOverride() {
      return this._override === true && this.isActive() && this.touchInButton();
    }

    isDisabled() {
      return this._disabled === true;
    }

    isEnabled() {
      return !this.isDisabled();
    }

    isNeedShowText() {
      return this._isNeedShowText === true;
    }

    addClickHandler(method) {
      return this._clickHandlers.push(method);
    }

    clearClickHandlers() {
      return this._clickHandlers = [];
    }

    isLocalMode() {
      return this._localMode === true;
    }

    setCondition(method) {
      return this._condition = method;
    }

    setConditionForDisable(method) {
      return this._condition2 = method;
    }

    getInfoData() {
      return this._infoData;
    }

    simulateClick() { //?NEW
      return this.applyClickedState();
    }

    simulateClickManual() { //?NEW
      this.simulateClick();
      return setTimeout((() => {
        try {
          return this.applyNormalState();
        } catch (error) {

        }
      }), 50);
    }

    prepare() { //?NEW
      return this.slowUpdate();
    }

    realX() {
      if (this.isLocalMode()) {
        return this._realX;
      } else {
        return this.x;
      }
    }

    realY() {
      if (this.isLocalMode()) {
        return this._realY;
      } else {
        return this.y;
      }
    }

    show() {
      this.visible = true;
      return this._manualHided = false;
    }

    hide() {
      this.visible = false;
      return this._manualHided = true;
    }

    disable() {
      this._disabled = true;
      this._manualDisabled = true;
      this.refreshEnDisState();
      return this._mouseIn = false;
    }

    enable() {
      this._disabled = false;
      this._manualDisabled = false;
      return this.refreshEnDisState();
    }

    update() {
      super.update();
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseClick();
      this.updatePosition();
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
      return this.updateComplexTextVisible();
    }

    slowUpdate() {
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseTracking();
      this.updateConditionForVisible();
      return this.updateConditionForEnabling();
    }

    updateMouseTracking() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.cursorInButton()) {
        this._onMouseEnter();
        return this._mouseIn = true;
      } else {
        this._onMouseLeave();
        return this._mouseIn = false;
      }
    }

    // * In MZ TouchInput always have X,Y
    cursorInButton() {
      return this.touchInButton();
    }

    xyInButton(x, y) {
      var inRect, rect, rx, ry;
      rx = KDCore.SDK.toGlobalCoord(this, 'x');
      ry = KDCore.SDK.toGlobalCoord(this, 'y');
      rect = new PIXI.Rectangle(rx, ry, this._realWidth(), this._realHeight());
      inRect = rect.contains(x, y);
      if (inRect === true && this._checkAlpha === true) {
        return this._checkAlphaPixel(x - rx, y - ry);
      } else {
        return inRect;
      }
    }

    _realWidth() {
      if (this._hasImage()) {
        return this._mainImage().width;
      } else {
        return this.width;
      }
    }

    _hasImage() {
      return this._mainImage() != null;
    }

    _mainImage() {
      return this._images[0];
    }

    _realHeight() {
      if (this._hasImage()) {
        return this._mainImage().height;
      } else {
        return this.height;
      }
    }

    _checkAlphaPixel(x, y) {
      var pixel;
      pixel = this._hasImage() ? this._mainImage().bitmap.getAlphaPixel(x, y) : this.bitmap.getAlphaPixel(x, y);
      return pixel >= 200;
    }

    _onMouseEnter() {
      if (this._mouseIn === true) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyCoverState();
      }
      this._showText();
      if (this.getInfoData() != null) {
        return this._startComplexTimer();
      }
    }

    _onMouseLeave() {
      if (this._mouseIn === false) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyNormalState();
      }
      this._hideText();
      return this._stopComplexTimer();
    }

    _showText() {
      if (this._textSprite == null) {
        return;
      }
      this._updateTextPosition();
      return this._textSprite.visible = true;
    }

    _hideText() {
      if (this._textSprite == null) {
        return;
      }
      return this._textSprite.visible = false;
    }

    _startComplexTimer() {
      this._stopComplexTimer();
      return this._cTimer = setTimeout((() => {
        if (this._mouseIn === true) {
          return this._isNeedShowText = true;
        }
      }), 1000);
    }

    _stopComplexTimer() {
      if (this._cTimer != null) {
        clearTimeout(this._cTimer);
      }
      return this._isNeedShowText = false;
    }

    updateMouseClick() {
      if (!this.isActive()) {
        this._unTouch();
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.touchInButton()) {
        this._touching = true;
        this.applyClickedState();
      }
      if (this._touching === true) {
        if (TouchInput.isReleased() || !this.touchInButton()) {
          this._unTouch();
          if (TouchInput.isReleased()) {
            return this.callClickHandler();
          }
        }
      }
    }

    _unTouch() {
      this._touching = false;
      if (this.touchInButton()) {
        return this.applyCoverState();
      } else {
        return this.applyNormalState();
      }
    }

    touchInButton() {
      return this.xyInButton(TouchInput.x, TouchInput.y);
    }

    callClickHandler() {
      if (this._clickHandlers.length > 0) {
        return this._clickHandlers.forEach(function(method) {
          return method();
        });
      }
    }

    updatePosition() {
      var p;
      if (!this._localMode) {
        return;
      }
      p = new KDCore.Point(this._realX, this._realY);
      return this.move(p.screenX(), p.screenY());
    }

    updateConditionForVisible() {
      var result;
      if (this._condition == null) {
        return;
      }
      if (this._manualHided === true) {
        return;
      }
      try {
        result = this._condition();
        return this.visible = !result;
      } catch (error) {
        console.warn('wrong condition in button');
        return this.visible = true;
      }
    }

    updateConditionForEnabling() {
      if (!this._condition2) {
        return;
      }
      if (this._manualDisabled === true) {
        return;
      }
      try {
        this._disabled = this._condition2();
        return this.refreshEnDisState();
      } catch (error) {
        console.warn('wrong condition in button for enable state');
        return this.disable();
      }
    }

    setButtonImages(img1, img2, img3, img4) {
      if (this._images != null) {
        this._images.forEach(function(img) {
          if (img != null) {
            return img.parent.removeChild(img);
          }
        });
      }
      this._images = [new Sprite(img1), img2 != null ? new Sprite(img2) : void 0, img3 != null ? new Sprite(img3) : void 0, img4 != null ? new Sprite(img4) : void 0];
      this._images.forEach((img) => {
        if (img != null) {
          return this.addChild(img);
        }
      });
      return this.applyNormalState();
    }

    applyNormalState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[0]) != null ? ref.visible = true : void 0;
    }

    refreshImages() {
      return this._images.forEach(function(img) {
        return img != null ? img.visible = false : void 0;
      });
    }

    applyCoverState() {
      this.refreshImages();
      if (this._images[1] != null) {
        return this._images[1].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    applyClickedState() {
      this.refreshImages();
      if (this._images[2] != null) {
        return this._images[2].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    _createText(text, size) {
      var h, w;
      if (this._textSprite) {
        this.removeChild(this._textSprite);
      }
      w = Math.round(((size / 10) + 1) * 5 * text.length);
      h = size + 4;
      this._textSprite = new Sprite(new Bitmap(w, h));
      this._textSprite.bitmap.fontSize = size;
      this._textSprite.bitmap.drawText(text, 0, h / 2, w, 1, 'center');
      this._textSprite.visible = false;
      return this.addChild(this._textSprite);
    }

    _updateTextPosition() {
      var nx, ny;
      if (!this._textSprite) {
        return;
      }
      nx = this._realWidth() / 2 - this._textSprite.width / 2;
      if (this._textPosition === 0) {
        ny = -this._textSprite.height;
      } else {
        ny = this._realHeight() + this._textSprite.height / 2;
      }
      return this._textSprite.move(nx, ny);
    }

    applyDisableState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[3]) != null ? ref.visible = true : void 0;
    }

    refreshEnDisState() {
      if (this.isDisabled()) {
        this.applyDisableState();
        return this._hideText();
      } else {
        if (this._mouseIn === false) {
          return this.applyNormalState();
        }
      }
    }

    //else
    //    do @applyCoverState
    updateComplexTextVisible() {}

    applyScale(mod) {
      var i, img, len, ref;
      ref = this._images;
      for (i = 0, len = ref.length; i < len; i++) {
        img = ref[i];
        if (img != null) {
          img.scale.x = mod;
          img.scale.y = mod;
        }
      }
    }

    static FromSet(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img0, img0);
      return button;
    }

    static FromSetFull(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1, img2, img3;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      img2 = getterFunc(imgName + "_02");
      img3 = getterFunc(imgName + "_03");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img2, img3);
      return button;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseCircle;
  //NUI 1.0
  //rev 28.04.24

    //"type": "circle"
  Sprite_BaseCircle = class Sprite_BaseCircle extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 100,
          r: 30
        },
        gradientEnd: {
          x: 100,
          y: 100,
          r: 70
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    isHaveGradient() {
      return false; //@settings.fillGradient?
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        }
      });
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        return this._drawBaseCircle();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var e;
      try {

      } catch (error) {
        /*{ width, height } = @settings
        c = document.createElement("canvas")
        ctx = c.getContext("2d")*/
        /*grd = ctx.createRadialGradient(
            @settings.gradientStart.x,
            @settings.gradientStart.y,
            @settings.gradientStart.r,
            @settings.gradientEnd.x,
            @settings.gradientEnd.y,
            @settings.gradientEnd.r
        )*/
        //grd = ctx.createRadialGradient(110, 90, 30, 100, 100, 70)
        /*for key, value of fillGradient
        try
            grd.addColorStop(Number(key), value)
        catch e
            KDCore.warning e*/
        /*grd.addColorStop(0, "pink")
        grd.addColorStop(0.9, "white")
        grd.addColorStop(1, "green")

        ctx.fillStyle = grd
        ctx.fillRect(0, 0, 400, 400)
        texture = new PIXI.Texture.from(c)
        @graphics.beginTextureFill(texture)*/
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawBaseCircle() {
      var colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawElipse(0, 0, width, height, colorData);
          // * Stroke
          return this._drawStroke(0, 0, width, height, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawElipse(0, 0, width, height, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawElipse(x, y, w, h, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        g.drawEllipse(x, y, w / 2, h / 2);
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        return g.drawEllipse(x, y, w / 2, h / 2);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        // * Круг (элипс) рисуется от центра, что не удобно
        // при расчёте координат, поэтому сдвигаем в левый вверхний угол
        this.graphics.x = this.settings.width * 0.5;
        return this.graphics.y = this.settings.height * 0.5;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseCircle = Sprite_BaseCircle;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseRect;
  //NUI 1.0
  //rev 28.04.24

    //"type": "rect"
  Sprite_BaseRect = class Sprite_BaseRect extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        corners: 0, // {  topLeft, topRight, bottomRight, bottomLeft }
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 0
        },
        gradientEnd: {
          x: 0,
          y: 100
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    defaultCornersSettings() {
      return {
        topLeft: 0,
        topRight: 0,
        bottomRight: 0,
        bottomLeft: 0
      };
    }

    isHaveGradient() {
      return this.settings.fillGradient != null;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        },
        gradientStart: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(v, this.settings.gradientEnd);
          }
        },
        gradientEnd: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(this.settings.gradientStart, v);
          }
        }
      });
    }

    setGradientStartEnd(start, end) {
      var e;
      try {
        if (start != null) {
          start.x = this._getValueByStr(start.x, 'width', this);
          start.y = this._getValueByStr(start.y, 'height', this);
        }
        if (end != null) {
          end.x = this._getValueByStr(end.x, 'width', this);
          end.y = this._getValueByStr(end.y, 'height', this);
        }
        if (start != null) {
          this.settings.gradientStart = start;
        }
        if (end != null) {
          this.settings.gradientEnd = end;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var cornersSettings, e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        if (typeof this.settings.corners === "number") {
          return this._drawBaseRoundedRect();
        } else if (this.settings.corners != null) {
          cornersSettings = Object.assign(this.defaultCornersSettings(), this.settings.corners);
          return this._drawComplexRoundedRect(cornersSettings);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var c, convertedValue, ctx, e, grd, height, key, texture, value, width;
      try {
        if (KDCore.isMV()) {
          return;
        }
        ({width, height} = this.settings);
        c = document.createElement("canvas");
        ctx = c.getContext("2d");
        grd = ctx.createLinearGradient(this.settings.gradientStart.x, this.settings.gradientStart.y, this.settings.gradientEnd.x, this.settings.gradientEnd.y);
        for (key in fillGradient) {
          value = fillGradient[key];
          try {
            convertedValue = this._convertGradientStopColor(value);
            grd.addColorStop(Number(key), convertedValue);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        texture = new PIXI.Texture.from(c);
        return this.graphics.beginTextureFill(texture);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _convertGradientStopColor(color) {
      var alpha, c, e, parts;
      try {
        if (color == null) {
          return "#FFF";
        }
        if (!String.any(color)) {
          return "#FFF";
        }
        if (color.contains("%")) {
          parts = color.split("%");
          color = parts[0];
          alpha = Number(parts[1]);
          c = KDCore.Color.FromHex(color);
          c = c.reAlpha(alpha * 255);
          return c.CSS;
        } else {
          return color;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "#FFF";
      }
    }

    _drawBaseRoundedRect() {
      var colorData, corners, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height, corners} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawRect(0, 0, width, height, corners, colorData);
          // * Stroke
          return this._drawStroke(-d / 2, -d / 2, width + d / 2, height + d / 2, corners, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawRect(0, 0, width, height, corners, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawRect(x, y, w, h, r, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        if (r > 0) {
          g.drawRoundedRect(x, y, w, h, r);
        } else {
          g.drawRect(x, y, w, h);
        }
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, r, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        if (r > 0) {
          return g.drawRoundedRect(x, y, w, h, r);
        } else {
          return g.drawRect(x, y, w, h);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRoundedRect(cornersSettings) {
      var bottomLeft, bottomRight, colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, topLeft, topRight, width;
      try {
        if (cornersSettings == null) {
          return;
        }
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        ({topLeft, topRight, bottomRight, bottomLeft} = cornersSettings);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
          return this._drawComplexStroke(-d / 2, -d / 2, width + (d / 2), height + (d / 2), strokeColorData, d, topLeft, topRight, bottomRight, bottomLeft);
        } else {
          return this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRect(x, y, width, height, colorData, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e;
      try {
        if (!this.isHaveGradient()) {
          this.graphics.beginFill(...colorData);
        }
        // Starting from the top left corner.
        this.graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        this.graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        this.graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        this.graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        this.graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        if (!this.isHaveGradient()) {
          return this.graphics.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexStroke(x, y, width, height, colorData, d, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e, graphics;
      try {
        graphics = this.graphics;
        graphics.lineStyle(d, ...colorData);
        // Starting from the top left corner.
        graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        return graphics.closePath();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        return this.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseRect = Sprite_BaseRect;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroup;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)

    //rev 07.10.21
  Sprite_ButtonsGroup = class Sprite_ButtonsGroup extends KDCore.Sprite {
    // buttonsArray = [
    //       {image: NAME, position: [X,Y]}, ...
    //    ]
    constructor(buttonsArray, activeIndex, clickCallback) {
      var button, i, len;
      super();
      this.clickCallback = clickCallback;
      this._buttons = [];
      for (i = 0, len = buttonsArray.length; i < len; i++) {
        button = buttonsArray[i];
        this._createButton(button);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroup.prototype;
    _._createButton = function({image, position}) {
      var btn, index, method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      index = this._buttons.length;
      btn = new KDCore.ButtonM(image, true, "Alpha");
      btn.move(position);
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this._buttons.push(btn);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroup = Sprite_ButtonsGroup;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroupHandler;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)
  // * В отличии от Sprite_ButtonsGroup, принимает массив
  // * уже созданных кнопок

    //rev 10.07.22
  Sprite_ButtonsGroupHandler = class Sprite_ButtonsGroupHandler extends KDCore.Sprite {
    // _buttons = [Button object with enable, disable, isEnable, addClickHandler methods]
    constructor(_buttons, clickCallback, activeIndex = 0) {
      var button, i, index, len, ref;
      super();
      this._buttons = _buttons;
      this.clickCallback = clickCallback;
      ref = this._buttons;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        button = ref[index];
        this._processButton(button, index);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroupHandler.prototype;
    _._processButton = function(btn, index) {
      var method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroupHandler = Sprite_ButtonsGroupHandler;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Gauge;
  //NUI 1.1
  //rev 16.06.24

    //"type": "gauge"
  Sprite_Gauge = class Sprite_Gauge extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._lastValue = 1;
      this._gaugeBaseLayer = new KDCore.Sprite();
      this.add(this._gaugeBaseLayer);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return {
        fillMode: "color", //image, plane, color
        fillColor: "#ffffff",
        fillOpacity: 255,
        imageName: "", // * for fill, if fillMode is image, for plane if fillMode is plane
        folderName: "pictures",
        margins: 2, // * For plane image
        width: "auto",
        height: "auto",
        mask: "",
        backColor: "#000000",
        backImage: "",
        backOpacity: 255,
        vertical: false
      };
    }

    isLoaded() {
      var e;
      try {
        return this._loaded === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width !== "auto") {
          return this.settings.width;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realWidth(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height !== "auto") {
          return this.settings.height;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realHeight(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        rate: function(v) {
          if (v != null) {
            return this.draw(v);
          }
        },
        fillImage: function(v) {
          if (v != null) {
            return this.setFillImage(v);
          }
        },
        fillColor: function(v) {
          if (v != null) {
            return this.setFillColor(v);
          }
        },
        fillOpacity: function(v) {
          if (v != null) {
            return this.setFillOpacity(v);
          }
        }
      });
    }

    //TODO:!
    //backImage: (v) ->
    //backColor: (v) ->
    //backOpacity: (v) ->
    draw(percent = 1) {
      var e;
      try {
        if (!this.isLoaded()) {
          this._requireFunc('draw', arguments);
          return;
        }
        this._lastValue = percent;
        return this._drawGauge(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillOpacity(opacity) {
      var e, ref;
      try {
        this.settings.fillOpacity = opacity;
        return (ref = this.fillLayer) != null ? ref.opacity = opacity : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillColor(color) {
      var e;
      try {
        this.settings.fillColor = color;
        if (this.fillColorBitmap != null) {
          this._createColorGaugeFillColorBitmap();
          return this._drawGauge(this._lastValue);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillImage(imageName) {
      var e;
      try {

      } catch (error) {
        //TODO:
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e;
      try {
        this._loaded = false;
        this._destroyExistGauge();
        this._createGaugeFromSettings();
        return this.draw(this._lastValue);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyExistGauge() {
      var e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        this._gaugeSpr.removeFromParent();
        return this._gaugeSpr = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createGaugeFromSettings() {
      var e;
      try {
        this._gaugeSpr = new KDCore.Sprite();
        this._gaugeBaseLayer.add(this._gaugeSpr);
        switch (this.settings.fillMode) {
          case "image":
            return this._createImageGauge();
          case "plane":
            return this._createPlaneGauge();
          case "color":
            return this._createColorGauge();
          default:
            return console.warn("Unknown Gauge fillMode: " + this.settings.fillMode);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createImageGauge() {
      var e;
      try {
        this._gaugeSourceImage = new KDCore.Sprite_Image({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        return this._gaugeSourceImage.addLoadListener(this._onGaugeFillImageLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeFillImageLoaded() {
      var e;
      try {
        this._addBackground(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer = KDCore.Sprite.FromBitmap(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeLoadedAndReady() {
      var e;
      try {
        this._loaded = true;
        this.width = this.realWidth();
        this.height = this.realHeight();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createPlaneGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать Plane Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height,
          margins: this.settings.margins
        });
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать цветную Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = KDCore.Sprite.FromBitmap(this.settings.width, this.settings.height);
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._createColorGaugeFillColorBitmap();
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGaugeFillColorBitmap() {
      var e;
      try {
        this.fillColorBitmap = new Bitmap(this.settings.width, this.settings.height);
        return this.fillColorBitmap.fillAll(this.settings.fillColor);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addBackground(width, height) {
      var background, e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        background = null;
        if (String.any(this.settings.backImage)) {
          background = this._createGaugeBackgroundImage();
        } else if (String.any(this.settings.backColor)) {
          background = this._createGaugeBackgroundColor(width, height, this.settings.backColor);
        }
        if (background != null) {
          if (this.settings.backOpacity != null) {
            background.opacity = this.settings.backOpacity;
          }
          return this._gaugeSpr.add(background);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addMask() {
      var e, gaugeMask;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        if (String.isNullOrEmpty(this.settings.mask)) {
          return;
        }
        gaugeMask = new KDCore.Sprite_Image({
          imageName: this.settings.mask,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        this._gaugeSpr.mask = gaugeMask.image;
        this._gaugeSpr.add(gaugeMask);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this._gaugeSpr.mask = null;
      }
    }

    _createGaugeBackgroundColor(width, height, color) {
      var background, e;
      try {
        background = KDCore.Sprite.FromBitmap(width, height);
        background.b().fillAll(color);
        return background;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _createGaugeBackgroundImage() {
      var e;
      try {
        return new KDCore.Sprite_Image({
          imageName: this.settings.backImage,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _drawGauge(percent) {
      var e;
      try {
        if (this.fillLayer == null) {
          return;
        }
        // * See COE, Fill Indicator
        //if @settings.vertical is true
        //TODO: VERTICAL
        //else
        return this._drawHorizontal(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawHorizontal(percent) {
      var e;
      try {
        switch (this.settings.fillMode) {
          case "image":
            return this._drawImageGauge(percent);
          case "plane":
            return this._drawPlaneGauge(percent);
          case "color":
            return this._drawColorGauge(percent);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImageGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this._gaugeSourceImage.image.bitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawGaugeBitmapBased(percent, fillBitmap) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.b().blt(fillBitmap, 0, 0, w, h, 0, 0);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawColorGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this.fillColorBitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawPlaneGauge(percent) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.setSize(w, h);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Gauge = Sprite_Gauge;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Group;
  //NUI 1.0
  //rev 30.04.24
  Sprite_Group = class Sprite_Group extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      if (this.settings.horizontalNavigation === true) {
        this.pIsVerticalKeyboardNavigation = function() {
          return false;
        };
      }
      this._applySettings();
      this._onResize();
      return;
    }

    update() {
      var e;
      super.update();
      try {
        if (this._isNeedWaitLoadingChild === true) {
          //console.log("REFRESH BY LOAD")
          return this.refreshBindings(this._dataObjectRef, true);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    refreshBindings(dataObject, recursive) {
      var c, i, len, ref;
      super.refreshBindings(...arguments);
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if ((c.isLoaded != null) && !c.isLoaded()) {
          this._startWaitLoading(dataObject);
          return;
        }
      }
      this._isNeedWaitLoadingChild = false;
    }

    _startWaitLoading(_dataObjectRef) {
      var e;
      this._dataObjectRef = _dataObjectRef;
      try {
        return this._isNeedWaitLoadingChild = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    defaultSettings() {
      return {
        keyboardHandling: false,
        horizontalNavigation: false,
        width: "auto",
        height: "auto"
      };
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          return this._calculateMax("x", "width");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          return this._calculateMax("y", "height");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    _calculateMax(a, b) {
      var child, e, i, len, ref, size, value;
      try {
        value = 0;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          size = child[a] + KDCore.Utils.getRealSpriteSize(b, child);
          if (size > value) {
            value = size;
          }
        }
        if (value < 0) {
          value = 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
      return value;
    }

    _applySettings() {
      var e;
      try {
        if (this.settings.keyboardHandling === true) {
          return this.activateHandlerManagment();
        } else {
          return this.deactivateHandlerManagment();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Group = Sprite_Group;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Image;
  //NUI 1.0
  //rev 29.04.24

    //"type": "image"
  Sprite_Image = class Sprite_Image extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._create();
      this._onResize();
      this.draw(this.settings.imageName);
      return;
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultSettings() {
      return {
        imageName: "",
        folderName: "pictures",
        width: "auto",
        height: "auto",
        keepAspect: false
      };
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.width;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.width;
            }
          }
        } else {
          return this.settings.width;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.height;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.height;
            }
          }
        } else {
          return this.settings.height;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.draw(v);
        },
        icon: function(v) {
          return this.drawIcon(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName, folderName = null) {
      var e;
      try {
        if (String.any(folderName)) {
          this.settings.folderName = folderName;
        }
        return this.draw(imageName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Если не иконка (число), то ничего не рисует (защита)
    drawIcon(iconIndex) {
      var e;
      try {
        if (isFinite(iconIndex)) {
          return this.draw(iconIndex);
        } else {
          return this.draw("");
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    draw(imageName = "") {
      var e;
      try {
        if (isFinite(imageName)) {
          return this._drawIcon(imageName);
        } else if (String.any(imageName)) {
          return this._drawImage(imageName);
        } else {
          this._srcBitmap = null;
          return this._onResize();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.image = new KDCore.Sprite(new Bitmap(1, 1));
        return this.addChild(this.image);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawIcon(iconIndex) {
      var e, w;
      try {
        w = this.settings.width;
        if (w === "auto") {
          w = 32;
        }
        this.settings.height = w;
        this._srcBitmap = new Bitmap(w, w);
        this._srcBitmap.drawIcon(0, 0, iconIndex, w, true);
        this._loaded = true;
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImage(imageName) {
      var e, folderName;
      try {
        ({folderName} = this.settings);
        this._loaded = false;
        this._srcBitmap = ImageManager.loadBitmap('img/' + folderName + "/", imageName);
        return this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onBitmapLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var b, e, fh, fw, height, width;
      try {
        this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
        if (this._srcBitmap == null) {
          return;
        }
        b = this._srcBitmap;
        if (this.settings.keepAspect === true) {
          ({width, height} = this._calculateAspectRatio(this.image.bitmap.width, this.image.bitmap.height, this._srcBitmap.width, this._srcBitmap.height));
          fw = width;
          fh = height;
        } else {
          fw = this.realWidth();
          fh = this.realHeight();
        }
        return this.image.bitmap.blt(b, 0, 0, b.width, b.height, 0, 0, fw, fh);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _calculateAspectRatio(containerWidth, containerHeight, width, height) {
      var aspectRatio, containerAspectRatio, e;
      try {
        aspectRatio = width / height;
        containerAspectRatio = containerWidth / containerHeight;
        if (aspectRatio > containerAspectRatio) {
          width = containerWidth;
          height = width / aspectRatio;
        } else {
          height = containerHeight;
          width = height * aspectRatio;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return {width, height};
    }

  };
  return KDCore.Sprite_Image = Sprite_Image;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ImgButton;
  //NUI 1.0
  //rev 25.04.24

    //"type": "legacyButton"
  Sprite_ImgButton = class Sprite_ImgButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      return;
    }

    defaultSettings() {
      return {
        width: "auto",
        height: "auto",
        imageName: "",
        isFull: false,
        folderName: "pictures",
        isCheckAlpha: false,
        handler: null
      };
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          return this.button.realWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          return this.button.realHeight();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.setImage(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName = "") {
      var e;
      try {
        if (this.button != null) {
          this._lastButtonState = this.button.isEnabled();
          this._lastButtonHandler = this.button._handler;
        }
        this.settings.imageName = imageName;
        this._create();
        // * Может не быть кнопки, если imageName == ""
        if (this.button == null) {
          return;
        }
        if (this._lastButtonState != null) {
          this.setEnabledState(this._lastButtonState);
          this._lastButtonState = null;
        }
        if (this._lastButtonHandler != null) {
          this.setClickHandler(this._lastButtonHandler);
          return this._lastButtonHandler = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setEnabledState(state = true) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        if (state === true) {
          return this.button.enable();
        } else {
          return this.button.disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * В отличии от AddClickHandler, удаляет все предидущие
    setClickHandler(handler) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.clearClickHandler();
        if ((handler != null) && typeof handler === "function") {
          return this.button.addClickHandler(handler);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * EXPAND FIELDS
    click() {
      var ref;
      return (ref = this.button) != null ? ref.click() : void 0;
    }

    setManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.setManualHover() : void 0;
    }

    disableManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.disableManualHover() : void 0;
    }

    setManualSelected() {
      var ref;
      return (ref = this.button) != null ? ref.setManualSelected(...arguments) : void 0;
    }

    enableClick() {
      var ref;
      return (ref = this.button) != null ? ref.enableClick() : void 0;
    }

    disableClick() {
      var ref;
      return (ref = this.button) != null ? ref.disableClick() : void 0;
    }

    desaturate() {
      var ref;
      return (ref = this.button) != null ? ref.desaturate() : void 0;
    }

    isMouseIn() {
      return (this.button != null) && this.button.isMouseIn();
    }

    isActive() {
      return (this.button != null) && this.button.isActive();
    }

    isDisabled() {
      return this.isEnabled();
    }

    isEnabled() {
      return (this.button != null) && this.button.isEnabled();
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    clearClickHandler() {
      var ref;
      return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
    }

    simulateClick() {
      var ref;
      return (ref = this.button) != null ? ref.simulateClick() : void 0;
    }

    refreshState() {
      var ref;
      return (ref = this.button) != null ? ref.refreshState(...arguments) : void 0;
    }

    disable() {
      var ref;
      return (ref = this.button) != null ? ref.disable() : void 0;
    }

    enable() {
      var ref;
      return (ref = this.button) != null ? ref.disable() : void 0;
    }

    // * ==============
    _create() {
      var e;
      try {
        this._loaded = false;
        if (this.button != null) {
          this._destroyButton();
        }
        if (!String.any(this.settings.imageName)) {
          return;
        }
        this.button = new KDCore.ButtonM(this.settings.imageName, this.settings.isFull, this.settings.folderName);
        if (this.settings.isCheckAlpha === true) {
          this.button.isCheckAlpha = function() {
            return true;
          };
        }
        if (this.settings.handler != null) {
          this.setClickHandler(this.settings.handler);
        }
        this.button.addLoadListener(this._onLoaded.bind(this));
        return this.addChild(this.button);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyButton() {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.removeFromParent();
        this._loaded = false;
        if ($gameTemp.kdButtonUnderMouse === this.button) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ImgButton = Sprite_ImgButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsList;
  // * Класс который позволяет сделать список (на основе Window_Selectable), но из Sprite элементов, а не Draw на Bitmap

    //rev 02.05.24

    //TODO: Dynamic items height, controls handlers support
  Sprite_ItemsList = class Sprite_ItemsList extends Window_Selectable {
    constructor(r, settings = {}) {
      if (KDCore.isMV()) {
        super(r.x, r.y, r.width, r.height);
      } else {
        super(r);
      }
      this.settings = Object.assign(this.defaultSetting(), settings);
      this.padding = this.settings.itemsPadding;
      this._prevSelectedIndex = -1;
      this._createItemsContainer();
      this._createWindowContentMask();
      this._setupBackgroundType();
      return;
    }

    defaultSetting() {
      return {
        maxCols: 1,
        isHaveSelectionEffect: false,
        selectionEffects: ["glow;distance:12;outerStrength:3"],
        scaleItemsWidth: false,
        scaleItemsHeight: false,
        defautItemHeight: 36,
        isDrawDefaultItemBack: false,
        backgroundType: 2,
        itemsPadding: 12,
        isHaveInOutAnimation: false,
        inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
        outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
      };
    }

    activate(index) {
      var e;
      try {
        this.refresh();
        if (index != null) {
          this.safeSelect(index);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.activate();
    }

    maxItems() {
      return this.getAllItems().length;
    }

    maxCols() {
      if (this.settings != null) {
        return this.settings.maxCols || 1;
      } else {
        return 1;
      }
    }

    getAllItems() {
      return this.itemsSet || [];
    }

    setItems(itemsSet, singleItemHeight = null) {
      this.itemsSet = itemsSet;
      this.singleItemHeight = singleItemHeight;
      this._prevSelectedIndex = -1;
      this.setTopRow(0);
      this._clearPreviousItems();
      if (this.singleItemHeight == null) {
        this._adjustAutoItemsHeight(this.itemsSet[0]);
      }
      this.refresh();
      this._drawNewItems();
    }

    selectedItem() {
      return this.itemAt(this.index());
    }

    setOkHandler(handler) {
      return this.setHandler('ok', handler);
    }

    setCancelHandler(handler) {
      return this.setHandler('cancel', handler);
    }

    setSelectionHandler(handler) {
      return this.pOnSelectionChanged = handler;
    }

    itemAt(index) {
      return this.getAllItems()[index];
    }

    isNeedScaleItemsW() {
      return this.settings.scaleItemsWidth === true;
    }

    isNeedScaleItemsH() {
      return this.settings.scaleItemsHeight === true;
    }

    // * NOT WORKS!!!
    isUseDynamicHeight() {
      return false;
    }

    lineHeight(index) {
      if (this.settings != null) {
        return this.singleItemHeight || this.settings.defautItemHeight;
      } else {
        return this.singleItemHeight || 36;
      }
    }

    isDrawWindowDefaultItemsBack() {
      return this.settings.isDrawDefaultItemBack === true;
    }

    //$[OVER]
    _updateCursor() {
      if (KDCore.isMV()) {
        return this.setCursorRect(0, 0, 0, 0);
      } else {
        return this._cursorSprite.visible = false;
      }
    }

    update() {
      super.update();
      this._itemsContainer.y = -this._scrollY;
      return this._updateItemsSelectionState();
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ItemsList.prototype;
    _._createItemsContainer = function() {
      var ref;
      if (!this.isDrawWindowDefaultItemsBack()) {
        if ((ref = this._contentsBackSprite) != null) {
          ref.visible = false;
        }
      }
      this._windowItemsContentLayer = new Sprite();
      this._windowItemsContentLayer.move(this._padding, this._padding);
      this.addChild(this._windowItemsContentLayer);
      this._itemsContainer = new KDCore.Sprite();
      this._windowItemsContentLayer.addChild(this._itemsContainer);
      this.addChild(this._downArrowSprite);
      return this.addChild(this._upArrowSprite);
    };
    _._setupBackgroundType = function() {
      return this.setBackgroundType(this.settings.backgroundType);
    };
    _._createWindowContentMask = function() {
      var e, m, maskBitmap;
      try {
        maskBitmap = new Bitmap(this.width - this._padding * 2, this.height - this._padding * 2);
        maskBitmap.fillAll("#FFF");
        m = new Sprite(maskBitmap);
        this._windowItemsContentLayer.mask = m;
        return this._windowItemsContentLayer.addChild(m);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustAutoItemsHeight = function(item) {
      var e;
      try {
        if (item == null) {
          this.singleItemHeight = 36;
          return;
        }
        if (item.realHeight != null) {
          this.singleItemHeight = item.realHeight();
        } else {
          if (item.height > 0) {
            this.singleItemHeight = item.height;
          }
        }
        if (this.singleItemHeight === 0 || !this.singleItemHeight) {
          return this.singleItemHeight = 36;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._clearPreviousItems = function() {
      var c, e, i, j, len, len1, ref, results, toRemove;
      try {
        toRemove = [];
        ref = this._itemsContainer.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          toRemove.push(c);
        }
        results = [];
        for (j = 0, len1 = toRemove.length; j < len1; j++) {
          c = toRemove[j];
          results.push(c.removeFromParent());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._drawNewItems = function() {
      var e, i, index, item, len, ref, results;
      try {
        ref = this.getAllItems();
        results = [];
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          results.push(this._addNewItemToList(item, index));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._addNewItemToList = function(item, index) {
      var e, rect;
      try {
        if (item == null) {
          return;
        }
        rect = this.itemRect(index);
        item.x = rect.x;
        item.y = rect.y;
        this._adjustItemWidthAndHeight(item);
        return this._itemsContainer.addChild(item);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustItemWidthAndHeight = function(item) {
      var e, scaleFactor;
      try {
        if (item == null) {
          return;
        }
        if (this.isNeedScaleItemsW()) {
          scaleFactor = this._defaultItemWidth() / this._getItemWidth(item);
          item.scale.x = scaleFactor;
        }
        if (this.isNeedScaleItemsH()) {
          scaleFactor = this.lineHeight() / this._getItemHeight(item);
          return item.scale.y = scaleFactor;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getItemWidth = function(item) {
      var e, v;
      v = this._defaultItemWidth();
      try {
        if (item == null) {
          return v;
        }
        if (item.realWidth != null) {
          v = item.realWidth();
        } else {
          if (item.width > 0) {
            v = item.width;
          }
        }
        if (v === 0 || !v) {
          v = this._defaultItemWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._defaultItemWidth = function() {
      return this.width - this._padding * 2;
    };
    _._getItemHeight = function(item) {
      var e, v;
      v = 36;
      try {
        if (item == null) {
          return v;
        }
        if (item.realHeight != null) {
          v = item.realHeight();
        } else {
          if (item.height > 0) {
            v = item.height;
          }
        }
        if (v === 0 || !v) {
          v = 36;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._updateItemsSelectionState = function() {
      var e;
      try {
        if (KDCore.isMZ()) {
          if (!this.active || this.index() < 0 || !this.cursorVisible) {
            this._disableSelectionForAll();
            return;
          }
        } else {
          if (!this.active || this.index() < 0 || !this.isCursorVisible()) {
            this._disableSelectionForAll();
            return;
          }
        }
        return this._selectItemAtIndex(this.index());
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._disableSelectionForAll = function() {
      var e, i, item, len, ref, results;
      try {
        if (this._prevSelectedIndex === -2) {
          return;
        }
        this._prevSelectedIndex = -2;
        ref = this.getAllItems();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(this._deselectItem(item));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if ((this._prevSelectedIndex != null) && this._prevSelectedIndex >= 0) {
          this._deselectItem(this.itemAt(this._prevSelectedIndex));
        }
        this._playItemInAnimation(item);
        if (item.activateInList != null) {
          return item.activateInList();
        } else {
          return this._selectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemInAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (this.settings.inAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.inAnimation);
        return this._isHaveInAnimation = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (!this.settings.isHaveSelectionEffect) {
          return;
        }
        //item.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 4 })]
        if (this.settings.selectionEffects == null) {
          return;
        }
        if (this.settings.selectionEffects.length === 0) {
          return;
        }
        KDCore.UI.Builder.ApplyEffects(item, this.settings.selectionEffects);
        return this._isSelectionEffectBeenAdded = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        this._playItemOutAnimation(item);
        if (item.deactivateInList != null) {
          return item.deactivateInList();
        } else {
          return this._deselectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemOutAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (!this._isHaveInAnimation) {
          return;
        }
        if (this.settings.outAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.outAnimation);
        return this._isHaveInAnimation = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemAnimation = function(item, animation) {
      var e, root;
      try {
        if (item == null) {
          return;
        }
        root = item.children[0];
        if (root == null) {
          return;
        }
        if (typeof animation === "string") {
          animation = KDCore.UI.Builder.ConvertShortcut(animation);
        }
        return root.setAnimationRule(animation);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (this._isSelectionEffectBeenAdded === true) {
          item.filters = [];
          return this._isSelectionEffectBeenAdded = false;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemAtIndex = function(index) {
      var e, item;
      try {
        if (this._prevSelectedIndex !== index) {
          item = this.itemAt(index);
          if (item == null) {
            return;
          }
          this._selectItem(item);
          return this._prevSelectedIndex = index;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ItemsList = Sprite_ItemsList;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListN;
  //NUI 1.0
  //rev 03.05.24

    //type: "list"
  // * Этот класс служит только как Wrapper, чтобы можно было задавать настроки List через NUI схему
  Sprite_ItemsListN = class Sprite_ItemsListN extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign(this.defaultSettings(), settings);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return Object.assign({
        width: 240,
        height: 420
      }, KDCore.Sprite_ItemsList.prototype.defaultSetting());
    }

    /* (See parent class, this is just for reference)
           defaultSetting: -> {
               maxCols: 1,
               isHaveSelectionEffect: false,
               selectionEffects: ["glow;distance:12;outerStrength:3"],
               scaleItemsWidth: false,
               scaleItemsHeight: false,
               defautItemHeight: 36,
               isDrawDefaultItemBack: false,
               backgroundType: 2,
               itemsPadding: 12,
               isHaveInOutAnimation: false,
               inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
               outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
           }*/
    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        maxCols: function(v) {
          if (v != null) {
            return this.setMaxCols(v);
          }
        }
      });
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    setSize(width, height) {
      var e;
      try {
        width = this._getValueByStr(width, 'width', this);
        height = this._getValueByStr(height, 'height', this);
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setMaxCols(maxCols) {
      var e;
      try {
        this.settings.maxCols = maxCols;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    clear() {
      var ref;
      return (ref = this.list) != null ? ref.setItems([]) : void 0;
    }

    // * WRAPPED
    setItems() {
      var ref;
      return (ref = this.list) != null ? ref.setItems(...arguments) : void 0;
    }

    activate() {
      var ref;
      return (ref = this.list) != null ? ref.activate(...arguments) : void 0;
    }

    deactivate() {
      var ref;
      return (ref = this.list) != null ? ref.deactivate(...arguments) : void 0;
    }

    setOkHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setOkHandler(...arguments) : void 0;
    }

    setCancelHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setCancelHandler(...arguments) : void 0;
    }

    setSelectionHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setSelectionHandler(...arguments) : void 0;
    }

    refresh() {
      var ref;
      return (ref = this.list) != null ? ref.refresh(...arguments) : void 0;
    }

    selectedItem() {
      var ref;
      return (ref = this.list) != null ? ref.selectedItem() : void 0;
    }

    itemAt() {
      var ref;
      return (ref = this.list) != null ? ref.itemAt(...arguments) : void 0;
    }

    maxItems() {
      var ref;
      return (ref = this.list) != null ? ref.maxItems() : void 0;
    }

    getAllItems() {
      var ref;
      return (ref = this.list) != null ? ref.getAllItems() : void 0;
    }

    maxCols() {
      var ref;
      return (ref = this.list) != null ? ref.maxCols() : void 0;
    }

    // * END WRAPPED

      // * Dev, (not use settings) , чтобы визуально видеть размеры окна при подгонке
    setBackgroundType() {
      var ref;
      return (ref = this.list) != null ? ref.setBackgroundType(...arguments) : void 0;
    }

    // * Shortcut
    showBack() {
      return this.setBackgroundType(0);
    }

    _applySettings() {
      var e;
      try {
        this._destroyList();
        this._createListWithSettings(this.settings);
        if (this._isHaveStoredData === true) {
          return this._restoreData();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyList() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        this._isHaveStoredData = true;
        this._lastItems = this.list.getAllItems();
        this._isBeenActive = this.list.active === true;
        this._lastSelectedIndex = this.list.index();
        this._lastHandlers = this.list._handlers;
        this.removeChild(this.list);
        return this.list = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createListWithSettings(settings) {
      var e;
      try {
        this.list = new KDCore.Sprite_ItemsList({
          x: 0,
          y: 0,
          width: settings.width,
          height: settings.height
        }, settings);
        return this.addChild(this.list);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _restoreData() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        if (this._lastHandlers != null) {
          this.list._handlers = this._lastHandlers;
        }
        if (this._lastItems == null) {
          return;
        }
        this.list.setItems(this._lastItems);
        if (this._lastSelectedIndex != null) {
          this.list.safeSelect(this._lastSelectedIndex);
        }
        if (this._isBeenActive === true) {
          this.list.activate();
        }
        return this._isHaveStoredData = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ItemsListN = Sprite_ItemsListN;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_NUI;
  //NUI 1.0
  //rev 06.05.24
  Sprite_NUI = class Sprite_NUI extends KDCore.Sprite {
    constructor(nuiScheme, owner = null) {
      super();
      this.nuiScheme = nuiScheme;
      if (this.nuiScheme != null) {
        this.loadNuiScheme(this.nuiScheme, owner);
      }
      return;
    }

    // * DIRECT nuiElement,без Sprite_NUI (надо присоединять к OWNER)
    static FromScheme(scheme, owner) {
      var e, spr;
      try {
        spr = new Sprite_NUI(scheme, owner);
        if (owner != null) {
          owner.addChild(spr.nuiElement);
        }
        return spr.nuiElement;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite_NUI();
      }
    }

    _afterLoadNuiAutoRefreshTime() {
      return 100;
    }

    loadNuiScheme(scheme, owner = null) {
      var e;
      try {
        if (this.nuiElement != null) {
          this.destroyNuiElement();
        }
        if (scheme == null) {
          return;
        }
        if (owner == null) {
          owner = this;
        }
        if (scheme["type"] != null) {
          this.nuiElement = KDCore.UI.Builder.Make(scheme, owner, this);
        } else {
          this.nuiElement = KDCore.UI.Builder.Factory(scheme, owner, this._afterLoadNuiAutoRefreshTime())[0];
        }
        this.addChild(this.nuiElement);
        return this.refreshBindings(owner, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    destroyNuiElement() {
      var e;
      try {
        if (this.nuiElement == null) {
          return;
        }
        this.nuiElement.removeFromParent();
        return this.nuiElement = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_NUI = Sprite_NUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Plane;
  //NUI 1.0
  //rev 25.04.24

    //type: "plane"
  Sprite_Plane = class Sprite_Plane extends KDCore.Sprite {
    constructor(settings) {
      var bottom, folderName, imageName, left, margins, right, textureSource, top;
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this.plane = null;
      this.planeContainer = new KDCore.Sprite();
      this.addChild(this.planeContainer);
      ({imageName, margins, folderName} = this.settings);
      if (isFinite(margins)) {
        left = top = right = bottom = margins;
      } else {
        ({left, top, right, bottom} = margins);
      }
      textureSource = ImageManager.loadBitmap('img/' + folderName + '/', imageName);
      textureSource.addLoadListener(() => {
        var texture;
        texture = new PIXI.Texture(textureSource._baseTexture);
        if (KDCore.isMV()) {
          this.plane = new PIXI.mesh.NineSlicePlane(texture, left, top, right, bottom);
        } else {
          this.plane = new PIXI.NineSlicePlane(texture, left, top, right, bottom);
        }
        this.planeContainer.addChild(this.plane);
        return this._onResize();
      });
      this._onResize();
      return;
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    defaultSettings() {
      return {
        imageName: "",
        width: 100,
        height: 100,
        margins: 20,
        folderName: "pictures"
      };
    }

    setSize(w = 100, h = 100) {
      var e;
      try {
        w = this._getValueByStr(w, 'width', this);
        h = this._getValueByStr(h, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.plane.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.plane.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        if (this.plane == null) {
          return;
        }
        this.plane.width = this.settings.width;
        return this.plane.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Plane = Sprite_Plane;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_SButton;
  //NUI 1.0
  //rev 30.04.24
  //"type": "button"
  Sprite_SButton = class Sprite_SButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._isEnabled = true;
      this._isUnderMouse = false;
      this._isPressActive = false;
      this._isMouseOver = false;
      this._create();
      this._refreshSettings();
      return;
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    isDisabled() {
      return !this.isEnabled();
    }

    isEnabled() {
      return this._isEnabled === true;
    }

    _enable() {
      var e;
      try {
        if (this._desaturated === true) {
          this.filters = [];
          this._desaturated = false;
        }
        if ((this.settings.disabledTint != null) && this._isEnabled === false) { // * Return to normal Tint
          this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        }
        this._isEnabled = true;
        return this._refreshTint();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _disable() {
      var e;
      try {
        this._applyDisabledEffect();
        return this._isEnabled = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyDisabledEffect() {
      var e;
      try {
        if (this.settings.desaturateWhenDisabled === true) {
          return this.desaturate();
        } else if (this.settings.disabledTint != null) {
          return this.applyTint(this.settings.disabledTint, this.settings.disabledTintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    isActive() {
      return this._isEnabled === true && this.visible === true && this.opacity !== 0;
    }

    pIsSupportKeyboardHandle() {
      return this.settings.keyboardHandled === true;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
      this._desaturated = true;
    }

    defaultSettings() {
      return {
        imageName: '',
        folderName: 'pictures',
        imageMargins: 20,
        width: 160,
        height: 60,
        clickSe: "Cursor1",
        desaturateWhenDisabled: false,
        tint: "",
        overTint: 0xFFFFDD,
        activeTint: 0xAAAAAA,
        tintAlpha: 0.5,
        disabledTint: 0xAAAAAA,
        disabledTintAlpha: 0.5,
        keyboardKey: "",
        keyboardHandled: true,
        enabled: true
      };
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        style: function(v) {
          if (v != null) {
            return this.updateStyle(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        }
      });
    }

    setEnabledState(state = true) {
      var e;
      try {
        this.settings.enabled = state;
        if (state === true) {
          return this._enable();
        } else {
          return this._disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    enable() {
      return this.setEnabledState(true);
    }

    disable() {
      return this.setEnabledState(false);
    }

    updateStyle(style) {
      var e;
      try {
        this.settings = Object.assign(this.settings, style);
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    setClickHandler(handler = null) {
      var e;
      try {
        this.settings.onClick = null;
        if ((handler != null) && typeof handler === 'function') {
          return this.settings.onClick = handler;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 160, height = 60) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    executeAction() {
      var e;
      try {
        KDCore.Utils.playSE(this.settings.clickSe);
        if (this.settings.onClick != null) {
          return this.settings.onClick();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onTap() {
      var e;
      try {
        return this.executeAction();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //console.log("TAP")
    _onOver() {
      this._isMouseOver = true;
      return this._refreshSettings();
    }

    //console.log("OVER")
    _onOut() {
      this._isMouseOver = false;
      return this._refreshSettings();
    }

    //console.log("OUT")
    _onDown() {
      this._isPressActive = true;
      return this._refreshSettings();
    }

    //console.log("DOWN")
    _onUp() {
      this._isPressActive = false;
      return this._refreshSettings();
    }

    //console.log("UP")
    _create() {
      var e, height, width;
      try {
        this.buttonPlane = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          margins: this.settings.imageMargins,
          folderName: this.settings.folderName
        });
        ({width, height} = this.settings);
        this.buttonPlane.setSize(width, height);
        return this.addChild(this.buttonPlane);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshSettings() {
      var e;
      try {
        this._refreshTint();
        if (this.settings.keyboardHandled === true) {
          this.handleOKAction = this._onTap;
        } else {
          this.handleOKAction = null;
        }
        this.setEnabledState(this.settings.enabled);
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshTint() {
      var e;
      try {
        if (this._isPressActive === true) {
          return this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        } else if (this._isMouseOver === true) {
          return this.applyTint(this.settings.overTint, this.settings.tintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    applyTint(tintValue, tintAlpha = 0.5) {
      var e;
      try {
        if (tintValue == null) {
          this._resetTintFilter();
          return;
        }
        if (typeof tintValue === "string") {
          if (!String.any(tintValue)) {
            this._resetTintFilter();
            return;
          }
          tintValue = KDCore.Utils.string2hex(tintValue);
        }
        return this.buttonPlane.filters = [new PIXI.filters.ColorOverlayFilter(tintValue, tintAlpha)];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _resetTintFilter() {
      var e;
      try {
        return this.buttonPlane.filters = [];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _activateHandlerVisually() {
      var e;
      try {
        return this.applyTint(this.settings.overTint);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    pDeactivateHandler() {
      super.pDeactivateHandler();
      return this.applyTint(this.settings.tint);
    }

    update() {
      super.update();
      if (this.isActive()) {
        this._updateKeyboardHandling();
        this._updateMouseHandling();
      } else {
        if (this._isUnderMouse === true) {
          this._onOut();
        }
        if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    }

    _updateKeyboardHandling() {
      var e;
      try {
        if (String.any(this.settings.keyboardKey)) {
          if (Input.isTriggered(this.settings.keyboardKey)) {
            Input.clear();
            return this._onTap();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateMouseHandling() {
      var e;
      try {
        if (this.isUnderMouse()) {
          if (!this._isUnderMouse) {
            this._onOver();
            $gameTemp.kdButtonUnderMouse = this;
            try {
              if ($gameTemp.__pkdActiveKeyboardHandler != null) {
                $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
            this._isUnderMouse = true;
          }
        } else {
          if (this._isUnderMouse === true) {
            this._onOut();
            if ($gameTemp.kdButtonUnderMouse === this) {
              $gameTemp.kdButtonUnderMouse = null;
            }
            this._isUnderMouse = false;
          }
        }
        if (TouchInput.isPressed()) {
          if (this._isUnderMouse === true) {
            if (!this._isMousePressed) {
              this._onDown();
              this._isMousePressed = true;
            }
          }
        }
        if (TouchInput.isReleased()) {
          if (this._isMousePressed === true) {
            this._onUp();
            if (this._isUnderMouse === true) {
              this._onTap();
            }
            return this._isMousePressed = false;
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e, ref;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        return (ref = this.buttonPlane) != null ? ref.setSize(this.width, this.height) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_SButton = Sprite_SButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad((function() {
  var Sprite_TilingFrame;
  Sprite_TilingFrame = class Sprite_TilingFrame extends KDCore.Sprite {
    constructor(width, height, skinBitmap) {
      super();
      this.width = width;
      this.height = height;
      this.skinBitmap = skinBitmap;
      this._createParts();
      this._refreshAll();
    }

    _createParts() {
      var i, j;
      this.backSprite = new Sprite();
      this.addChild(this.backSprite);
      this.content = new Sprite();
      this.addChild(this.content);
      this._outFrame = new Sprite();
      for (i = j = 0; j < 8; i = ++j) {
        this._outFrame.addChild(new Sprite());
      }
      return this.addChild(this._outFrame);
    }

    // * Отступ, чтобы за рамку не выходить
    _fillPadding() {
      return 2;
    }

    // * Размер частей на картинке
    _fillImagePartWidth() {
      return 96;
    }

    _fillImagePartHeight() {
      return 96;
    }

    // * Толщина рамки
    _frameThickness() {
      return 12;
    }

    _refreshAll() {
      this._refreshBack();
      return this._refreshTFrame();
    }

    _refreshBack() {
      var fh, fw, h, m, sprite, w;
      m = this._fillPadding();
      w = Math.max(0, this.width - m * 2);
      h = Math.max(0, this.height - m * 2);
      sprite = this.backSprite;
      sprite.bitmap = this.skinBitmap;
      // * Координаты фона из картинки
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      sprite.setFrame(0, 0, fw, fh);
      sprite.move(m, m);
      sprite.scale.x = w / fw;
      return sprite.scale.y = h / fh;
    }

    _refreshTFrame() {
      var drect, fh, fw, j, len, m, ref, spr, srect;
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      // * Положение назначения
      drect = {
        x: 0,
        y: 0,
        width: this.width,
        height: this.height
      };
      // * Координаты рамки на картинке
      srect = {
        x: fw,
        y: 0,
        width: fw,
        height: fh
      };
      m = this._frameThickness(); // * Толщина
      ref = this._outFrame.children;
      for (j = 0, len = ref.length; j < len; j++) {
        spr = ref[j];
        spr.bitmap = this.skinBitmap;
      }
      if (KDCore.isMZ()) {
        Window.prototype._setRectPartsGeometry.call(this, this._outFrame, srect, drect, m);
      } else {
        this._setRectPartsGeometry(this._outFrame, srect, drect, m);
      }
    }

    // * Этот метод существует в MZ, но нет в MV
    //? From MZ
    _setRectPartsGeometry(sprite, srect, drect, m) {
      var child, children, dh, dmh, dmw, dw, dx, dy, j, len, sh, smh, smw, sw, sx, sy;
      sx = srect.x;
      sy = srect.y;
      sw = srect.width;
      sh = srect.height;
      dx = drect.x;
      dy = drect.y;
      dw = drect.width;
      dh = drect.height;
      smw = sw - m * 2;
      smh = sh - m * 2;
      dmw = dw - m * 2;
      dmh = dh - m * 2;
      children = sprite.children;
      sprite.setFrame(0, 0, dw, dh);
      sprite.move(dx, dy);
      // corner
      children[0].setFrame(sx, sy, m, m);
      children[1].setFrame(sx + sw - m, sy, m, m);
      children[2].setFrame(sx, sy + sw - m, m, m);
      children[3].setFrame(sx + sw - m, sy + sw - m, m, m);
      children[0].move(0, 0);
      children[1].move(dw - m, 0);
      children[2].move(0, dh - m);
      children[3].move(dw - m, dh - m);
      // edge
      children[4].move(m, 0);
      children[5].move(m, dh - m);
      children[6].move(0, m);
      children[7].move(dw - m, m);
      children[4].setFrame(sx + m, sy, smw, m);
      children[5].setFrame(sx + m, sy + sw - m, smw, m);
      children[6].setFrame(sx, sy + m, m, smh);
      children[7].setFrame(sx + sw - m, sy + m, m, smh);
      children[4].scale.x = dmw / smw;
      children[5].scale.x = dmw / smw;
      children[6].scale.y = dmh / smh;
      children[7].scale.y = dmh / smh;
      // center
      if (children[8] != null) {
        children[8].setFrame(sx + m, sy + m, smw, smh);
        children[8].move(m, m);
        children[8].scale.x = dmw / smw;
        children[8].scale.y = dmh / smh;
      }
      for (j = 0, len = children.length; j < len; j++) {
        child = children[j];
        child.visible = dw > 0 && dh > 0;
      }
    }

  };
  return KDCore.Sprite_TilingFrame = Sprite_TilingFrame;
}));


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Window_ExtTextLineBase;
  // * Данное окно используется как основа для Sprite_UITextExt
  //rev 07.10.21
  Window_ExtTextLineBase = class Window_ExtTextLineBase extends Window_Base {
    constructor(rect, fontSettings) {
      super(rect);
      this.fontSettings = fontSettings;
      this.createContents();
      // * Всегда прозрачное окно
      this.setBackgroundType(2);
    }

    // * Нет отступов
    updatePadding() {
      return this.padding = 0;
    }

    // * Нет отступов
    itemPadding() {
      return 0;
    }

    textPadding() {
      return 0;
    }

    standardPadding() {
      return 0;
    }

    contentsWidth() {
      return this.width;
    }

    contentsHeight() {
      return this.height;
    }

    // * Более гибкая настройка размера текста при { }
    makeFontBigger() {
      return this.contents.fontSize += 1;
    }

    makeFontSmaller() {
      if (this.contents.fontSize > 1) {
        return this.contents.fontSize -= 1;
      }
    }

    // * Применение своих шрифта и размера текста
    resetFontSettings() {
      super.resetFontSettings();
      if (this.fontSettings == null) {
        return;
      }
      if (String.any(this.fontSettings.face)) {
        this.contents.fontFace = this.fontSettings.face;
      }
      if (this.fontSettings.size > 0) {
        this.contents.fontSize = this.fontSettings.size;
      }
      if (this.fontSettings.italic != null) {
        this.contents.fontItalic = this.fontSettings.italic;
      }
    }

  };
  return KDCore.Window_ExtTextLineBase = Window_ExtTextLineBase;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button M
  //------------------------------------------------------------------------------
  //@[AUTO EXTEND]
  // * Button Mini - упрощённый класс Sprite_XButton (KDCore.Button)

    // * Принимает название файла изображения кнопки без _00
  // * Названия изображения должны быть в стандартном формате _00, _01, [_03]
  // * _02 - не используются в этом классе

    // * Класс использует глобальную временную переменную для определения находится ли мышь в зоне кнопки

    //TODO: ADD ALPHA CHECK!

    // * Если isFull - true, значит нужен _03
  KDCore.ButtonM = class ButtonM extends KDCore.Sprite {
    constructor(filename, isFull = false, sourceFolder = null) {
      super();
      this._bitmaps = [];
      this._disabled = false;
      this._isTriggered = false;
      // * Когда произошло нажатие на кнопку
      this._handler = null;
      this._isCanBeClicked = true;
      this._isManualHoverMode = false;
      this._isManualSelected = false;
      this._loadBitmaps(filename, isFull, sourceFolder);
      this._setImageState(0);
      this._createThread();
    }

    realWidth() {
      return this._bitmaps[0].width;
    }

    realHeight() {
      return this._bitmaps[0].height;
    }

    setManualHover() {
      return this._isManualHoverMode = true;
    }

    disableManualHover() {
      return this._isManualHoverMode = false;
    }

    setManualSelected(_isManualSelected) {
      this._isManualSelected = _isManualSelected;
    }

    enableClick() {
      return this._isCanBeClicked = true;
    }

    disableClick() {
      return this._isCanBeClicked = false;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
    }

    isLoaded() {
      var ref;
      return (ref = this._bitmaps[0]) != null ? ref.isReady() : void 0;
    }

    isMouseIn() {
      if (this._isManualHoverMode === true) {
        return this._isManualSelected;
      } else {
        return this.isUnderMouse() && this.visible === true;
      }
    }

    isAllParentsActive() {
      var e, parent;
      try {
        parent = this.parent;
        while (parent != null) {
          if (parent.visible === false) {
            return false;
          }
          if (parent.opacity === 0) {
            return false;
          }
          parent = parent.parent;
        }
        return true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    }

    isActive() {
      if (this._isCanBeClicked === false) {
        return false;
      }
      if (this.visible === false) {
        return false;
      }
      if (this.opacity === 0) {
        return false;
      }
      return this.isAllParentsActive();
    }

    isDisabled() {
      return this._disabled === true;
    }

    addClickHandler(_handler) {
      this._handler = _handler;
    }

    clearClickHandler() {
      return this._handler = null;
    }

    // * Воспроизводит визуальный эффект нажатия
    simulateClick() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.isMouseIn()) {
        return;
      }
      this._startSimulation();
    }

    isEnabled() {
      return !this.isDisabled();
    }

    refreshState(isEnable = true) {
      if (isEnable === true) {
        if (this.isDisabled()) {
          this.enable();
        }
      } else {
        if (this.isEnabled()) {
          this.disable();
        }
      }
    }

    disable() {
      this._disabled = true;
      return this._setImageState(2);
    }

    enable() {
      this._disabled = false;
      return this._setImageState(0);
    }

    click() {
      if (this._handler != null) {
        return this._handler();
      }
    }

    update() {
      super.update();
      return this._updateMain();
    }

  };
  return (function() {    
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ ButtonM Implementation
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _, alias_SM_isAnyButtonPressed, alias_SM_onMapLoaded;
    //@[DEFINES]
    _ = KDCore.ButtonM.prototype;
    _._loadBitmaps = function(filename, isFull = false, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(filename + '_00'));
      this._bitmaps[0].addLoadListener(this._onBitmapLoaded.bind(this));
      this._bitmaps.push(getterFunc(filename + '_01'));
      if (isFull) {
        this._bitmaps.push(getterFunc(filename + '_03'));
      }
    };
    _._onBitmapLoaded = function() {
      var e;
      try {
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getGetter = function(sourceFolder = null) {
      var getterFunc;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder !== null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap('img/' + sourceFolder + '/', filename);
        };
      }
      return getterFunc;
    };
    _._setImageState = function(index = 0) {
      if (this._bitmaps[index] == null) {
        index = 0;
      }
      this.bitmap = this._bitmaps[index];
      this._lastState = index;
    };
    _._createThread = function() {
      this.hoverThread = new KDCore.TimedUpdate(3, this._updateHover.bind(this));
      this.hoverThread.applyTimeRange(-1, 1);
      this.hoverThread.call();
    };
    //?[DYNAMIC]
    _._updateMain = function() {
      this._updateMouseLogic();
      if (!this.isActive()) {
        if (($gameTemp.kdButtonUnderMouse != null) && $gameTemp.kdButtonUnderMouse === this) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseLogic = function() {
      this.hoverThread.update();
      return this._updateMouseClick();
    };
    _._updateHover = function() {
      var e;
      if (!this.isActive()) {
        return;
      }
      // * чтобы эффект нажатия не прекратить
      if (this._isTriggered === true) {
        return;
      }
      if (this.isMouseIn()) {
        if (this._lastState !== 1) {
          if (!this.isDisabled()) {
            this._setImageState(1);
          }
          $gameTemp.kdButtonUnderMouse = this;
          try {
            if ($gameTemp.__pkdActiveKeyboardHandler != null) {
              $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
      } else {
        if (this._lastState !== 0) {
          if (!this.isDisabled()) {
            this._setImageState(0);
          }
          if ($gameTemp.kdButtonUnderMouse === this) {
            $gameTemp.kdButtonUnderMouse = null;
          }
        } else if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseClick = function() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.isUnderMouse()) {
        this._isTriggered = true;
        this._setImageState(0);
      }
      if (this._isTriggered === true) {
        if (TouchInput.isReleased()) {
          this._isTriggered = false;
          if (this.isMouseIn()) {
            this.click();
          }
        }
      }
    };
    _._startSimulation = function() {
      this._setImageState(1);
      this._simulateThread = new KDCore.TimedUpdate(10, () => {
        return this._setImageState(0);
      });
      this._simulateThread.once();
      return this._updateMain = this._updateMouseClickSimulated;
    };
    _._updateMouseClickSimulated = function() {
      this._simulateThread.update();
      if (!this._simulateThread.isAlive()) {
        this._simulateThread = null;
        this._updateMain = this._updateMouseLogic;
      }
    };
    // * Теперь при нажатии на любую кнопку, игрок не будет ходить по карте

    //@[ALIAS]
    alias_SM_isAnyButtonPressed = Scene_Map.prototype.isAnyButtonPressed;
    Scene_Map.prototype.isAnyButtonPressed = function() {
      if ($gameTemp.kdButtonUnderMouse != null) {
        return true;
      } else {
        return alias_SM_isAnyButtonPressed.call(this);
      }
    };
    //TODO: Добавить доп. проверку?
    //@[ALIAS]
    alias_SM_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function() {
      $gameTemp.kdButtonUnderMouse = null;
      setTimeout((function() {
        return $gameTemp.kdButtonUnderMouse = null;
      }), 50);
      return alias_SM_onMapLoaded.call(this);
    };
  })();
});

// ■ END ButtonM Implementation
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button Mini User - класс с определением файла каждого состояния отдельно
  // * Принимает теже аргументы, только заместо имени файла, три изображения (имени)
  // ? states = { main, hover, disabled }
  return KDCore.ButtonMU = class ButtonMU extends KDCore.ButtonM {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    _loadBitmaps(states, isFull = true, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(states.main));
      this._bitmaps.push(getterFunc(states.hover));
      // * Optional 03
      if (String.any(states.disabled)) {
        this._bitmaps.push(getterFunc(states.disabled));
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_TilingLine;
  Sprite_TilingLine = class Sprite_TilingLine extends KDCore.Sprite_TilingFrame {
    constructor() {
      super(...arguments);
    }

    //$[OVER BASE ALL BELOW]
    _fillPadding() {
      return 0;
    }

    _refreshTFrame() {} // * EMPTY

    _fillImagePartWidth() {
      return 4;
    }

    _fillImagePartHeight() {
      return 26;
    }

  };
  return KDCore.Sprite_TilingLine = Sprite_TilingLine;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Пространство имён для всех UIElements
  KDCore.UI = KDCore.UI || {};
  (function() {    // * Общий класс для всех UI элементов
    //?rev 07.02.2024
    var Sprite_UIElement;
    Sprite_UIElement = (function() {
      // * ABSTRACT значит что класс сам по себе ничего не создаёт, не хранит данные
      //@[ABSTRACT]
      class Sprite_UIElement extends KDCore.Sprite {
        constructor(params) {
          super();
          this.params = params;
          this._init();
        }

        // * Стандартный набор настроек
        defaultParams() {
          return {
            visible: true
          };
        }

        // * Общий метод (есть у всех элементов)
        // * По умолчанию вызывает drawText, но потомки могут переопределить
        draw() {
          return this.drawText(...arguments);
        }

        // * Общий метод
        drawText() {} // * EMPTY

        
          // * Если изначально невидимый (из параметров), то не активный вообще
        isActive() {
          return this.params.visible === true;
        }

        rootImageFolder() {
          if (String.any(this.params.rootImageFolder)) {
            return this.params.rootImageFolder;
          } else {
            return Sprite_UIElement.RootImageFolder;
          }
        }

        // * Сделать чёрно белым
        desaturate() {
          this.filters = [new PIXI.filters.ColorMatrixFilter()];
          this.filters[0].desaturate();
        }

        clearFilters() {
          return this.filters = [];
        }

        // * Общий метод (можно ли редактировать визуально)
        isCanBeEdited() {
          return false;
        }

        // * Общий метод (надо ли скрывать при игровом сообщнии)
        isHaveHideWithMessageFlag() {
          return false;
        }

        // * Общий метод (находится ли объект под мышкой)
        isUnderMouse() {
          var ref;
          return ((ref = this.zeroChild()) != null ? ref.isUnderMouse() : void 0) && this.isFullVisible();
        }

        // * Полностью ли виден объект? (включае всех его родителей)
        isFullVisible() {
          return this.visible === true && this.allParentsIsVisible();
        }

        // * Все ли родители объекта видимы
        allParentsIsVisible() {
          var e, p;
          if (!this.visible) {
            return false;
          }
          try {
            if (this.parent != null) {
              p = this.parent;
              while (p != null) {
                if (p.visible === true) {
                  p = p.parent;
                } else {
                  return false;
                }
              }
              return true;
            } else {
              return this.visible === true;
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            return true;
          }
        }

        // * Параметры первого элемента (если он есть)
        realWidth() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
          return 0;
        }

        realHeight() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
          return 0;
        }

        // * Метод восстановления значения на стандартные настройки
        reset(property) {
          var e;
          try {
            switch (property) {
              case "position":
                this._resetPosition();
                break;
              default:
                this[property] = this.params[property];
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }

      };

      // * Корневая директория для изображений
      Sprite_UIElement.RootImageFolder = "Alpha";

      return Sprite_UIElement;

    }).call(this);
    KDCore.UI.Sprite_UIElement = Sprite_UIElement;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIElement.prototype;
    _._init = function() {
      var e;
      this._prepare();
      try {
        return this._createContent();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Если при создании произошла ошибка, отключаем элемент
        return this.isActive = function() {
          return false;
        };
      }
    };
    
    // * Подготовка элемента (проверка параметров)
    _._prepare = function() {
      //@params = @defaultParams() unless @params?
      this.params = Object.assign({}, this.defaultParams(), this.params);
      if (this.params.visible != null) {
        this.visible = this.params.visible;
      }
    };
    // * Наследники создают свои элементы в этом методе
    _._createContent = function() {}; // * EMPTY
    
    // * Сброс позиции
    _._resetPosition = function() {
      var e, x, y;
      if (this.params.position == null) {
        return;
      }
      try {
        ({x, y} = this.params.position);
        if (isFinite(x) && isFinite(y)) {
          x = Number(x);
          y = Number(y);
        } else {
          x = Number(eval(x));
          y = Number(eval(y));
        }
        this.move(x, y);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.move(0, 0);
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListNHor;
  //TODO: NOT USED IN NUI 1.0
  //NUI 1.X !#!
  //rev 03.05.24

    //"type": "horList"
  Sprite_ItemsListNHor = class Sprite_ItemsListNHor extends KDCore.Sprite_ItemsListN {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    defaultSettings() {
      var settings;
      settings = super.defaultSettings();
      settings.width = 420;
      settings.height = 120;
      settings.maxCols = 4;
      return settings;
    }

    //$[OVER]
    setMaxCols(maxCols) {} // * AUTO

    setItems(items) {
      var e, l;
      try {
        if (items != null) {
          l = this.maxItems();
          if (l !== items.length) {
            this.settings.maxCols = items.length;
            this.clear();
            this._applySettings();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.setItems(items);
    }

  };
  return KDCore.Sprite_ItemsListNHor = Sprite_ItemsListNHor;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Screen;
  //NUI 1.0
  //rev 04.05.24

    //"type": "screen"
  Sprite_Screen = class Sprite_Screen extends KDCore.Sprite_Group {
    constructor(settings) {
      super(settings);
      this._applyExtraSettings();
    }

    //TODO: В режиме linkToMap, должен иметь width и height карты (size * tileSize)
    realWidth() {
      return Graphics.width;
    }

    realHeight() {
      return Graphics.height;
    }

    defaultSettings() {
      var defaultSettings;
      defaultSettings = super.defaultSettings();
      return Object.assign(defaultSettings, {
        width: Graphics.width,
        height: Graphics.height,
        linkToMap: false //TODO: NOT USED IN NUI 1.0
      });
    }

    _applyExtraSettings() {
      var e;
      try {
        if (this.settings.linkToMap === true) {
          return this.anchorPoint = new KDCore.MapAnchorPoint(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      super.update();
      return this._refreshScreenPosition();
    }

    _refreshScreenPosition() {
      var e;
      try {
        if (this.anchorPoint == null) {
          return;
        }
        this.x = this.anchorPoint.screenX();
        return this.y = this.anchorPoint.screenY();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Screen = Sprite_Screen;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIButton;
    // * Кнопка на экране, можно нажимать
    Sprite_UIButton = class Sprite_UIButton extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "Button_Inventory",
          isHaveDisabled: true,
          rootImageFolder: null, //?optional
          click: "console.log('click')" // * число или код
        };
      }

      // * Кнопка не поддерживает перерисовку
      draw() {} // * EMPTY

      disable() {
        var ref;
        return (ref = this.button) != null ? ref.disable() : void 0;
      }

      enable() {
        var ref;
        return (ref = this.button) != null ? ref.enable() : void 0;
      }

      setState(isEnabled) {
        if (isEnabled) {
          return this.enable();
        } else {
          return this.disable();
        }
      }

      
        // * Просто вызов метода
      call() {
        var ref;
        return (ref = this.button) != null ? ref.click() : void 0;
      }

      // * Вызов метода с симуляцией нажатия
      click() {
        var ref, ref1;
        if ((ref = this.button) != null) {
          ref.click();
        }
        return (ref1 = this.button) != null ? ref1.simulateClick() : void 0;
      }

    };
    KDCore.UI.Sprite_UIButton = Sprite_UIButton;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIButton.prototype;
    //$[OVER]
    _._createContent = function() {
      if (this.params.image.isEmpty()) {
        KDCore.warning('You try create Button without image');
        return;
      }
      this.button = new KDCore.ButtonM(this.params.image, this.params.isHaveDisabled, this.rootImageFolder());
      this.add(this.button);
      return this._registerClickMethod();
    };
    _._registerClickMethod = function() {
      var commonEventId, e, method, ref, script;
      if (!String.any(this.params.click)) {
        return;
      }
      method = null;
      try {
        // * Если число, то значит общее событие
        if (isFinite(this.params.click)) {
          commonEventId = parseInt(this.params.click);
          if (commonEventId > 0) {
            method = function() {
              return $gameTemp.reserveCommonEvent(commonEventId);
            };
          }
        } else {
          // * Иначе скрипт
          script = this.params.click;
          method = function() {
            return eval(script);
          };
        }
        return this.button.addClickHandler(method);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Рисует лицо персонажа (из папки Faces)
    var Sprite_UIFace;
    Sprite_UIFace = class Sprite_UIFace extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          faceName: "Actor1",
          faceIndex: 0,
          mirror: false,
          size: 144
        };
      }

      draw() {
        return this.drawFace(...arguments);
      }

      drawFace(faceName, faceIndex) {
        return this._drawFaceWhenReady(faceName, faceIndex);
      }

    };
    KDCore.UI.Sprite_UIFace = Sprite_UIFace;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIFace.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._createFaceSprite();
    };
    _._createFaceSprite = function() {
      this._faceSpr = KDCore.Sprite.FromBitmap(this.params.size);
      if (this.params.mirror === true) {
        this._flipFaceSpr();
      }
      this.add(this._faceSpr);
      this._drawFaceWhenReady(this.params.faceName, this.params.faceIndex);
    };
    _._flipFaceSpr = function() {
      this._faceSpr.scale.x = -1;
      this._faceSpr.x = this.params.size;
    };
    _._drawFaceWhenReady = function(name, index = 0) {
      var ref;
      if ((ref = this._faceSpr) != null) {
        ref.clear();
      }
      if (!String.any(name)) {
        return;
      }
      if (index < 0) {
        return;
      }
      this._drawOnReady = {name, index};
      this._faceSourceBitmap = ImageManager.loadFace(name);
      this._faceSourceBitmap.addLoadListener(this._drawFace.bind(this));
      this._drawFace();
    };
    _._drawFace = function() {
      var fh, fw, size, sx, sy;
      if (this._faceSpr == null) {
        return;
      }
      this._faceSpr.clear();
      if (!String.any(this._drawOnReady.name)) {
        return;
      }
      if (KDCore.isMZ()) {
        fw = ImageManager.faceWidth;
        fh = ImageManager.faceHeight;
      } else {
        fw = Window_Base._faceWidth;
        fh = Window_Base._faceHeight;
      }
      size = this.params.size;
      sx = (this._drawOnReady.index % 4) * fw;
      sy = Math.floor(this._drawOnReady.index / 4) * fh;
      this._faceSpr.bitmap.blt(this._faceSourceBitmap, sx, sy, fw, fh, 0, 0, size, size);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIGauge;
    Sprite_UIGauge = class Sprite_UIGauge extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          fill: "",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawGauge(...arguments);
      }

      drawGauge(percent = 1) {
        this._lastValue = percent;
        return this._drawGauge(percent);
      }

      isVertical() {
        return this.params.vertical === true;
      }

    };
    KDCore.UI.Sprite_UIGauge = Sprite_UIGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIGauge.prototype;
    //$[OVER]
    _._createContent = function() {
      // * Загружается главное изображение, затем уже все остальные, т.к. нужны размеры
      return this._loadFillImage();
    };
    _._loadFillImage = function() {
      // * Главное изображение, поэтому если не указано, то ничего
      if (this.params.fill.isEmpty()) {
        KDCore.warning('You try create Gauge without fill image');
        return;
      }
      KDCore.Utils.loadImageAsync(this.rootImageFolder(), this.params.fill).then(this._createParts.bind(this));
    };
    // * Получаем изображение заполнения и создаём части (т.к. есть размеры)
    _._createParts = function(fillBitmap) {
      this.fillBitmap = fillBitmap;
      this._createBackground();
      this._createFillLayer();
      this._loadForeground();
      this._loadMask();
      return this._onReady();
    };
    _._createBackground = function() {
      this.background = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      this.background.b().fillAll(this.params.backColor);
      this.background.opacity = this.params.backOpacity;
      return this.add(this.background);
    };
    _._createFillLayer = function() {
      this.fillLayer = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      return this.add(this.fillLayer);
    };
    _._loadForeground = function() {
      var fore;
      if (String.isNullOrEmpty(this.params.foreground)) {
        return;
      }
      fore = KDCore.Sprite.FromImg(this.params.foreground, this.rootImageFolder());
      return this.add(fore);
    };
    _._loadMask = function() {
      var mask;
      if (String.isNullOrEmpty(this.params.mask)) {
        return;
      }
      mask = KDCore.Sprite.FromImg(this.params.mask, this.rootImageFolder());
      this.mask = mask;
      return this.add(mask);
    };
    // * Если что-то было до готовности, нарисовать
    _._onReady = function() {
      this.drawGauge(this._lastValue);
    };
    _._drawGauge = function(percent) {
      if (this.fillLayer == null) {
        return;
      }
      this.fillLayer.clear();
      if (this.isVertical()) {
        return this._drawVerGauge(percent);
      } else {
        return this._drawHorGauge(percent);
      }
    };
    _._drawHorGauge = function(percent) {
      var w;
      w = this.fillBitmap.width * percent;
      return this.fillLayer.b().blt(this.fillBitmap, 0, 0, w, this.fillLayer.height, 0, 0);
    };
    _._drawVerGauge = function(percent) {
      var h, hy;
      h = this.fillBitmap.height * percent;
      hy = this.fillBitmap.height - h;
      this.fillLayer.b().blt(this.fillBitmap, 0, 0, this.fillLayer.width, h, 0, hy);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIIcon;
    Sprite_UIIcon = class Sprite_UIIcon extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          index: 0,
          size: 32,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawIcon(...arguments);
      }

      drawIcon(index = 0, noSmoth = false) {
        this._lastValue = index;
        return this._drawIcon(index, noSmoth);
      }

    };
    KDCore.UI.Sprite_UIIcon = Sprite_UIIcon;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIIcon.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createIcon();
      return this._drawIcon(this.params.index);
    };
    _._createIcon = function() {
      this._icon = KDCore.Sprite.FromBitmap(this.params.size, this.params.size);
      this.add(this._icon);
      return this._onReady();
    };
    _._onReady = function() {
      return this.drawIcon(this._lastValue);
    };
    _._drawIcon = function(index, noSmoth = false) {
      this._icon.clear();
      if (KDCore.SDK.isString(index)) {
        this._drawImageIcon(index, noSmoth);
      } else {
        if (index <= 0) {
          return;
        }
        this._icon.drawIcon(0, 0, index, this.params.size, noSmoth);
      }
    };
    _._drawImageIcon = function(imageName, noSmoth = false) {
      return KDCore.Utils.loadImageAsync(this.rootImageFolder(), imageName).then((bitmap) => {
        return this._icon.drawIcon(0, 0, bitmap, this.params.size, noSmoth);
      });
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIImage;
    Sprite_UIImage = class Sprite_UIImage extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "",
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawImage(...arguments);
      }

      drawImage(image) {
        return this._drawImage(image);
      }

    };
    KDCore.UI.Sprite_UIImage = Sprite_UIImage;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIImage.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._drawImage(this.params.image);
    };
    _._drawImage = function(image) {
      this._clearImage();
      if (!String.isNullOrEmpty(image)) {
        this._image = KDCore.Sprite.FromImg(image, this.rootImageFolder());
        this.add(this._image);
      }
    };
    _._clearImage = function() {
      if (this._image == null) {
        return;
      }
      this._image.visible = false;
      this.removeChild(this._image);
      return this._image = null;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIRect;
    Sprite_UIRect = class Sprite_UIRect extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 60,
            h: 20
          },
          fillColor: "#FFFFFF".toCss(),
          fillOpacity: 255,
          borderColor: "#000000".toCss(),
          borderThickness: 1,
          borderOpacity: 255
        };
      }

      draw() {
        return this.fill(...arguments);
      }

      fill(color, opacity = 255) {
        return this._fill(color, opacity);
      }

      drawBorder(color, thickness = 1, opacity = 255) {
        return this._drawBorder(color, thickness, opacity);
      }

    };
    KDCore.UI.Sprite_UIRect = Sprite_UIRect;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIRect.prototype;
    //$[OVER]
    _._createContent = function() {
      if (String.any(this.params.fillColor)) {
        this._createFill();
        this.fill(this.params.fillColor, this.params.fillOpacity);
      }
      if (String.any(this.params.borderColor) && this.params.borderThickness > 0) {
        this._createBorder();
        return this.drawBorder(this.params.borderColor, this.params.borderThickness, this.params.borderOpacity);
      }
    };
    _._createFill = function() {
      this._fillSpr = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._fillSpr);
    };
    _._createBorder = function() {
      this._borderSprite = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._borderSprite);
    };
    _._fill = function(color, opacity) {
      if (this._fillSpr == null) {
        return;
      }
      this._fillSpr.fillAll(color);
      this._fillSpr.opacity = opacity;
    };
    _._drawBorder = function(color, thickness, opacity) {
      var b;
      if (this._borderSprite == null) {
        return;
      }
      this._borderSprite.clear();
      b = this._borderSprite.b();
      // * Top line
      b.fillRect(0, 0, b.width, thickness, color);
      // * Bottom line
      b.fillRect(0, b.height - thickness, b.width, thickness, color);
      // * Left line
      b.fillRect(0, 0, thickness, b.height, color);
      // * Right line
      b.fillRect(b.width - thickness, 0, thickness, b.height, color);
      return this._borderSprite.opacity = opacity;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22

    //"type": "legacyText"
    var Sprite_UIText;
    Sprite_UIText = class Sprite_UIText extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#ffffff",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: ""
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      realWidth() {
        return this.sizeWidth();
      }

      realHeight() {
        return this.sizeHeight();
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            return this.updateStyle(v);
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h,
              width: w,
              height: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyle) {
        var e;
        try {
          this.params = Object.assign({}, this.params, newStyle);
          this._destroyOldContent();
          this._createContent();
          // * Redraw Text
          return this.drawText(this._lastText || "");
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //?DYNAMIC
      // * Сперва рисуем по готовности, а как загрузился спрайт, меняем
      drawText(text) {
        var e;
        try {
          this.params.text = text;
          return this._drawTextWhenReady(text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss) {
        if (this._textSpr == null) {
          return;
        }
        this._textSpr.b().textColor = colorCss;
        this.drawText(text);
        this._textSpr.b().textColor = this.params.textColor;
      }

    };
    KDCore.UI.Sprite_UIText = Sprite_UIText;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText.prototype;
    _._destroyOldContent = function() {
      var e, ref, ref1;
      try {
        if ((ref = this._shadowSpr) != null) {
          ref.removeFromParent();
        }
        return (ref1 = this._textSpr) != null ? ref1.removeFromParent() : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createContent = function() {
      if (this.params.shadow != null) {
        this._createShadow();
      }
      return this._createTextSprite();
    };
    _._createTextSprite = function() {
      this._textSpr = KDCore.Sprite.FromParams(this.params);
      this._textSpr.onReady(this._onReady.bind(this));
      return this.add(this._textSpr);
    };
    // * Выполнить по готовности
    _._onReady = function() {
      // * Переключить метод, так как уже готов
      this.drawText = this._drawText;
      // * Написать то что нужно было до готовности (если есть)
      if (this._drawOnReady == null) {
        return;
      }
      this.drawText(this._drawOnReady);
      this._drawOnReady = null;
    };
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      if (text != null) {
        this._textSpr.drawTextFull(text);
      }
      if (this._shadowSpr != null) {
        this._shadowSpr.clear();
        if (text != null) {
          this._shadowSpr.drawTextFull(text);
        }
      }
    };
    // * Написать текст когда будет готов
    _._drawTextWhenReady = function(text) {
      this._drawOnReady = text;
      return this._drawText(text);
    };
    
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
    _._createShadow = function() {
      this._shadowSpr = KDCore.Sprite.FromParams(this.params);
      this._shadowSpr.bitmap.textColor = this.params.shadow.color;
      this._shadowSpr.opacity = this.params.shadow.opacity;
      this._shadowSpr.x += this.params.shadow.margins.x;
      this._shadowSpr.y += this.params.shadow.margins.y;
      return this.add(this._shadowSpr);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22
    var Sprite_UIText2;
    
      //"type": "text"
    Sprite_UIText2 = class Sprite_UIText2 extends KDCore.UI.Sprite_UIElement {
      constructor(params, userTextStyle) {
        super(params);
        this.userTextStyle = userTextStyle;
        this._applyParameters(params);
        this._createTextSprite();
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
        return;
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false,
            bold: false,
            weight: 0 // * 0 - not used
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#FFFFFF",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: "",
          multiline: false,
          verticalCentered: true
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            if (v != null) {
              return this.updateStyle(v);
            }
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      realWidth() {
        return this.sizeWidth();
      }

      realHeight() {
        return this.sizeHeight();
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      defaultStyle() {
        return {};
      }

      drawText(text) {
        if (text == null) {
          text = "";
        }
        this.params.text = text;
        this._drawText(text);
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss = "#FFF") {
        if (this._textSpr == null) {
          return;
        }
        this.updateStyle({
          textColor: colorCss
        });
        this.drawText(text);
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyleInOldFormat = {}, newStyleInNewFormat = {}) {
        var e;
        try {
          this.textStyle = this._convertOldStyle(newStyleInOldFormat, newStyleInNewFormat);
          this._textSpr.style = this.textStyle;
          // * Redraw Text
          return this.drawText(this._textSpr.text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      getMetrics() {
        return PIXI.TextMetrics.measureText(this._textSpr.text, this._textSpr.style);
      }

    };
    KDCore.UI.Sprite_UIText2 = Sprite_UIText2;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText2.prototype;
    _._applyParameters = function(params) {
      var e;
      try {
        return this.textStyle = this._convertOldStyle(params, {});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertOldStyle = function(params = {}, style = {}) {
      var _textStyle, color, e, margins, opacity;
      try {
        this.params = Object.assign({}, this.params, params);
        _textStyle = Object.assign({}, this.defaultStyle(), this.userTextStyle, style);
        if (String.any(this.params.font.face)) {
          _textStyle.fontFamily = this.params.font.face;
        }
        _textStyle.fontSize = this.params.font.size;
        if (this.params.font.italic === true) {
          _textStyle.fontStyle = 'italic';
        }
        if (this.params.font.bold === true) {
          _textStyle.fontWeight = 'bold';
        }
        if ((this.params.font.weight != null) && this.params.font.weight > 0) {
          _textStyle.fontWeight = this.params.font.weight;
        }
        if (String.any(this.params.outline.color) && this.params.outline.width > 0) {
          _textStyle.stroke = this.params.outline.color;
          _textStyle.strokeThickness = this.params.outline.width;
        }
        _textStyle.fill = this.params.textColor;
        if ((this.params.shadow != null) && this.params.shadow.opacity > 0) {
          ({color, opacity, margins} = this.params.shadow);
          _textStyle.dropShadow = true;
          _textStyle.dropShadowAngle = margins.y;
          _textStyle.dropShadowColor = color;
          _textStyle.dropShadowDistance = margins.x;
          _textStyle.dropShadowAlpha = opacity / 255.0;
        }
        if (this.params.multiline === true) {
          _textStyle.align = this.params.alignment || 'left';
          _textStyle.wordWrap = true;
          if (this.params.font.size != null) {
            _textStyle.lineHeight = this.params.font.size + 2;
          }
          if (this.sizeWidth() > 0) {
            _textStyle.wordWrapWidth = this.sizeWidth();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return _textStyle;
    };
    _._createTextSprite = function() {
      var style;
      style = new PIXI.TextStyle(this.textStyle);
      this._textSpr = new PIXI.Text('', style);
      this.add(this._textSpr);
      if (this._needToDrawText != null) {
        this.draw(this._needToDrawText);
        this._needToDrawText = null;
      }
    };
    _._drawText = function(text) {
      var e, h, height, maxLineWidth, textMetrics, w;
      if (this._textSpr == null) {
        this._needToDrawText = text;
        return;
      }
      this._textSpr.text = text;
      if (this.params.size.height != null) {
        this.params.size.h = this.params.size.height;
      }
      if (this.params.size.width != null) {
        this.params.size.w = this.params.size.width;
      }
      ({w, h} = this.params.size);
      try {
        if (typeof text !== "string") {
          text = String(text);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        text = "[wrong text input]";
      }
      textMetrics = PIXI.TextMetrics.measureText(text, this._textSpr.style);
      ({height, maxLineWidth} = textMetrics);
      if (this.params.verticalCentered === true) {
        this._textSpr.y = (h - height) / 2;
      } else {
        this._textSpr.y = 0;
      }
      if (this.params.alignment === 'center') {
        this._textSpr.x = (w - maxLineWidth) / 2;
      } else if (this.params.alignment === 'right') {
        this._textSpr.x = w - maxLineWidth;
      } else {
        this._textSpr.x = 0;
      }
      this._textSpr.x += this.params.margins.x;
      this._textSpr.y += this.params.margins.y;
    };
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //TODO: NOT USED IN NUI 1.0
    //NUI 1.X !#!
    //rev 03.05.22

    //"type": "textExt"
    var Sprite_UITextExt;
    Sprite_UITextExt = class Sprite_UITextExt extends KDCore.UI.Sprite_UIText {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 200,
            height: 60
          },
          font: {
            face: null,
            size: 14,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          // * новые параметры (KDCore 2.7)
          //?null могут быть
          singleLine: false,
          forceCentered: false
        };
      }

      //$[OVER]
      // * Данный метод не поддерживается, так как тут основа не Sprite, а Window
      drawTextColor() {
        return this.drawText(...arguments);
      }

    };
    KDCore.UI.Sprite_UITextExt = Sprite_UITextExt;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextExt.prototype;
    //$[OVER]
    _._destroyOldContent = function() {
      var e;
      try {
        if (this._textSpr == null) {
          return;
        }
        return this.removeChild(this._textSpr);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createTextSprite = function() {
      var rect;
      rect = new Rectangle(0, 0, this.sizeWidth(), this.sizeHeight());
      this._textSpr = new KDCore.Window_ExtTextLineBase(rect, this.params.font);
      this._textSpr.x = this.params.margins.x || 0;
      this._textSpr.y = this.params.margins.y || 0;
      this.add(this._textSpr);
      // * На следующий кадр, чтобы не было потери текста (опасно)
      setTimeout((() => {
        var e;
        try {
          return this._onReady();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 10);
      this._onReady(); // * Сразу
    };
    
    //$[OVER]
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.contents.clear();
      if (this.params.forceCentered === true) {
        this._textSpr.drawTextExInCenter(text, 0, 0, this._textSpr.width, this._textSpr.height);
      } else {
        if (this.params.singleLine === true) {
          this._textSpr.drawTextEx(text, 0, 0, this._textSpr.width);
        } else {
          // * По умолчанию
          this._textSpr.drawTextExWithWordWrap(text, 0, 0, this._textSpr.width);
        }
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UITextWithBack;
    Sprite_UITextWithBack = class Sprite_UITextWithBack extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          text: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            alignment: "center",
            font: {
              face: null,
              size: 18,
              italic: false
            },
            margins: {
              x: 0,
              y: 0
            },
            outline: {
              color: null,
              width: 2
            },
            textColor: "#000000".toCss()
          },
          rect: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            fillColor: "#FFFFFF".toCss(),
            fillOpacity: 255,
            borderColor: "#000000".toCss(),
            borderThickness: 1,
            borderOpacity: 255
          },
          textMargins: {
            x: 0,
            y: 0
          }
        };
      }

      draw() {
        return this.drawText(...arguments);
      }

      // * Aргументы смотри в Sprite_UIText
      drawText() {
        return this.text.draw(...arguments);
      }

      drawTextColor() {
        return this.text.drawTextColor(...arguments);
      }

      // * Аргументы смотри в Sprite_UIRect
      fill() {
        return this.rect.fill(...arguments);
      }

      drawBorder() {
        return this.rect.drawBorder(...arguments);
      }

      //$[OVER]
      isUnderMouse() {
        return this.rect.isUnderMouse();
      }

    };
    KDCore.UI.Sprite_UITextWithBack = Sprite_UITextWithBack;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextWithBack.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createRect();
      return this._createText();
    };
    _._createRect = function() {
      this.rect = new KDCore.UI.Sprite_UIRect(this.params.rect);
      return this.addChild(this.rect);
    };
    _._createText = function() {
      var x, y;
      this.text = new KDCore.UI.Sprite_UIText(this.params.text);
      ({x, y} = this.params.textMargins);
      this.text.move(x, y);
      return this.addChild(this.text);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIColorGauge;
    Sprite_UIColorGauge = class Sprite_UIColorGauge extends KDCore.UI.Sprite_UIGauge {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 100,
            h: 40
          },
          fill: "#FFFFFF", // * В отличии от Gauge, тут цвет, а не картинка
          foreground: "", // картинка
          mask: "", // картинка
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

    };
    KDCore.UI.Sprite_UIColorGauge = Sprite_UIColorGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIColorGauge.prototype;
    //$[OVER]
    // * Заместо изображения используем простой Bitmap с заливкой цвета
    _._loadFillImage = function() {
      var fillBitmap;
      fillBitmap = new Bitmap(this.params.size.w, this.params.size.h);
      fillBitmap.fillAll(this.params.fill);
      this._createParts(fillBitmap);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Данный UI Элемент является только контейнером
    // * Он ничего не рисует, нужно добавлять в него
    // * контент методом addContent

    //rev 17.11.22
    var Sprite_UITooltip;
    Sprite_UITooltip = class Sprite_UITooltip extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        this.opacity = 0;
      }

      isTooltipActive() {
        return (this._opThread != null) || (this._opChanger != null) || this.opacity > 0;
      }

      activateTooltip(x, y, parent) {
        if (this.isTooltipActive()) {
          return;
        }
        this.deactivateTooltip();
        this.move(x, y);
        this._opThread = new KDCore.TimedUpdate(this.params.delay, this.showTooltip.bind(this));
        if (!this.params.isGlobal && (parent != null)) {
          parent.addChild(this);
        } else {
          // * Always on Top on Scene  (if Global)
          SceneManager._scene.addChild(this);
        }
      }

      deactivateTooltip() {
        this._opThread = null;
        this._opChanger = null;
        return this.opacity = 0;
      }

      showTooltip() {
        this._opThread = null;
        this.appear(this.params.opacityChangeStep);
        if (this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      update() {
        var ref;
        super.update();
        if ((ref = this._opThread) != null) {
          ref.update();
        }
        if (this.isTooltipActive() && this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          delay: 30,
          opacityChangeStep: 35,
          margins: {
            x: 8,
            y: 8
          },
          isGlobal: true,
          cursorRelative: true
        };
      }

      toCursor() {
        var x, y;
        ({x, y} = this.params.margins);
        return this.move(TouchInput.x + x, TouchInput.y + y);
      }

      // * Основной метод, нужно добавить контент
      addContent(content) {
        return this.add(content);
      }

    };
    KDCore.UI.Sprite_UITooltip = Sprite_UITooltip;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITooltip.prototype;
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__processEscapeCharacter, _;
  //@[DEFINES]
  _ = Window_Base.prototype;
  //@[ALIAS]
  ALIAS__processEscapeCharacter = _.processEscapeCharacter;
  _.processEscapeCharacter = function(code, textState) {
    switch (code) {
      case 'CHEX':
        this.pProcessColorChangeHex(this.pObtainEscapeParamHexColor(textState));
        break;
      case 'ISZ':
        this.pProcessDrawIconSized(this.pObtainEscapeParamIconArr(textState), textState);
        break;
      case 'PSZ':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, false);
        break;
      case 'PSB':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, true);
        break;
      default:
        ALIAS__processEscapeCharacter.call(this, code, textState);
    }
  };
  //?NEW
  _.pObtainEscapeParamHexColor = function(textState) {
    var arr, regExp, textPart;
    regExp = /^\[(#?([0-9a-fA-F]{2}){3}|([0-9a-fA-F]){3})\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      return arr[1];
    } else {
      return "";
    }
  };
  //?NEW
  _.pObtainEscapeParamIconArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          return parseInt(i.trim());
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pObtainEscapeParamImgArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\w+,\s*\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          if (isFinite(i)) {
            return parseInt(i.trim());
          } else {
            return i;
          }
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pProcessColorChangeHex = function(colorHex) {
    var e;
    try {
      this.changeTextColor(colorHex);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.resetTextColor();
    }
  };
  //?NEW
  //?params: [INDEX, SIZE, DX, DY]
  _.pProcessDrawIconSized = function(params, textState) {
    var dx, dy, e, iconIndex, size, staticMargin, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      size = params[1];
      if (params[1] == null) {
        if (KDCore.isMZ()) {
          size = ImageManager.iconWidth;
        } else {
          size = Window_Base._iconWidth;
        }
      }
      if (params[2] == null) {
        params[2] = 0;
      }
      if (params[3] == null) {
        params[3] = 0;
      }
      iconIndex = params[0];
      dx = params[2];
      dy = params[3];
      staticMargin = 2;
      x = textState.x + staticMargin + dx;
      y = textState.y + staticMargin + dy;
      if (KDCore.isMZ()) {
        if (textState.drawing === true) {
          // * Только в режиме рисования
          this.contents.drawIcon(x, y, iconIndex, size);
        }
      } else {
        this.contents.drawIcon(x, y, iconIndex, size);
      }
      textState.x += size + (staticMargin * 2) + dx;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  //?NEW
  //?params: [NAME, W, H, DX, DY]
  _.pProcessDrawPictureSized = function(params, textState, isUnderText = false) {
    var drawBitmap, drawProcess, e, height, name, source, width, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      name = params[0];
      if (!String.any(name)) {
        return;
      }
      width = params[1];
      height = params[2];
      if (params[3] == null) {
        params[3] = 0;
      }
      if (params[4] == null) {
        params[4] = 0;
      }
      x = textState.x + 2 + params[3];
      y = textState.y + 2 + params[4];
      drawBitmap = this.contents;
      source = this.pGetSourceImageForDrawPictureSized(name);
      if ((KDCore.isMZ() && textState.drawing === true) || KDCore.isMV()) {
        drawProcess = function() {
          var e;
          try {
            if (drawBitmap == null) {
              return;
            }
            return drawBitmap.drawOnMe(source, x, y, width, height);
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        source.addLoadListener(drawProcess);
      }
      if (isUnderText !== true) {
        // * Вариант, что текст не будет "перескакивать" за ширину картинки а пойдёт поверх (т.е. фоновая картинка)
        // * Если картине не preload, то может "вылезти" на текст потом, так как рисоваться будет позже
        textState.x += width + 4 + params[3];
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  // * Данный метод вынесен отдельно, чтобы можно было переопределять папки
  return _.pGetSourceImageForDrawPictureSized = function(name) {
    return ImageManager.loadPicture(name);
  };
});


// Generated by CoffeeScript 2.6.1



// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var FloatingWindow;
  
    // * Общий класс для всех окон на карте
  /*parameters
      {
          draggable: true,
          closeButton: true,
          moveToCenter: true,
          alwaysOnTop: true,
          header: true
      }
  */
  FloatingWindow = class FloatingWindow extends KDCore.Sprite {
    constructor(mainParent, windowW, windowH, parameters) {
      super();
      this.mainParent = mainParent;
      this.windowW = windowW;
      this.windowH = windowH;
      this.parameters = parameters;
      this._init();
      return;
    }

    static StaticSettings() {
      return {
        draggable: false,
        closeButton: false,
        moveToCenter: false,
        alwaysOnTop: false,
        header: false
      };
    }

    // * Статическое окно с дочерним
    static StaticWindow(parent, sub) {
      var p, w;
      p = KDCore.FloatingWindow.StaticSettings();
      w = new KDCore.FloatingWindow(parent, sub.width, sub.height, p);
      w.setSubWindow(sub);
      w.open();
      return w;
    }

    isActive() {
      return this.visible === true;
    }

    isReady() {
      return this._isReady === true;
    }

    isMouseIn() {
      return this.inPosition(TouchInput);
    }

    isOpen() {
      return this.isActive();
    }

    // * Дочернее окно (если есть)
    sub() {
      return this._subw;
    }

    setOnReadyHandler(_readyHandler) {
      this._readyHandler = _readyHandler;
      if ((this._readyHandler != null) && this._isReady === true) {
        return this._readyHandler();
      }
    }

    isDraggable() {
      return this._isDraggable === true && (this._headerSpr != null) && this._headerSpr.visible === true && this.isOpen();
    }

    setCloseHandler(_closeHandler) {
      this._closeHandler = _closeHandler;
    }

    callCloseHandler() {
      if (this._closeHandler != null) {
        return this._closeHandler();
      }
    }

    setDraggingHandler(_dragHandler) {
      this._dragHandler = _dragHandler;
    }

    setDragEndHandler(_dragEndHandler) {
      this._dragEndHandler = _dragEndHandler;
    }

    hideHeader() {} //TODO:

    hideCloseButton() {} //TODO:

    
      // * Сдвиг заголовка по X, чтобы рамку не задевал
    headerMarginX() {
      return 2;
    }

    // * Сдвиг заголовка по Y, чтобы рамку не задевал
    headerMarginY() {
      return 0;
    }

    // * Стандартная позиция кнопки "закрыть"
    closeButtonPosition() {
      return {
        x: this.width - 24,
        y: 4
      };
    }

    open() {
      if (this.isOpen()) {
        return;
      }
      this._open();
      this._afterOpen();
    }

    close() {
      if (!this.isOpen()) {
        return;
      }
      this._close();
      this._afterClose();
    }

    rootImageFolder() {
      return "Alpha/Windows";
    }

    update() {
      super.update();
      this._updateMouseCheckThread();
      this._updateDragging();
    }

    // * Добавить спрайт на специальный слой контента
    addContent(sprite) {
      return this._contentLayer.addChild(sprite);
    }

    // * Добавить дочернее окно
    setSubWindow(w) {
      this._subw = w;
      this.addContent(w);
    }

    destroy() {
      this._close();
      return Sprite.prototype.destroy.call(this);
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = FloatingWindow.prototype;
    _._init = function() {
      var ref;
      // * Окно всегда закрыто
      this.visible = false;
      // * Контент прогрузился?
      this._isReady = false;
      this._applyParameters();
      if (this._isAlwaysOnTop === false) {
        // * Если не всегда поверх окон, то добавляем сразу к родителю (один раз)
        if ((ref = this.mainParent) != null) {
          ref.addChild(this);
        }
      }
      this._initFloatingSystem();
      this._createLayers();
      this._loadWindowFrame();
    };
    // * Тут ничего не создавать, не двигать, так как
    // * конент создаётся Async, см. метод _createCustomElements
    _._applyParameters = function() {
      var p;
      this._applyDefaults();
      if (this.parameters == null) {
        return;
      }
      p = this.parameters;
      if (p.draggable != null) {
        this._isDraggable = p.draggable;
      }
      if (p.moveToCenter != null) {
        this._isMoveToCenter = p.moveToCenter;
      }
      if (p.header != null) {
        this._isHeaderVisible = p.header;
      }
      if (p.closeButton != null) {
        this._isHaveCloseButton = p.closeButton;
      }
      if (p.alwaysOnTop != null) {
        this._isAlwaysOnTop = p.alwaysOnTop;
      }
    };
    _._applyDefaults = function() {
      // * Окно можно перетаскивать мышкой (по умолчанию - да)
      this._isDraggable = true;
      this._isMoveToCenter = true;
      this._isHeaderVisible = true;
      this._isHaveCloseButton = true;
      this._isAlwaysOnTop = true;
    };
    _._initFloatingSystem = function() {
      if ($gameTemp._floatingWindows == null) {
        // * Создаём массив окон, он нужен для правильного
        // закрытия окон (по очереди) и перемещения drag and drop
        // с учётом верхнего окна
        $gameTemp._floatingWindows = [];
      }
      // * Вспомогательная переменная, чтобы не вызывать методы каждый кадр
      this._mouseIn = false;
      // * Тоже вспомогательная переменная
      this._dragging = false;
    };
    _._moveToStartPosition = function() {
      if (this._isMoveToCenter === true) {
        return this.moveToCenter(Graphics.width / 2, Graphics.height / 2);
      }
    };
    _._closeButtonClick = function() {
      // * При исчезании, кнопка не успевает себя "удалить"
      $gameTemp.kdButtonUnderMouse = null;
      this.callCloseHandler();
      return this.close();
    };
    (function() {      // * DRAGGING
      // -----------------------------------------------------------------------
      _._updateDragging = function() {
        if (!this.isDraggable()) {
          return;
        }
        // * Если мы уже двигаем окно, но мышка вышла за границы, то можно дальше двигать
        // * Только если мышка не в окне и не двигали ранее, то не проверяем
        if (this._mouseIn === false && this._dragging === false) {
          return;
        }
        // * Если существует объект который сейчас dragging
        if ($gameTemp.pkdDraggableInstance != null) {
          // * Если этот объект не этот объект, то выходим из метода
          if ($gameTemp.pkdDraggableInstance !== this) {
            return;
          }
        }
        if (TouchInput.isLongPressed()) {
          if (this._dragging === false) {
            this._onDragStart();
          } else {
            this._onDragging();
          }
        } else {
          this._stopDragging();
        }
      };
      _._onDragStart = function() {
        // * Проверка, в области Header или нет
        if (!this._isMouseInHeader()) {
          return;
        }
        // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
        this.opacity = 200;
        this._deltaXY = this.getDeltaXY();
        this._dragging = true;
        // * Устанавливаем глобальную ссылку на объект перемещения
        $gameTemp.pkdDraggableInstance = this;
      };
      _.getDeltaXY = function() {
        var p;
        p = new KDCore.Point(this.x, this.y);
        return p.delta(TouchInput);
      };
      _._onDragging = function() {
        // * Защита от перетаскивания за края экрана
        if (!this._isNewMousePositionOnScreen()) {
          return;
        }
        this.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
        if (this._dragHandler != null) {
          return this._dragHandler();
        }
      };
      _._stopDragging = function() {
        if (this._dragging === true) {
          this._dragging = false;
          this.opacity = 255;
          this._clearDraggableGlocalInstance();
          if (this._dragEndHandler != null) {
            this._dragEndHandler();
          }
        }
      };
      // * Освобождаем глобальную ссылку
      _._clearDraggableGlocalInstance = function() {
        if ($gameTemp.pkdDraggableInstance === this) {
          return $gameTemp.pkdDraggableInstance = null;
        }
      };
      _._isMouseInHeader = function() {
        if (this._headerSpr == null) {
          return false;
        }
        return this._headerSpr.isContainsPoint(TouchInput);
      };
      _._isNewMousePositionOnScreen = function() {
        return KDCore.Utils.isPointInScreen(TouchInput, 10);
      };
    })();
    (function() {      // -----------------------------------------------------------------------

      // * CREATE ELEMENTS
      // -----------------------------------------------------------------------
      
      // * Слои нужны, так как изображения загружаються асинхронно
      _._createLayers = function() {
        this._mainLayer = new Sprite();
        this._contentLayer = new Sprite();
        this._headerLayer = new Sprite();
        this._closeButtonLayer = new Sprite();
        this.addChild(this._mainLayer);
        this.addChild(this._contentLayer);
        this.addChild(this._headerLayer);
        this.addChild(this._closeButtonLayer);
      };
      _._loadWindowFrame = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "windowFrame").then(this._createWindow.bind(this));
      };
      _._createWindow = function(frameImage) {
        this.bitmap = new Bitmap(this.windowW, this.windowH);
        this.wFrame = new KDCore.Sprite_TilingFrame(this.windowW, this.windowH, frameImage);
        this._mainLayer.addChild(this.wFrame);
        this._createParts();
      };
      _._createParts = function() {
        this._loadHeader();
        if (this._isHaveCloseButton === true) {
          this._createCloseButton();
        }
        this._moveToStartPosition();
        this._createCustomElements();
        // * Окно готово
        this._isReady = true;
        if (this._readyHandler != null) {
          this._readyHandler();
        }
      };
      _._loadHeader = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "headerLine").then(this._createHeader.bind(this));
      };
      _._createHeader = function(headerLineImage) {
        var w;
        w = this.windowW - (this.headerMarginX() * 2);
        this._headerSpr = new KDCore.Sprite_TilingLine(w, headerLineImage.height, headerLineImage);
        this._headerSpr.x = this.headerMarginX();
        this._headerSpr.y = this.headerMarginY();
        this._headerLayer.addChild(this._headerSpr);
        if (this._isHeaderVisible === true) {
          // * Сдвигаем контент, чтобы было начало под заголовком
          this._contentLayer.y += headerLineImage.height + this.headerMarginY();
        } else {
          this._headerSpr.visible = false;
        }
      };
      _._createCloseButton = function() {
        this._closeButton = new KDCore.ButtonM("windowCloseButton", false, this.rootImageFolder());
        this._closeButtonLayer.addChild(this._closeButton);
        this._closeButton.move(this.closeButtonPosition());
        this._closeButton.addClickHandler(this._closeButtonClick.bind(this));
      };
      //%[FOR CHILDRENS]
      // * Наследники создают свои элементы в этом методе
      // * Есть специальный метод addContent()
      _._createCustomElements = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * MOUSE
      // -----------------------------------------------------------------------
      
      // * Определение если мышка в области окна
      //TODO: Есть проблема при открытии окна сразу под курсором
      _._registerMouseInOut = function() {
        if (!this.isOpen()) {
          return;
        }
        if (this.isMouseIn()) {
          if (this._mouseIn === false) {
            this._mouseIn = true;
            this._onMouseIn();
          }
        } else {
          if (this._mouseIn === true) {
            this._mouseIn = false;
            this._onMouseOut();
          }
        }
      };
      // * Используется похожая система что и в KDCore.ButtonM
      _._onMouseIn = function() {
        return $gameTemp.floatingWindowUnderMouse = this;
      };
      _._onMouseOut = function() {
        if ($gameTemp.floatingWindowUnderMouse === this) {
          return $gameTemp.floatingWindowUnderMouse = null;
        }
      };
      // * Будем проверять мышка ли в окне только при открытом окне
      _._createMouseCheckThread = function() {
        this._mouseCheckThread = new KDCore.TimedUpdate(1, this._registerMouseInOut.bind(this));
        this._updateMouseCheckThread = () => {
          return this._mouseCheckThread.update();
        };
        return this._mouseCheckThread.call();
      };
      // * Когда окно закрывается, никаких проверок, обнуляем метод
      _._destroyMouseCheckThread = function() {
        this._mouseCheckThread = null;
        return this._updateMouseCheckThread = function() {};
      };
      //?DYNAMIC
      _._updateMouseCheckThread = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * OPEN OR CLOSE
      // -----------------------------------------------------------------------
      _._open = function() {
        var ref, ref1;
        this.visible = true;
        if ((ref = $gameTemp._floatingWindows) != null) {
          ref.push(this);
        }
        if (this._isAlwaysOnTop === true) {
          // * Окно, которое открывается, всегда снова выше остальных (опция)
          if ((ref1 = this.mainParent) != null) {
            ref1.addChild(this);
          }
        }
        return this._createMouseCheckThread();
      };
      _._afterOpen = function() {}; // * EMPTY
      _._close = function() {
        this.visible = false;
        if (this._isAlwaysOnTop === true) {
          this.removeFromParent();
        }
        this._clearDraggableGlocalInstance();
        $gameTemp._floatingWindows.delete(this);
        this._onMouseOut();
        return this._destroyMouseCheckThread();
      };
      _._afterClose = function() {}; // * EMPTY
    })();
  })();
  (function() {    // ■ END PRIVATE.coffee
    //---------------------------------------------------------------------------

    // * Если окно под курсором, нельзя нажимать на карте для движения игрока
    // -----------------------------------------------------------------------
    (function() {      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ Scene_Map.coffee
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var ALIAS__isAnyButtonPressed, ALIAS__processMapTouch, _;
      
      //@[DEFINES]
      _ = Scene_Map.prototype;
      if (KDCore.isMZ()) {
        //@[ALIAS]
        ALIAS__isAnyButtonPressed = _.isAnyButtonPressed;
        _.isAnyButtonPressed = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return true;
          } else {
            return ALIAS__isAnyButtonPressed.call(this);
          }
        };
      } else {
        //@[ALIAS]
        ALIAS__processMapTouch = _.processMapTouch;
        _.processMapTouch = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return;
          }
          return ALIAS__processMapTouch.call(this);
        };
      }
    })();
  })();
  //@[EXTEND]
  // ■ END Scene_Map.coffee
  //---------------------------------------------------------------------------
  return KDCore.FloatingWindow = FloatingWindow;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var HUI;
  // * Html UI Manager
  // * Набор инструментов для работы с HTML элементами интерфейса
  HUI = function() {};
  (function() {
    var _;
    //@[DEFINES]
    _ = HUI;
    _.init = function() {
      // * Данный набор инструментов могут использовать многие плагины, поэтому проверка
      if (this.isInited()) {
        return;
      }
      this._createMainParentInHtml();
      this._extendGraphicsClass();
      this.refresh();
    };
    // * Был ли создан (инициализирован) основной элемент
    _.isInited = function() {
      return this.parent() != null;
    };
    // * Основной элемент родитель для всех элементов UI
    _.parent = function() {
      return this._parent;
    };
    _.refresh = function() {
      if (!this.isInited()) {
        return;
      }
      Graphics._centerElement(this._parent);
      this._parent.style.zIndex = 2;
      this._parent.style.width = Graphics._canvas.style.width;
      this._parent.style.height = Graphics._canvas.style.height;
    };
    _.initReactComponents = function(withBabel = true) {
      var e;
      try {
        if (withBabel) {
          this._loadBabel();
        }
        return this._loadReact();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadBabel = function() {
      var e;
      try {
        return this._loadScript('https://unpkg.com/babel-standalone@6/babel.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadReact = function() {
      var e;
      try {
        this._loadScript('https://unpkg.com/react@18/umd/react.production.min.js');
        return this._loadScript('https://unpkg.com/react-dom@18/umd/react-dom.production.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadScript = function(src, isReact = false) {
      var e, script;
      try {
        script = document.createElement("script");
        if (isReact === true) {
          script.type = "text/babel";
        } else {
          script.type = "text/javascript";
          script.crossorigin = true;
        }
        script.src = src;
        script.async = false;
        script.defer = true;
        script.onerror = function(e) {
          KDCore.warning('HUI: Failed to load script');
          return KDCore.warning(e);
        };
        document.body.appendChild(script);
        if (isReact === true) {
          return window.dispatchEvent(new Event('DOMContentLoaded'));
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.loadReactComponent = function(componentName, folder = 'data/uiComponents') {
      var e, src;
      try {
        src = folder + "/" + componentName + ".js";
        return this._loadScript(src, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addReactComponent = function(componentName, props, uniqueId = null) {
      var e, element, reactElement, root;
      try {
        if (window[componentName] == null) {
          KDCore.warning("Cant find " + componentName + ", make sure to load it first");
          return null;
        }
        if (uniqueId == null) {
          uniqueId = componentName;
        }
        // * Создаём отдельный DIV для каждого элемента (чтобы можно было удалять)
        element = this._getElementForReactComponent(uniqueId);
        root = ReactDOM.createRoot(element);
        reactElement = React.createElement(window[componentName], props);
        root.render(reactElement);
        return KDCore.HUI.getElement(uniqueId);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    // * Simple React Component (without JSX!)
    _.loadReactComponentFromFile = function(filename, props, uniqueId, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".js";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element;
          eval(xhr.responseText);
          element = KDCore.HUI.addReactComponent(filename, props, uniqueId);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getElementForReactComponent = function(componentId) {
      var e, element;
      try {
        this.removeElementById(componentId);
        element = this.addElement(componentId, '', null);
        return element;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _.loadElementFromFile = function(filename, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".html";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element, htmlElementText;
          // * Хотел отдельные данные передавать и заменять в HTML текст
          // * Но если у нас есть React компоненты, то это не надо
          //htmlElementText = @convertDataKeys(xhr.responseText, dataKeys)
          htmlElementText = xhr.responseText;
          element = KDCore.HUI.addElement(filename, htmlElementText, null);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCSS = function(name, folder = "css") {
      var head;
      if (!this.isInited()) {
        this.init();
      }
      head = document.getElementsByTagName("head")[0];
      if (head != null) {
        head.insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"$0/$1.css\" />".replace("$0", folder).replace("$1", name));
      }
    };
    _.addElement = function(id, html, classes = null) {
      var cls, element, i, len;
      if (!this.isInited()) {
        this.init();
      }
      element = document.createElement("div");
      element.id = id;
      element.innerHTML = html;
      if (classes != null) {
        for (i = 0, len = classes.length; i < len; i++) {
          cls = classes[i];
          element.classList.add(cls);
        }
      }
      this._parent.appendChild(element);
      return element;
    };
    _.appendElement = function(element) {
      var e;
      try {
        return this._parent.appendChild(element);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Может быть NULL
    _.getElement = function(id) {
      return document.getElementById(id);
    };
    _.removeElement = function(element) {
      if (element == null) {
        return;
      }
      if (KDCore.SDK.isString(element)) {
        this.removeElementById(element);
      } else {
        this.removeElementById(element.id);
      }
    };
    _.removeElementById = function(elementId) {
      var element;
      if (!this.isInited()) {
        return;
      }
      element = this.getElement(elementId);
      if (element != null) {
        this._parent.removeChild(element);
      }
    };
    // * PRIVATE ------------------------------------------------------------------
    _._createMainParentInHtml = function() {
      this._parent = document.createElement("div");
      this._parent.id = "KDCoreMain";
      document.body.appendChild(this._parent);
    };
    _._extendGraphicsClass = function() {
      var ALIAS___updateCanvas;
      //@[ALIAS]
      ALIAS___updateCanvas = Graphics._updateCanvas;
      Graphics._updateCanvas = function() {
        ALIAS___updateCanvas.call(this);
        return KDCore.HUI.refresh();
      };
    };
  })();
  //@[EXTEND]
  return KDCore.HUI = HUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___onMouseUp, ALIAS___onRightButtonDown, ALIAS__clear, ALIAS__update, _;
  // * Right mouse pressed
  // * Определение когда правая (вторая) кнопка мыши зажата и удерживается

  //@[DEFINES]
  _ = TouchInput;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this._kdMousePressed2 = false;
    this._kdPressedTime2 = 0;
  };
  //@[ALIAS]
  ALIAS___onRightButtonDown = _._onRightButtonDown;
  _._onRightButtonDown = function(event) {
    var check;
    ALIAS___onRightButtonDown.call(this, event);
    // * Это значит что ALIAS метод прошёл (верные X и Y в Canvas)
    if (KDCore.isMZ()) {
      check = this._newState.cancelled === true;
    } else {
      check = this._events.cancelled === true;
    }
    if (check === true) {
      this._kdMousePressed2 = true;
      this._kdPressedTime2 = 0;
    }
  };
  //@[ALIAS]
  ALIAS___onMouseUp = _._onMouseUp;
  _._onMouseUp = function(event) {
    ALIAS___onMouseUp.call(this, event);
    if (event.button === 2) {
      this._kdMousePressed2 = false;
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this.kdIsPressed2()) {
      return this._kdPressedTime2++;
    }
  };
  //?[NEW]
  return _.kdIsPressed2 = function() {
    return this._kdMousePressed2 === true;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Методы из RPG Maker MZ которых нет в RPG Maker MV
  if (KDCore.isMZ()) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Scene_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Scene_Base.prototype;
    _.calcWindowHeight = function(numLines, selectable) {
      if (selectable === true) {
        return Window_Selectable.prototype.fittingHeight(numLines);
      } else {
        return Window_Base.prototype.fittingHeight(numLines);
      }
    };
  })();
  (function() {    // ■ END Scene_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    _.itemLineRect = function(index) {
      return this.itemRect(index);
    };
  })();
  (function() {    // ■ END Window_Selectable.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__initialize, ALIAS__processEscapeCharacter, _;
    //@[DEFINES]
    _ = Window_Base.prototype;
    // * Чтоб можно было Rectangle принимать в конструктор
    //@[ALIAS]
    ALIAS__initialize = _.initialize;
    _.initialize = function(x, y, w, h) {
      if (x instanceof PIXI.Rectangle || x instanceof Rectangle) {
        return ALIAS__initialize.call(this, x.x, x.y, x.width, x.height);
      } else {
        return ALIAS__initialize.call(this, ...arguments);
      }
    };
    
    // * В MZ используется FS для изменения размера шрифта в тексте
    //@[ALIAS]
    ALIAS__processEscapeCharacter = _.processEscapeCharacter;
    _.processEscapeCharacter = function(code, textState) {
      if (code === "FS") {
        this.contents.fontSize = this.obtainEscapeParam(textState);
      } else {
        ALIAS__processEscapeCharacter.call(this, code, textState);
      }
    };
  })();
  (function() {    // ■ END Window_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Spriteset_Map.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Spriteset_Map.prototype;
    _.findTargetSprite = function(target) {
      return this._characterSprites.find(function(sprite) {
        return sprite.checkCharacter(target);
      });
    };
  })();
  return (function() {    // ■ END Spriteset_Map.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Sprite_Character.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Sprite_Character.prototype;
    _.checkCharacter = function(character) {
      return this._character === character;
    };
  })();
});

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_SM_processMapTouch, alias_TIOMM;
  //?SMouse better alternative
  if (KDCore.isMZ()) {
    return;
  }
  // * Для ButtonM
  //@[ALIAS]
  alias_SM_processMapTouch = Scene_Map.prototype.processMapTouch;
  Scene_Map.prototype.processMapTouch = function() {
    if ($gameTemp.kdButtonUnderMouse != null) {
      if ($gameTemp.kdButtonUnderMouse.parent == null) {
        return $gameTemp.kdButtonUnderMouse = null;
      } else {

      }
    } else {
      return alias_SM_processMapTouch.call(this);
    }
  };
  //@[ALIAS]
  alias_TIOMM = TouchInput._onMouseMove;
  TouchInput._onMouseMove = function(event) {
    var x, y;
    alias_TIOMM.call(this, event);
    x = Graphics.pageToCanvasX(event.pageX);
    y = Graphics.pageToCanvasY(event.pageY);
    if (Graphics.isInsideCanvas(x, y)) {
      return this._onHover(x, y);
    }
  };
  
  //?NEW, from MZ
  return TouchInput._onHover = function(_x, _y) {
    this._x = _x;
    this._y = _y;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__clear, ALIAS__update, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Input;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    return this._virtualButton = null;
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this._virtualButton == null) {
      return;
    }
    this._latestButton = this._virtualButton;
    this._pressedTime = 0;
    return this._virtualButton = null;
  };
  return _.virtualClick = function(buttonName) {
    return this._virtualButton = buttonName;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___startLoading, _;
  // * В версии RPG Maker MZ 1.5.0 появился баг что картинки не успевают прогрузится
  // * Данный фикс, возвращает старое поведение
  if (!KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Bitmap.prototype;
  //@[ALIAS]
  ALIAS___startLoading = _._startLoading;
  return _._startLoading = function() {
    if (Utils.hasEncryptedImages()) {
      ALIAS___startLoading.call(this, ...arguments);
    } else {
      // * Это из RPG Maker MZ до версии 1.5
      this._image = new Image();
      this._image.onload = this._onLoad.bind(this);
      this._image.onerror = this._onError.bind(this);
      this._destroyCanvas();
      this._loadingState = "loading";
      this._image.src = this._url;
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Builder;
  Builder = {};
  (function() {    //NUI 1.0
    //rev 30.04.24
    var _;
    //@[DEFINES]
    _ = Builder;
    _.Factory = function(jsonCollection, owner, exRefresh = 0) {
      var e, item, items, j, key, len, value;
      try {
        if (jsonCollection == null) {
          return;
        }
        items = [];
        for (key in jsonCollection) {
          value = jsonCollection[key];
          item = KDCore.UI.Builder.Make(value, owner);
          if (item != null) {
            items.push(item); // * Skip not UI elements definitions
          }
        }
//owner[key] = item if owner?
        for (j = 0, len = items.length; j < len; j++) {
          item = items[j];
          item.refreshBindings(owner, true);
        }
        // * Обновить привязки через MS ещё раз
        if (exRefresh > 0) {
          setTimeout((function() {
            var e, k, len1, results;
            try {
              results = [];
              for (k = 0, len1 = items.length; k < len1; k++) {
                item = items[k];
                results.push(item.refreshBindings(owner, true));
              }
              return results;
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }), exRefresh);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return items;
    };
    _.Make = function(jsonStructure, owner = null, parent = null) {
      var bindings, child, childrens, dataObject, e, item, j, len, parameters, shortcutData, subItem, type, value;
      try {
        if (jsonStructure == null) {
          return null;
        }
        if (jsonStructure.type == null) {
          return null;
        }
        if (jsonStructure.shortcut != null) {
          shortcutData = KDCore.UI.Builder.ConvertShortcut(jsonStructure.shortcut);
          ({type, parameters} = shortcutData);
        } else {
          ({type, parameters} = jsonStructure);
        }
        if (typeof parameters === "string") {
          parameters = KDCore.UI.Builder.ConvertShortcut(parameters);
        }
        if (jsonStructure.createIf != null) {
          value = this._convertBindingValue(owner, jsonStructure.createIf);
          if (value !== true) {
            return null;
          }
        }
        item = KDCore.UI.Builder.CreateItemByType(type, parameters);
        if (item == null) {
          return null;
        }
        ({dataObject, bindings, childrens} = jsonStructure);
        // * Parent нужен чтобы работали настройки положения (center, %) и т.д.
        if (parent != null) {
          parent.addChild(item);
        } else {
          // * Owner - это не только главный родитель, но и к кому мы
          // * прописываем все поля по ID
          if (owner != null) {
            owner.addChild(item);
          }
        }
        // * Сохраняем схему (но только этого элемента, без "детей")
        item.uiJsonScheme = Object.assign({}, jsonStructure, {
          childrens: []
        });
        // * Константы доступны не только у каждого элемента в схеме, но и у общего родителя
        if ((jsonStructure.constants != null) && (owner != null)) {
          if (owner.uiConstants == null) {
            owner.uiConstants = {};
          }
          owner.uiConstants = Object.assign(owner.uiConstants, jsonStructure.constants);
        }
        if (bindings != null) {
          if (dataObject == null) {
            dataObject = owner;
          }
          KDCore.UI.Builder.ApplyBindings(item, bindings, dataObject);
        }
        try {
          if (jsonStructure.effects != null) {
            KDCore.UI.Builder.ApplyEffects(item, jsonStructure.effects);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        try {
          if (jsonStructure.animations != null) {
            KDCore.UI.Builder.ApplyAnimations(item, jsonStructure.animations);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        if ((childrens != null) && childrens.length > 0) {
          for (j = 0, len = childrens.length; j < len; j++) {
            child = childrens[j];
            // * Дети всегда имеют родителя - этот элемент (а не owner)
            subItem = KDCore.UI.Builder.Make(child, owner, item);
          }
        }
        if (jsonStructure.id != null) {
          item.id = jsonStructure.id;
          if (owner != null) {
            owner[jsonStructure.id] = item;
          }
        }
        if (jsonStructure.parent != null) {
          parent = jsonStructure.parent;
          if ((owner != null) && (owner[parent] != null)) {
            owner[parent].addChild(item);
          }
        }
        // * Update bindings for recalculate Positions and Sizes
        if (bindings != null) {
          KDCore.UI.Builder.RefreshBindings(item, dataObject);
        }
        if (jsonStructure.position != null) {
          item.setPosition(jsonStructure.position);
        }
        return item;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    // * dataObject может быть Null, если нет binding c $
    _.ApplyBindings = function(uiElement, bindings, dataObject) {
      var dataBindings, e, field, value;
      try {
        if (uiElement == null) {
          return;
        }
        if (bindings == null) {
          return;
        }
        if (uiElement.dataBindings == null) {
          return;
        }
        dataBindings = uiElement.dataBindings();
        if (dataBindings == null) {
          return;
        }
        for (field in dataBindings) {
          if (bindings[field] != null) {
            value = this.ConvertBindingValue(dataObject, bindings[field], uiElement);
            dataBindings[field].call(uiElement, value);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.RefreshBindings = function(uiElement, dataObject) {
      var bindings, e;
      try {
        if (uiElement == null) {
          return;
        }
        if (uiElement.uiJsonScheme == null) {
          return;
        }
        ({bindings} = uiElement.uiJsonScheme);
        if (bindings == null) {
          return;
        }
        KDCore.UI.Builder.ApplyBindings(uiElement, bindings, dataObject);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ApplyEffects = function(uiElement, effects) {
      var alpha, color, e, ef, efData, effectsArray, j, len, quality, thickness;
      try {
        if (uiElement == null) {
          return;
        }
        if (effects == null) {
          return;
        }
        //TODO: Преобразование цвета!
        effectsArray = [];
        for (j = 0, len = effects.length; j < len; j++) {
          ef = effects[j];
          if (ef == null) {
            continue;
          }
          efData = KDCore.UI.Builder.ConvertShortcut(ef);
          if ((efData.shadow != null) && KDCore.isMZ()) {
            effectsArray.push(new PIXI.filters.DropShadowFilter(efData));
          }
          if ((efData.outline != null) && KDCore.isMZ()) {
            ({thickness, color, quality} = efData);
            if (thickness == null) {
              thickness = 1;
            }
            if (color == null) {
              color = 0xffffff;
            }
            effectsArray.push(new PIXI.filters.OutlineFilter(thickness, color, quality));
          }
          if (efData.glow != null) {
            effectsArray.push(new PIXI.filters.GlowFilter(efData));
          }
          if (efData.tint != null) {
            ({color, alpha} = efData);
            if (alpha == null) {
              alpha = 0.5;
            }
            effectsArray.push(new PIXI.filters.ColorOverlayFilter(color, alpha));
          }
        }
        if (effectsArray.length > 0) {
          return uiElement.filters = effectsArray;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ApplyAnimations = function(uiElement, animations) {
      var a, e, j, len;
      try {
        if (uiElement == null) {
          return;
        }
        if (animations == null) {
          return;
        }
        if (uiElement.addAnimationRule == null) {
          return;
        }
        if (animations.length === 0) {
          return;
        }
        for (j = 0, len = animations.length; j < len; j++) {
          a = animations[j];
          if (typeof a === 'string') {
            a = KDCore.UI.Builder.ConvertShortcut(a);
          }
          if (a != null) {
            uiElement.addAnimationRule(a);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ConvertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e, i, j, ref, text, value;
      try {
        if (bindingValue instanceof Array) {
          text = bindingValue[0];
          for (i = j = 1, ref = bindingValue.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
            if (bindingValue[i] == null) {
              continue;
            }
            value = this.ConvertBindingValue(sourceObj, bindingValue[i], element);
            if (value != null) {
              text = text.replace("%" + i, value);
            }
          }
          return text;
        } else {
          return this._convertBindingValue(sourceObj, bindingValue, element);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _.CreateItemByType = function(type, initialParameters = {}) {
      var e;
      try {
        // * SHOULD HAVE: dataBingins(size), realWidth, realHeight
        switch (type) {
          case 'button':
            return new KDCore.Sprite_SButton(initialParameters);
          case 'text':
            return new KDCore.UI.Sprite_UIText2(initialParameters);
          case 'plane':
            return new KDCore.Sprite_Plane(initialParameters);
          case 'rect':
            return new KDCore.Sprite_BaseRect(initialParameters);
          case 'image':
            return new KDCore.Sprite_Image(initialParameters);
          case 'legacyText':
            return new KDCore.UI.Sprite_UIText(initialParameters);
          case 'textExt':
            return new KDCore.UI.Sprite_UITextEx(initialParameters);
          case 'group':
            return new KDCore.Sprite_Group(initialParameters);
          case 'legacyButton':
            return new KDCore.Sprite_ImgButton(initialParameters);
          case 'circle':
            return new KDCore.Sprite_BaseCircle(initialParameters);
          case 'gauge':
            return new KDCore.Sprite_Gauge(initialParameters);
          case 'list':
            return new KDCore.Sprite_ItemsListN(initialParameters);
          case 'horList':
            return new KDCore.Sprite_ItemsListNHor(initialParameters);
          case 'screen':
            /*screenGroup = {
                "type": "group",
                "bindings": {
                    "width": "@Graphics.width",
                    "height": "@Graphics.height"
                }
            }
            return KDCore.UI.Builder.Make(screenGroup)*/
            return new KDCore.Sprite_Screen(initialParameters);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _._convertValueDataFromShortcut = function(valueData) {
      var data, e, item, j, len, n, outerItems, p, v;
      try {
        if (valueData.contains("|")) {
          data = {};
          outerItems = valueData.split("|");
          for (j = 0, len = outerItems.length; j < len; j++) {
            item = outerItems[j];
            p = item.split("=");
            n = p.shift();
            v = p;
            if (v.length === 0) {
              v = true;
            } else {
              if (v.length === 1) {
                v = v[0];
                if (isFinite(v)) {
                  v = Number(v);
                }
              } else {
                v = KDCore.UI.Builder._convertValueDataFromShortcut(v.join("="));
              }
            }
            data[n] = v;
          }
          return data;
        }
        data = KDCore.UI.Builder.ConvertShortcut(valueData, ",", "=");
        return data;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ConvertShortcut = function(shortcut, outerSep = ";", innerSep = ":") {
      var config, e, j, len, pair, value, valueData, valueName, values;
      try {
        config = {};
        values = shortcut.split(outerSep);
//console.log(values)
        for (j = 0, len = values.length; j < len; j++) {
          value = values[j];
          if (!String.any(value)) {
            continue;
          }
          pair = value.split(innerSep);
          valueName = pair[0];
          valueData = pair[1];
          if (String.any(valueData) && valueData.contains("=")) {
            valueData = KDCore.UI.Builder._convertValueDataFromShortcut(valueData);
          } else {
            if (valueData == null) {
              valueData = true;
            } else {
              if (isFinite(valueData)) {
                valueData = Number(valueData);
              }
            }
          }
          config[valueName] = valueData;
        }
        //console.log(valueName, valueData)
        return config;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var captured, dpValue, e, evalString, r, result, resultValue;
      try {
        if (typeof bindingValue === 'string') {
          // * Replace all HDP
          if (bindingValue.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              bindingValue = bindingValue.replace(/(\d+)hdp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * Replace all DP
          if (bindingValue.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              bindingValue = bindingValue.replace(/(\d+)dp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * FORCE EVAL
          if (bindingValue.contains("@") && bindingValue[0] === "@") {
            evalString = bindingValue.replace("@", "");
            return eval(evalString);
          }
          // * EXTRA $ calculations
          if (bindingValue.contains("~") && bindingValue[0] === "~") { // * POST EVAL
            if (bindingValue.contains("$")) {
              r = new RegExp("(\\$[\\w+.]*)", "g");
              result = r.exec(bindingValue);
              if (result != null) {
                //console.log(result)
                captured = result[1];
                if (String.any(captured)) {
                  resultValue = this._convertSingleBindingValue$(sourceObj, captured, element);
                  if (resultValue == null) {
                    return null;
                  }
                  if (typeof resultValue === 'function') {
                    return resultValue;
                  } else {
                    if (String.any(resultValue)) {
                      bindingValue = bindingValue.replace(captured, resultValue);
                      return this._convertBindingValue(sourceObj, bindingValue, element);
                    } else {
                      return null;
                    }
                  }
                }
              }
            } else {
              evalString = bindingValue.replace("~", "");
              return eval(evalString);
            }
          }
          
          // * Default old style simple $
          if (bindingValue.contains("$")) {
            return this._convertSingleBindingValue$(...arguments);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _._convertSingleBindingValue$ = function(sourceObj, bindingValue, element) {
      var e, field, parts, subData, subField;
      try {
        field = bindingValue.replace("$", "");
        if (field.contains(".")) { //$parent.width
          parts = field.split(".");
          // * Только одно вхождение
          field = parts[0];
          subField = parts[1];
          if (!String.any(field) && String.any(subField)) {
            if (element != null) {
              return this._convertSingleBindingValue$(element, "$" + subField, element);
            } else {
              return null;
            }
          }
          if (String.any(field) && !String.any(subField)) {
            return this._convertSingleBindingValue$(sourceObj, "$" + field, element);
          }
          if (sourceObj != null) {
            if (typeof sourceObj[field] === 'function') {
              subData = sourceObj[field]();
            } else {
              subData = sourceObj[field];
            }
            return this._convertSingleBindingValue$(subData, "$" + subField, element);
          } else {
            return null;
          }
        } else {
          if ((sourceObj != null) && (sourceObj[field] != null)) {
            if (typeof sourceObj[field] === 'function') {
              return sourceObj[field]();
            } else {
              return sourceObj[field];
            }
          } else {
            return null; // * We can't find value
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  //@[EXTEND]
  KDCore.UI = KDCore.UI || {};
  return KDCore.UI.Builder = Builder;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_WBDTEX_KDCore29122021;
  // * <center>, для RPG Maker MZ и если нету Visu Message Core
  if (KDCore.isMZ()) {
    alias_WBDTEX_KDCore29122021 = Window_Base.prototype.drawTextEx;
    Window_Base.prototype.drawTextEx = function(text, x, y, width) {
      var e, newText;
      try {
        if (Imported.VisuMZ_1_MessageCore !== true) { // * В Visu уже есть <center>
          if (String.any(text) && text.contains("<center>")) {
            if (text[0] === "<" && text[1] === "c") { // * Должен быть в начале строки
              newText = text.replace("<center>", "");
              return this.drawTextExInCenter(newText, x, y, width);
            }
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return alias_WBDTEX_KDCore29122021.call(this, ...arguments);
    };
  }
  //?NEW
  Window_Base.prototype.drawTextExInCenter = function(text, x, y, width, height) {
    var e, newX, newY, textSize;
    try {
      if (KDCore.isMV()) { // * В MV нет поддержки данного метода
        this.drawTextEx(...arguments);
        return;
      }
      textSize = this.textSizeEx(text);
      newX = x + width / 2 - textSize.width / 2;
      if ((height != null) && height > 0) {
        newY = y + height / 2 - textSize.height / 2;
      } else {
        newY = y;
      }
      return this.drawTextEx(text, newX, newY, width);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.drawTextEx(text, x, y, width);
    }
  };
  //?NEW
  Window_Base.prototype.drawTextExWithWordWrap = function(text, x, y, width, maxLines) {
    var maxWidth, wrappedText;
    this.drawTextEx("", 0, 0, 100);
    maxWidth = this.contentsWidth();
    wrappedText = Window_Message.prototype.pWordWrap.call(this, text, width || maxWidth, maxLines);
    return this.drawTextEx(wrappedText, x, y, width);
  };
  //?NEW
  return Window_Message.prototype.pWordWrap = function(text, maxWidth, maxLines) {
    var i, j, k, l, line, lines, newLines, ref, ref1, result, spaceLeft, spaceWidth, wordWidth, wordWidthWithSpace, words;
    lines = text.split('\n');
    maxWidth = maxWidth;
    spaceWidth = this.contents.measureTextWidth(' ');
    result = '';
    newLines = 1;
    for (i = k = 0, ref = lines.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      spaceLeft = maxWidth;
      line = lines[i];
      words = line.split(' ');
      for (j = l = 0, ref1 = words.length; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
        wordWidth = this.contents.measureTextWidth(words[j].replaceAll(/\\C\[\d+\]/g, ""));
        wordWidthWithSpace = wordWidth + spaceWidth;
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            if (maxLines === newLines) {
              return result;
            }
            result += '\n';
            newLines++;
          }
          result += words[j];
          spaceLeft = maxWidth - wordWidth;
          if (j === 0 && line.match(/\\n\w*\s*<\s*\\n\[\w*\s*\]\s*>*/gi)) {
            spaceLeft += 200;
          }
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += ' ' + words[j];
        }
      }
      if (i < lines.length - 1) {
        result += '\n';
      }
    }
    return result;
  };
});


// Generated by CoffeeScript 2.6.1
// * Последний файл (после всех классов)
// * Загружает библиотеки
var i, len, lib, ref, text;

if (KDCore._requireLoadLibrary === true) {
  ref = KDCore[KDCore._loader];
  for (i = 0, len = ref.length; i < len; i++) {
    lib = ref[i];
    lib();
  }
  KDCore[KDCore._loader] = [];
  text = "%c  KDCore is loaded " + KDCore.Version + " + NUI " + KDCore.nuiVersion;
  console.log(text, 'background: #222; color: #82b2ff');
}

// ==========================================================================
// ==========================================================================

//   END OF PLUGINS CORE LIBRARY
//   (Next code is this plugin code)

// ==========================================================================
// ==========================================================================

//Plugin KDCore builded by PKD PluginBuilder 2.2.1 - 18.06.2024

/**
 *    ____       _   _     _____ _           _ _                _         
 *   |  _ \ __ _| |_| |__ |  ___(_)_ __   __| (_)_ __   __ _   (_)___     
 *   | |_) / _` | __| '_ \| |_  | | '_ \ / _` | | '_ \ / _` |  | / __|    
 *   |  __/ (_| | |_| | | |  _| | | | | | (_| | | | | | (_| |_ | \__ \    
 *   |_|   \__,_|\__|_| |_|_|   |_|_| |_|\__,_|_|_| |_|\__, (_)/ |___/    
 *                                                     |___/ |__/         
 *   https://github.com/qiao/PathFinding.js
 */

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.PF=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports = _dereq_('./lib/heap');

},{"./lib/heap":2}],2:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Heap;
  } else {
    window.Heap = Heap;
  }

}).call(this);

},{}],3:[function(_dereq_,module,exports){
var DiagonalMovement = {
    Always: 1,
    Never: 2,
    IfAtMostOneObstacle: 3,
    OnlyWhenNoObstacles: 4
};

module.exports = DiagonalMovement;
},{}],4:[function(_dereq_,module,exports){
var Node = _dereq_('./Node');
var DiagonalMovement = _dereq_('./DiagonalMovement');

/**
 * The Grid class, which serves as the encapsulation of the layout of the nodes.
 * @constructor
 * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
 * @param {number} height Number of rows of the grid.
 * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
 *     representing the walkable status of the nodes(0 or false for walkable).
 *     If the matrix is not supplied, all the nodes will be walkable.  */
function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}

/**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
Grid.prototype._buildNodes = function(width, height, matrix) {
    var i, j,
        nodes = new Array(height);

    for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
};


Grid.prototype.getNodeAt = function(x, y) {
    return this.nodes[y][x];
};


/**
 * Determine whether the node at the given position is walkable.
 * (Also returns false if the position is outside the grid.)
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @return {boolean} - The walkability of the node.
 */
Grid.prototype.isWalkableAt = function(x, y) {
    return this.isInside(x, y) && this.nodes[y][x].walkable;
};


/**
 * Determine whether the position is inside the grid.
 * XXX: `grid.isInside(x, y)` is wierd to read.
 * It should be `(x, y) is inside grid`, but I failed to find a better
 * name for this method.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
Grid.prototype.isInside = function(x, y) {
    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
};


/**
 * Set whether the node on the given position is walkable.
 * NOTE: throws exception if the coordinate is not inside the grid.
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @param {boolean} walkable - Whether the position is walkable.
 */
Grid.prototype.setWalkableAt = function(x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
};


/**
 * Get the neighbors of the given node.
 *
 *     offsets      diagonalOffsets:
 *  +---+---+---+    +---+---+---+
 *  |   | 0 |   |    | 0 |   | 1 |
 *  +---+---+---+    +---+---+---+
 *  | 3 |   | 1 |    |   |   |   |
 *  +---+---+---+    +---+---+---+
 *  |   | 2 |   |    | 3 |   | 2 |
 *  +---+---+---+    +---+---+---+
 *
 *  When allowDiagonal is true, if offsets[i] is valid, then
 *  diagonalOffsets[i] and
 *  diagonalOffsets[(i + 1) % 4] is valid.
 * @param {Node} node
 * @param {DiagonalMovement} diagonalMovement
 */
Grid.prototype.getNeighbors = function(node, diagonalMovement) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        s0 = false, d0 = false,
        s1 = false, d1 = false,
        s2 = false, d2 = false,
        s3 = false, d3 = false,
        nodes = this.nodes;

    // ↑
    if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
    }
    // →
    if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
    }
    // ↓
    if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
    }
    // ←
    if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
    }

    if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
    }

    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
    } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
    } else {
        throw new Error('Incorrect value of diagonalMovement');
    }

    // ↖
    if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
    }
    // ↗
    if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
    }
    // ↘
    if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
    }
    // ↙
    if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
    }

    return neighbors;
};


/**
 * Get a clone of this grid.
 * @return {Grid} Cloned grid.
 */
Grid.prototype.clone = function() {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height);

    for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
};

module.exports = Grid;

},{"./DiagonalMovement":3,"./Node":6}],5:[function(_dereq_,module,exports){
/**
 * @namespace PF.Heuristic
 * @description A collection of heuristic functions.
 */
module.exports = {

  /**
   * Manhattan distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} dx + dy
   */
  manhattan: function(dx, dy) {
      return dx + dy;
  },

  /**
   * Euclidean distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy)
   */
  euclidean: function(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
  },

  /**
   * Octile distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy) for grids
   */
  octile: function(dx, dy) {
      var F = Math.SQRT2 - 1;
      return (dx < dy) ? F * dx + dy : F * dy + dx;
  },

  /**
   * Chebyshev distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} max(dx, dy)
   */
  chebyshev: function(dx, dy) {
      return Math.max(dx, dy);
  }

};

},{}],6:[function(_dereq_,module,exports){
/**
 * A node in grid. 
 * This class holds some basic information about a node and custom 
 * attributes may be added, depending on the algorithms' needs.
 * @constructor
 * @param {number} x - The x coordinate of the node on the grid.
 * @param {number} y - The y coordinate of the node on the grid.
 * @param {boolean} [walkable] - Whether this node is walkable.
 */
function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}

module.exports = Node;

},{}],7:[function(_dereq_,module,exports){
/**
 * Backtrace according to the parent records and return the path.
 * (including both start and end nodes)
 * @param {Node} node End node
 * @return {Array<Array<number>>} the path
 */
function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}
exports.backtrace = backtrace;

/**
 * Backtrace from start and end node, and return the path.
 * (including both start and end nodes)
 * @param {Node}
 * @param {Node}
 */
function biBacktrace(nodeA, nodeB) {
    var pathA = backtrace(nodeA),
        pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
}
exports.biBacktrace = biBacktrace;

/**
 * Compute the length of the path.
 * @param {Array<Array<number>>} path The path
 * @return {number} The length of the path
 */
function pathLength(path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i < path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}
exports.pathLength = pathLength;


/**
 * Given the start and end coordinates, return all the coordinates lying
 * on the line formed by these coordinates, based on Bresenham's algorithm.
 * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
 * @param {number} x0 Start x coordinate
 * @param {number} y0 Start y coordinate
 * @param {number} x1 End x coordinate
 * @param {number} y1 End y coordinate
 * @return {Array<Array<number>>} The coordinates on the line
 */
function interpolate(x0, y0, x1, y1) {
    var abs = Math.abs,
        line = [],
        sx, sy, dx, dy, err, e2;

    dx = abs(x1 - x0);
    dy = abs(y1 - y0);

    sx = (x0 < x1) ? 1 : -1;
    sy = (y0 < y1) ? 1 : -1;

    err = dx - dy;

    while (true) {
        line.push([x0, y0]);

        if (x0 === x1 && y0 === y1) {
            break;
        }
        
        e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }

    return line;
}
exports.interpolate = interpolate;


/**
 * Given a compressed path, return a new path that has all the segments
 * in it interpolated.
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} expanded path
 */
function expandPath(path) {
    var expanded = [],
        len = path.length,
        coord0, coord1,
        interpolated,
        interpolatedLen,
        i, j;

    if (len < 2) {
        return expanded;
    }

    for (i = 0; i < len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];

        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j < interpolatedLen - 1; ++j) {
            expanded.push(interpolated[j]);
        }
    }
    expanded.push(path[len - 1]);

    return expanded;
}
exports.expandPath = expandPath;


/**
 * Smoothen the give path.
 * The original path will not be modified; a new path will be returned.
 * @param {PF.Grid} grid
 * @param {Array<Array<number>>} path The path
 */
function smoothenPath(grid, path) {
    var len = path.length,
        x0 = path[0][0],        // path start x
        y0 = path[0][1],        // path start y
        x1 = path[len - 1][0],  // path end x
        y1 = path[len - 1][1],  // path end y
        sx, sy,                 // current start coordinate
        ex, ey,                 // current end coordinate
        newPath,
        i, j, coord, line, testCoord, blocked;

    sx = x0;
    sy = y0;
    newPath = [[sx, sy]];

    for (i = 2; i < len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);

        blocked = false;
        for (j = 1; j < line.length; ++j) {
            testCoord = line[j];

            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                blocked = true;
                break;
            }
        }
        if (blocked) {
            lastValidCoord = path[i - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
        }
    }
    newPath.push([x1, y1]);

    return newPath;
}
exports.smoothenPath = smoothenPath;


/**
 * Compress a path, remove redundant nodes without altering the shape
 * The original path is not modified
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} The compressed path
 */
function compressPath(path) {

    // nothing to compress
    if(path.length < 3) {
        return path;
    }

    var compressed = [],
        sx = path[0][0], // start x
        sy = path[0][1], // start y
        px = path[1][0], // second point x
        py = path[1][1], // second point y
        dx = px - sx, // direction between the two points
        dy = py - sy, // direction between the two points
        lx, ly,
        ldx, ldy,
        sq, i;

    // normalize the direction
    sq = Math.sqrt(dx*dx + dy*dy);
    dx /= sq;
    dy /= sq;

    // start the new path
    compressed.push([sx,sy]);

    for(i = 2; i < path.length; i++) {

        // store the last point
        lx = px;
        ly = py;

        // store the last direction
        ldx = dx;
        ldy = dy;

        // next point
        px = path[i][0];
        py = path[i][1];

        // next direction
        dx = px - lx;
        dy = py - ly;

        // normalize
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // if the direction has changed, store the point
        if ( dx !== ldx || dy !== ldy ) {
            compressed.push([lx,ly]);
        }
    }

    // store the last point
    compressed.push([px,py]);

    return compressed;
}
exports.compressPath = compressPath;

},{}],8:[function(_dereq_,module,exports){
module.exports = {
    'Heap'                      : _dereq_('heap'),
    'Node'                      : _dereq_('./core/Node'),
    'Grid'                      : _dereq_('./core/Grid'),
    'Util'                      : _dereq_('./core/Util'),
    'DiagonalMovement'          : _dereq_('./core/DiagonalMovement'),
    'Heuristic'                 : _dereq_('./core/Heuristic'),
    'AStarFinder'               : _dereq_('./finders/AStarFinder'),
    'BestFirstFinder'           : _dereq_('./finders/BestFirstFinder'),
    'BreadthFirstFinder'        : _dereq_('./finders/BreadthFirstFinder'),
    'DijkstraFinder'            : _dereq_('./finders/DijkstraFinder'),
    'BiAStarFinder'             : _dereq_('./finders/BiAStarFinder'),
    'BiBestFirstFinder'         : _dereq_('./finders/BiBestFirstFinder'),
    'BiBreadthFirstFinder'      : _dereq_('./finders/BiBreadthFirstFinder'),
    'BiDijkstraFinder'          : _dereq_('./finders/BiDijkstraFinder'),
    'IDAStarFinder'             : _dereq_('./finders/IDAStarFinder'),
    'JumpPointFinder'           : _dereq_('./finders/JumpPointFinder'),
};

},{"./core/DiagonalMovement":3,"./core/Grid":4,"./core/Heuristic":5,"./core/Node":6,"./core/Util":7,"./finders/AStarFinder":9,"./finders/BestFirstFinder":10,"./finders/BiAStarFinder":11,"./finders/BiBestFirstFinder":12,"./finders/BiBreadthFirstFinder":13,"./finders/BiDijkstraFinder":14,"./finders/BreadthFirstFinder":15,"./finders/DijkstraFinder":16,"./finders/IDAStarFinder":17,"./finders/JumpPointFinder":22,"heap":1}],9:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder. Based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching 
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;

    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        // if reached the end position, construct the path and return it
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = AStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],10:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Best-First-Search path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BestFirstFinder.prototype = new AStarFinder();
BestFirstFinder.prototype.constructor = BestFirstFinder;

module.exports = BestFirstFinder;

},{"./AStarFinder":9}],11:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var cmp = function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        },
        startOpenList = new Heap(cmp),
        endOpenList = new Heap(cmp),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng,
        BY_START = 1, BY_END = 2;

    // set the `g` and `f` value of the start node to be 0
    // and push it into the start open list
    startNode.g = 0;
    startNode.f = 0;
    startOpenList.push(startNode);
    startNode.opened = BY_START;

    // set the `g` and `f` value of the end node to be 0
    // and push it into the open open list
    endNode.g = 0;
    endNode.f = 0;
    endOpenList.push(endNode);
    endNode.opened = BY_END;

    // while both the open lists are not empty
    while (!startOpenList.empty() && !endOpenList.empty()) {

        // pop the position of start node which has the minimum `f` value.
        node = startOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_END) {
                return Util.biBacktrace(node, neighbor);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    startOpenList.push(neighbor);
                    neighbor.opened = BY_START;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    startOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor


        // pop the position of end node which has the minimum `f` value.
        node = endOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_START) {
                return Util.biBacktrace(neighbor, node);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - startX), abs(y - startY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    endOpenList.push(neighbor);
                    neighbor.opened = BY_END;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    endOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = BiAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],12:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-direcitional Best-First-Search path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BiBestFirstFinder.prototype = new BiAStarFinder();
BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

module.exports = BiBestFirstFinder;

},{"./BiAStarFinder":11}],13:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Bi-directional Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}


/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        startOpenList = [], endOpenList = [],
        neighbors, neighbor, node,
        diagonalMovement = this.diagonalMovement,
        BY_START = 0, BY_END = 1,
        i, l;

    // push the start and end nodes into the queues
    startOpenList.push(startNode);
    startNode.opened = true;
    startNode.by = BY_START;

    endOpenList.push(endNode);
    endNode.opened = true;
    endNode.by = BY_END;

    // while both the queues are not empty
    while (startOpenList.length && endOpenList.length) {

        // expand start open list

        node = startOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                // if this node has been inspected by the reversed search,
                // then a path is found.
                if (neighbor.by === BY_END) {
                    return Util.biBacktrace(node, neighbor);
                }
                continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
        }

        // expand end open list

        node = endOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                if (neighbor.by === BY_START) {
                    return Util.biBacktrace(neighbor, node);
                }
                continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
        }
    }

    // fail to find the path
    return [];
};

module.exports = BiBreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],14:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-directional Dijkstra path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

BiDijkstraFinder.prototype = new BiAStarFinder();
BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

module.exports = BiDijkstraFinder;

},{"./BiAStarFinder":11}],15:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Breadth-First-Search path finder.
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = [],
        diagonalMovement = this.diagonalMovement,
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        neighbors, neighbor, node, i, l;

    // push the start pos into the queue
    openList.push(startNode);
    startNode.opened = true;

    // while the queue is not empty
    while (openList.length) {
        // take the front node from the queue
        node = openList.shift();
        node.closed = true;

        // reached the end position
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            // skip this neighbor if it has been inspected before
            if (neighbor.closed || neighbor.opened) {
                continue;
            }

            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
        }
    }
    
    // fail to find the path
    return [];
};

module.exports = BreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],16:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Dijkstra path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

DijkstraFinder.prototype = new AStarFinder();
DijkstraFinder.prototype.constructor = DijkstraFinder;

module.exports = DijkstraFinder;

},{"./AStarFinder":9}],17:[function(_dereq_,module,exports){
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var Node       = _dereq_('../core/Node');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Iterative Deeping A Star (IDA*) path-finder.
 *
 * Recursion based on:
 *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
 *
 * Path retracing based on:
 *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
 *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
 *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
 *
 * @author Gerard Meier (www.gerardmeier.com)
 *
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 * @param {boolean} opt.trackRecursion Whether to track recursion for
 *     statistical purposes.
 * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
 */
function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path. When an empty array is returned, either
 * no path is possible, or the maximum execution time is reached.
 *
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    // Used for statistics:
    var nodesVisited = 0;

    // Execution time limitation:
    var startTime = new Date().getTime();

    // Heuristic helper:
    var h = function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }.bind(this);

    // Step cost from a to b:
    var cost = function(a, b) {
        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
    };

    /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {Array<Array<number>>} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
    var search = function(node, g, cutoff, route, depth) {
        nodesVisited++;

        // Enforce timelimit:
        if (this.timeLimit > 0 &&
            new Date().getTime() - startTime > this.timeLimit * 1000) {
            // Enforced as "path-not-found".
            return Infinity;
        }

        var f = g + h(node, end) * this.weight;

        // We've searched too deep for this iteration.
        if (f > cutoff) {
            return f;
        }

        if (node == end) {
            route[depth] = [node.x, node.y];
            return node;
        }

        var min, t, k, neighbour;

        var neighbours = grid.getNeighbors(node, this.diagonalMovement);

        // Sort the neighbours, gives nicer paths. But, this deviates
        // from the original algorithm - so I left it out.
        //neighbours.sort(function(a, b){
        //    return h(a, end) - h(b, end);
        //});

        
        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
            if (this.trackRecursion) {
                // Retain a copy for visualisation. Due to recursion, this
                // node may be part of other paths too.
                neighbour.retainCount = neighbour.retainCount + 1 || 1;

                if(neighbour.tested !== true) {
                    neighbour.tested = true;
                }
            }

            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

            if (t instanceof Node) {
                route[depth] = [node.x, node.y];

                // For a typical A* linked list, this would work:
                // neighbour.parent = node;
                return t;
            }

            // Decrement count, then determine whether it's actually closed.
            if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                neighbour.tested = false;
            }

            if (t < min) {
                min = t;
            }
        }

        return min;

    }.bind(this);

    // Node instance lookups:
    var start = grid.getNodeAt(startX, startY);
    var end   = grid.getNodeAt(endX, endY);

    // Initial search depth, given the typical heuristic contraints,
    // there should be no cheaper route possible.
    var cutOff = h(start, end);

    var j, route, t;

    // With an overflow protection.
    for (j = 0; true; ++j) {

        route = [];

        // Search till cut-off depth:
        t = search(start, 0, cutOff, route, 0);

        // Route not possible, or not found in time limit.
        if (t === Infinity) {
            return [];
        }

        // If t is a node, it's also the end node. Route is now
        // populated with a valid path to the end node.
        if (t instanceof Node) {
            return route;
        }

        // Try again, this time with a deeper cut-off. The t score
        // is the closest we got to the end node.
        cutOff = t;
    }

    // This _should_ never to be reached.
    return [];
};

module.exports = IDAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Node":6,"../core/Util":7}],18:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which always moves
 * diagonally irrespective of the number of obstacles.
 */
function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x + dx, y + dy)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (!grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y + dy]);
                }
                if (!grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y + dy]);
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (!grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x + dx, y + 1]);
                }
                if (!grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x + dx, y - 1]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFAlwaysMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],19:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there is at most one obstacle.
 */
function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],20:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there are no obstacles.
 */
function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            // return [x, y];
        // }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            // When moving vertically, must check for horizontal jump points
            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                // return [x, y];
            // }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
        }
        // search horizontally/vertically
        else {
            var isNextWalkable;
            if (dx !== 0) {
                isNextWalkable = grid.isWalkableAt(x + dx, y);
                var isTopWalkable = grid.isWalkableAt(x, y + 1);
                var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                if (isNextWalkable) {
                    neighbors.push([x + dx, y]);
                    if (isTopWalkable) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
                if (isTopWalkable) {
                    neighbors.push([x, y + 1]);
                }
                if (isBottomWalkable) {
                    neighbors.push([x, y - 1]);
                }
            }
            else if (dy !== 0) {
                isNextWalkable = grid.isWalkableAt(x, y + dy);
                var isRightWalkable = grid.isWalkableAt(x + 1, y);
                var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                if (isNextWalkable) {
                    neighbors.push([x, y + dy]);
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                if (isRightWalkable) {
                    neighbors.push([x + 1, y]);
                }
                if (isLeftWalkable) {
                    neighbors.push([x - 1, y]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfNoObstacles;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],21:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm allowing only horizontal
 * or vertical movements.
 */
function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    if (dx !== 0) {
        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
            return [x, y];
        }
    }
    else if (dy !== 0) {
        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
            return [x, y];
        }
        //When moving vertically, must check for horizontal jump points
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
            return [x, y];
        }
    }
    else {
        throw new Error("Only horizontal and vertical movements are allowed");
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        if (dx !== 0) {
            if (grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x, y - 1]);
            }
            if (grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x, y + 1]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
        }
        else if (dy !== 0) {
            if (grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y]);
            }
            if (grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y]);
            }
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFNeverMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],22:[function(_dereq_,module,exports){
/**
 * @author aniero / https://github.com/aniero
 */
var DiagonalMovement = _dereq_('../core/DiagonalMovement');
var JPFNeverMoveDiagonally = _dereq_('./JPFNeverMoveDiagonally');
var JPFAlwaysMoveDiagonally = _dereq_('./JPFAlwaysMoveDiagonally');
var JPFMoveDiagonallyIfNoObstacles = _dereq_('./JPFMoveDiagonallyIfNoObstacles');
var JPFMoveDiagonallyIfAtMostOneObstacle = _dereq_('./JPFMoveDiagonallyIfAtMostOneObstacle');

/**
 * Path finder using the Jump Point Search algorithm
 * @param {Object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
 *      movement will be allowed.
 */
function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}

module.exports = JumpPointFinder;

},{"../core/DiagonalMovement":3,"./JPFAlwaysMoveDiagonally":18,"./JPFMoveDiagonallyIfAtMostOneObstacle":19,"./JPFMoveDiagonallyIfNoObstacles":20,"./JPFNeverMoveDiagonally":21}],23:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Base class for the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}

/**
 * Find and return the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = this.openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = this.startNode = grid.getNodeAt(startX, startY),
        endNode = this.endNode = grid.getNodeAt(endX, endY), node;

    this.grid = grid;


    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this._identifySuccessors(node);
    }

    // fail to find the path
    return [];
};

/**
 * Identify successors for the given node. Runs a jump point search in the
 * direction of each available neighbor, adding any points found to the open
 * list.
 * @protected
 */
JumpPointFinderBase.prototype._identifySuccessors = function(node) {
    var grid = this.grid,
        heuristic = this.heuristic,
        openList = this.openList,
        endX = this.endNode.x,
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this._findNeighbors(node);
    for(i = 0, l = neighbors.length; i < l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);

            if (jumpNode.closed) {
                continue;
            }

            // include distance, as parent may not be immediately adjacent:
            d = Heuristic.octile(abs(jx - x), abs(jy - y));
            ng = node.g + d; // next `g` value

            if (!jumpNode.opened || ng < jumpNode.g) {
                jumpNode.g = ng;
                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.updateItem(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}]},{},[8])
(8)
});

// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>
//
// Released under the MIT License - https://github.com/jriecken/sat-js
//
// A simple library for determining intersections of circles and
// polygons using the Separating Axis Theorem.
/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */

/*global define: false, module: false*/
/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,
  eqeqeq:true, bitwise:true, strict:true, undef:true,
  curly:true, browser:true */

// Create a UMD wrapper for SAT. Works in:
//
//  - Plain browser via global SAT variable
//  - AMD loader (like require.js)
//  - Node.js
//
// The quoted properties all over the place are used so that the Closure Compiler
// does not mangle the exposed API in advanced mode.
/**
 * @param {*} root - The global scope
 * @param {Function} factory - Factory that creates SAT module
 */
(function (root, factory) {
  "use strict";
  if (typeof define === 'function' && define['amd']) {
    define(factory);
  } else if (typeof exports === 'object') {
    module['exports'] = factory();
  } else {
    root['SAT'] = factory();
  }
}(this, function () {
  "use strict";

  var SAT = {};

  //
  // ## Vector
  //
  // Represents a vector in two dimensions with `x` and `y` properties.


  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If
  // a coordinate is not specified, it will be set to `0`
  /**
   * @param {?number=} x The x position.
   * @param {?number=} y The y position.
   * @constructor
   */
  function Vector(x, y) {
    this['x'] = x || 0;
    this['y'] = y || 0;
  }
  SAT['Vector'] = Vector;
  // Alias `Vector` as `V`
  SAT['V'] = Vector;


  // Copy the values of another Vector into this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {
    this['x'] = other['x'];
    this['y'] = other['y'];
    return this;
  };

  // Create a new vector with the same coordinates as this on.
  /**
   * @return {Vector} The new cloned vector
   */
  Vector.prototype['clone'] = Vector.prototype.clone = function () {
    return new Vector(this['x'], this['y']);
  };

  // Change this vector to be perpendicular to what it was before. (Effectively
  // roatates it 90 degrees in a clockwise direction)
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['perp'] = Vector.prototype.perp = function () {
    var x = this['x'];
    this['x'] = this['y'];
    this['y'] = -x;
    return this;
  };

  // Rotate this vector (counter-clockwise) by the specified angle (in radians).
  /**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Vector} This for chaining.
   */
  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {
    var x = this['x'];
    var y = this['y'];
    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);
    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);
    return this;
  };

  // Reverse this vector.
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {
    this['x'] = -this['x'];
    this['y'] = -this['y'];
    return this;
  };


  // Normalize this vector.  (make it have length of `1`)
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {
    var d = this.len();
    if (d > 0) {
      this['x'] = this['x'] / d;
      this['y'] = this['y'] / d;
    }
    return this;
  };

  // Add another vector to this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['add'] = Vector.prototype.add = function (other) {
    this['x'] += other['x'];
    this['y'] += other['y'];
    return this;
  };

  // Subtract another vector from this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaiing.
   */
  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {
    this['x'] -= other['x'];
    this['y'] -= other['y'];
    return this;
  };

  // Scale this vector. An independent scaling factor can be provided
  // for each axis, or a single scaling factor that will scale both `x` and `y`.
  /**
   * @param {number} x The scaling factor in the x direction.
   * @param {?number=} y The scaling factor in the y direction.  If this
   *   is not specified, the x scaling factor will be used.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {
    this['x'] *= x;
    this['y'] *= typeof y != 'undefined' ? y : x;
    return this;
  };

  // Project this vector on to another vector.
  /**
   * @param {Vector} other The vector to project onto.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['project'] = Vector.prototype.project = function (other) {
    var amt = this.dot(other) / other.len2();
    this['x'] = amt * other['x'];
    this['y'] = amt * other['y'];
    return this;
  };

  // Project this vector onto a vector of unit length. This is slightly more efficient
  // than `project` when dealing with unit vectors.
  /**
   * @param {Vector} other The unit vector to project onto.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {
    var amt = this.dot(other);
    this['x'] = amt * other['x'];
    this['y'] = amt * other['y'];
    return this;
  };

  // Reflect this vector on an arbitrary axis.
  /**
   * @param {Vector} axis The vector representing the axis.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {
    var x = this['x'];
    var y = this['y'];
    this.project(axis).scale(2);
    this['x'] -= x;
    this['y'] -= y;
    return this;
  };

  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is
  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.
  /**
   * @param {Vector} axis The unit vector representing the axis.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {
    var x = this['x'];
    var y = this['y'];
    this.projectN(axis).scale(2);
    this['x'] -= x;
    this['y'] -= y;
    return this;
  };

  // Get the dot product of this vector and another.
  /**
   * @param {Vector}  other The vector to dot this one against.
   * @return {number} The dot product.
   */
  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {
    return this['x'] * other['x'] + this['y'] * other['y'];
  };

  // Get the squared length of this vector.
  /**
   * @return {number} The length^2 of this vector.
   */
  Vector.prototype['len2'] = Vector.prototype.len2 = function () {
    return this.dot(this);
  };

  // Get the length of this vector.
  /**
   * @return {number} The length of this vector.
   */
  Vector.prototype['len'] = Vector.prototype.len = function () {
    return Math.sqrt(this.len2());
  };

  // ## Circle
  //
  // Represents a circle with a position and a radius.

  // Create a new circle, optionally passing in a position and/or radius. If no position
  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will
  // have a radius of `0`.
  /**
   * @param {Vector=} pos A vector representing the position of the center of the circle
   * @param {?number=} r The radius of the circle
   * @constructor
   */
  function Circle(pos, r) {
    this['pos'] = pos || new Vector();
    this['r'] = r || 0;
    this['offset'] = new Vector();
  }
  SAT['Circle'] = Circle;

  // Compute the axis-aligned bounding box (AABB) of this Circle.
  //
  // Note: Returns a _new_ `Box` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {
    var r = this['r'];
    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));
    return new Box(corner, r * 2, r * 2);
  };

  // Compute the axis-aligned bounding box (AABB) of this Circle.
  //
  // Note: Returns a _new_ `Polygon` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {
    return this.getAABBAsBox().toPolygon();
  };

  // Set the current offset to apply to the radius.
  /**
   * @param {Vector} offset The new offset vector.
   * @return {Circle} This for chaining.
   */
  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {
    this['offset'] = offset;
    return this;
  };

  // ## Polygon
  //
  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)
  //
  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the
  // provided setters. Otherwise the calculated properties will not be updated correctly.
  //
  // `pos` can be changed directly.

  // Create a new polygon, passing in a position vector, and an array of points (represented
  // by vectors relative to the position vector). If no position is passed in, the position
  // of the polygon will be `(0,0)`.
  /**
   * @param {Vector=} pos A vector representing the origin of the polygon. (all other
   *   points are relative to this one)
   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @constructor
   */
  function Polygon(pos, points) {
    this['pos'] = pos || new Vector();
    this['angle'] = 0;
    this['offset'] = new Vector();
    this.setPoints(points || []);
  }
  SAT['Polygon'] = Polygon;

  // Set the points of the polygon. Any consecutive duplicate points will be combined.
  //
  // Note: The points are counter-clockwise *with respect to the coordinate system*.
  // If you directly draw the points on a screen that has the origin at the top-left corner
  // it will _appear_ visually that the points are being specified clockwise. This is just
  // because of the inversion of the Y-axis when being displayed.
  /**
   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {
    // Only re-allocate if this is a new polygon or the number of points has changed.
    var lengthChanged = !this['points'] || this['points'].length !== points.length;
    if (lengthChanged) {
      var i;
      var calcPoints = this['calcPoints'] = [];
      var edges = this['edges'] = [];
      var normals = this['normals'] = [];
      // Allocate the vector arrays for the calculated properties
      for (i = 0; i < points.length; i++) {
        // Remove consecutive duplicate points
        var p1 = points[i];
        var p2 = i < points.length - 1 ? points[i + 1] : points[0];
        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
          points.splice(i, 1);
          i -= 1;
          continue;
        }
        calcPoints.push(new Vector());
        edges.push(new Vector());
        normals.push(new Vector());
      }
    }
    this['points'] = points;
    this._recalc();
    return this;
  };

  // Set the current rotation angle of the polygon.
  /**
   * @param {number} angle The current rotation angle (in radians).
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {
    this['angle'] = angle;
    this._recalc();
    return this;
  };

  // Set the current offset to apply to the `points` before applying the `angle` rotation.
  /**
   * @param {Vector} offset The new offset vector.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {
    this['offset'] = offset;
    this._recalc();
    return this;
  };

  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).
  //
  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).
  /**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {
    var points = this['points'];
    var len = points.length;
    for (var i = 0; i < len; i++) {
      points[i].rotate(angle);
    }
    this._recalc();
    return this;
  };

  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate
  // system* (i.e. `pos`).
  //
  // This is most useful to change the "center point" of a polygon. If you just want to move the whole polygon, change
  // the coordinates of `pos`.
  //
  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)
  /**
   * @param {number} x The horizontal amount to translate.
   * @param {number} y The vertical amount to translate.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {
    var points = this['points'];
    var len = points.length;
    for (var i = 0; i < len; i++) {
      points[i]['x'] += x;
      points[i]['y'] += y;
    }
    this._recalc();
    return this;
  };


  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the
  // edges and normals of the collision polygon.
  /**
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype._recalc = function () {
    // Calculated points - this is what is used for underlying collisions and takes into account
    // the angle/offset set on the polygon.
    var calcPoints = this['calcPoints'];
    // The edges here are the direction of the `n`th edge of the polygon, relative to
    // the `n`th point. If you want to draw a given edge from the edge value, you must
    // first translate to the position of the starting point.
    var edges = this['edges'];
    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative
    // to the position of the `n`th point. If you want to draw an edge normal, you must first
    // translate to the position of the starting point.
    var normals = this['normals'];
    // Copy the original points array and apply the offset/angle
    var points = this['points'];
    var offset = this['offset'];
    var angle = this['angle'];
    var len = points.length;
    var i;
    for (i = 0; i < len; i++) {
      var calcPoint = calcPoints[i].copy(points[i]);
      calcPoint['x'] += offset['x'];
      calcPoint['y'] += offset['y'];
      if (angle !== 0) {
        calcPoint.rotate(angle);
      }
    }
    // Calculate the edges/normals
    for (i = 0; i < len; i++) {
      var p1 = calcPoints[i];
      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];
      var e = edges[i].copy(p2).sub(p1);
      normals[i].copy(e).perp().normalize();
    }
    return this;
  };


  // Compute the axis-aligned bounding box. Any current state
  // (translations/rotations) will be applied before constructing the AABB.
  //
  // Note: Returns a _new_ `Box` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {
    var points = this['calcPoints'];
    var len = points.length;
    var xMin = points[0]['x'];
    var yMin = points[0]['y'];
    var xMax = points[0]['x'];
    var yMax = points[0]['y'];
    for (var i = 1; i < len; i++) {
      var point = points[i];
      if (point['x'] < xMin) {
        xMin = point['x'];
      }
      else if (point['x'] > xMax) {
        xMax = point['x'];
      }
      if (point['y'] < yMin) {
        yMin = point['y'];
      }
      else if (point['y'] > yMax) {
        yMax = point['y'];
      }
    }
    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
  };


  // Compute the axis-aligned bounding box. Any current state
  // (translations/rotations) will be applied before constructing the AABB.
  //
  // Note: Returns a _new_ `Polygon` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {
    return this.getAABBAsBox().toPolygon();
  };

  // Compute the centroid (geometric center) of the polygon. Any current state
  // (translations/rotations) will be applied before computing the centroid.
  //
  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon
  //
  // Note: Returns a _new_ `Vector` each time you call this.
  /**
   * @return {Vector} A Vector that contains the coordinates of the Centroid.
   */
  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {
    var points = this['calcPoints'];
    var len = points.length;
    var cx = 0;
    var cy = 0;
    var ar = 0;
    for (var i = 0; i < len; i++) {
      var p1 = points[i];
      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point
      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];
      cx += (p1['x'] + p2['x']) * a;
      cy += (p1['y'] + p2['y']) * a;
      ar += a;
    }
    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area
    cx = cx / ar;
    cy = cy / ar;
    return new Vector(cx, cy);
  };


  // ## Box
  //
  // Represents an axis-aligned box, with a width and height.


  // Create a new box, with the specified position, width, and height. If no position
  // is given, the position will be `(0,0)`. If no width or height are given, they will
  // be set to `0`.
  /**
   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).
   * @param {?number=} w The width of the box.
   * @param {?number=} h The height of the box.
   * @constructor
   */
  function Box(pos, w, h) {
    this['pos'] = pos || new Vector();
    this['w'] = w || 0;
    this['h'] = h || 0;
  }
  SAT['Box'] = Box;

  // Returns a polygon whose edges are the same as this box.
  /**
   * @return {Polygon} A new Polygon that represents this box.
   */
  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {
    var pos = this['pos'];
    var w = this['w'];
    var h = this['h'];
    return new Polygon(new Vector(pos['x'], pos['y']), [
      new Vector(), new Vector(w, 0),
      new Vector(w, h), new Vector(0, h)
    ]);
  };

  // ## Response
  //
  // An object representing the result of an intersection. Contains:
  //  - The two objects participating in the intersection
  //  - The vector representing the minimum change necessary to extract the first object
  //    from the second one (as well as a unit vector in that direction and the magnitude
  //    of the overlap)
  //  - Whether the first object is entirely inside the second, and vice versa.
  /**
   * @constructor
   */
  function Response() {
    this['a'] = null;
    this['b'] = null;
    this['overlapN'] = new Vector();
    this['overlapV'] = new Vector();
    this.clear();
  }
  SAT['Response'] = Response;

  // Set some values of the response back to their defaults.  Call this between tests if
  // you are going to reuse a single Response object for multiple intersection tests (recommented
  // as it will avoid allcating extra memory)
  /**
   * @return {Response} This for chaining
   */
  Response.prototype['clear'] = Response.prototype.clear = function () {
    this['aInB'] = true;
    this['bInA'] = true;
    this['overlap'] = Number.MAX_VALUE;
    return this;
  };

  // ## Object Pools

  // A pool of `Vector` objects that are used in calculations to avoid
  // allocating memory.
  /**
   * @type {Array<Vector>}
   */
  var T_VECTORS = [];
  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }

  // A pool of arrays of numbers used in calculations to avoid allocating
  // memory.
  /**
   * @type {Array<Array<number>>}
   */
  var T_ARRAYS = [];
  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }

  // Temporary response used for polygon hit detection.
  /**
   * @type {Response}
   */
  var T_RESPONSE = new Response();

  // Tiny "point" polygon used for polygon hit detection.
  /**
   * @type {Polygon}
   */
  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();

  // ## Helper Functions

  // Flattens the specified array of points onto a unit vector axis,
  // resulting in a one dimensional range of the minimum and
  // maximum value on that axis.
  /**
   * @param {Array<Vector>} points The points to flatten.
   * @param {Vector} normal The unit vector axis to flatten on.
   * @param {Array<number>} result An array.  After calling this function,
   *   result[0] will be the minimum value,
   *   result[1] will be the maximum value.
   */
  function flattenPointsOn(points, normal, result) {
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    var len = points.length;
    for (var i = 0; i < len; i++) {
      // The magnitude of the projection of the point onto the normal
      var dot = points[i].dot(normal);
      if (dot < min) { min = dot; }
      if (dot > max) { max = dot; }
    }
    result[0] = min; result[1] = max;
  }

  // Check whether two convex polygons are separated by the specified
  // axis (must be a unit vector).
  /**
   * @param {Vector} aPos The position of the first polygon.
   * @param {Vector} bPos The position of the second polygon.
   * @param {Array<Vector>} aPoints The points in the first polygon.
   * @param {Array<Vector>} bPoints The points in the second polygon.
   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
   *   will be projected onto this axis.
   * @param {Response=} response A Response object (optional) which will be populated
   *   if the axis is not a separating axis.
   * @return {boolean} true if it is a separating axis, false otherwise.  If false,
   *   and a response is passed in, information about how much overlap and
   *   the direction of the overlap will be populated.
   */
  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
    var rangeA = T_ARRAYS.pop();
    var rangeB = T_ARRAYS.pop();
    // The magnitude of the offset between the two polygons
    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
    var projectedOffset = offsetV.dot(axis);
    // Project the polygons onto the axis.
    flattenPointsOn(aPoints, axis, rangeA);
    flattenPointsOn(bPoints, axis, rangeB);
    // Move B's range to its position relative to A.
    rangeB[0] += projectedOffset;
    rangeB[1] += projectedOffset;
    // Check if there is a gap. If there is, this is a separating axis and we can stop
    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
      T_VECTORS.push(offsetV);
      T_ARRAYS.push(rangeA);
      T_ARRAYS.push(rangeB);
      return true;
    }
    // This is not a separating axis. If we're calculating a response, calculate the overlap.
    if (response) {
      var overlap = 0;
      // A starts further left than B
      if (rangeA[0] < rangeB[0]) {
        response['aInB'] = false;
        // A ends before B does. We have to pull A out of B
        if (rangeA[1] < rangeB[1]) {
          overlap = rangeA[1] - rangeB[0];
          response['bInA'] = false;
          // B is fully inside A.  Pick the shortest way out.
        } else {
          var option1 = rangeA[1] - rangeB[0];
          var option2 = rangeB[1] - rangeA[0];
          overlap = option1 < option2 ? option1 : -option2;
        }
        // B starts further left than A
      } else {
        response['bInA'] = false;
        // B ends before A ends. We have to push A out of B
        if (rangeA[1] > rangeB[1]) {
          overlap = rangeA[0] - rangeB[1];
          response['aInB'] = false;
          // A is fully inside B.  Pick the shortest way out.
        } else {
          var option1 = rangeA[1] - rangeB[0];
          var option2 = rangeB[1] - rangeA[0];
          overlap = option1 < option2 ? option1 : -option2;
        }
      }
      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
      var absOverlap = Math.abs(overlap);
      if (absOverlap < response['overlap']) {
        response['overlap'] = absOverlap;
        response['overlapN'].copy(axis);
        if (overlap < 0) {
          response['overlapN'].reverse();
        }
      }
    }
    T_VECTORS.push(offsetV);
    T_ARRAYS.push(rangeA);
    T_ARRAYS.push(rangeB);
    return false;
  }
  SAT['isSeparatingAxis'] = isSeparatingAxis;

  // Calculates which Voronoi region a point is on a line segment.
  // It is assumed that both the line and the point are relative to `(0,0)`
  //
  //            |       (0)      |
  //     (-1)  [S]--------------[E]  (1)
  //            |       (0)      |
  /**
   * @param {Vector} line The line segment.
   * @param {Vector} point The point.
   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,
   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,
   *          RIGHT_VORONOI_REGION (1) if it is the right region.
   */
  function voronoiRegion(line, point) {
    var len2 = line.len2();
    var dp = point.dot(line);
    // If the point is beyond the start of the line, it is in the
    // left voronoi region.
    if (dp < 0) { return LEFT_VORONOI_REGION; }
    // If the point is beyond the end of the line, it is in the
    // right voronoi region.
    else if (dp > len2) { return RIGHT_VORONOI_REGION; }
    // Otherwise, it's in the middle one.
    else { return MIDDLE_VORONOI_REGION; }
  }
  // Constants for Voronoi regions
  /**
   * @const
   */
  var LEFT_VORONOI_REGION = -1;
  /**
   * @const
   */
  var MIDDLE_VORONOI_REGION = 0;
  /**
   * @const
   */
  var RIGHT_VORONOI_REGION = 1;

  // ## Collision Tests

  // Check if a point is inside a circle.
  /**
   * @param {Vector} p The point to test.
   * @param {Circle} c The circle to test.
   * @return {boolean} true if the point is inside the circle, false if it is not.
   */
  function pointInCircle(p, c) {
    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);
    var radiusSq = c['r'] * c['r'];
    var distanceSq = differenceV.len2();
    T_VECTORS.push(differenceV);
    // If the distance between is smaller than the radius then the point is inside the circle.
    return distanceSq <= radiusSq;
  }
  SAT['pointInCircle'] = pointInCircle;

  // Check if a point is inside a convex polygon.
  /**
   * @param {Vector} p The point to test.
   * @param {Polygon} poly The polygon to test.
   * @return {boolean} true if the point is inside the polygon, false if it is not.
   */
  function pointInPolygon(p, poly) {
    TEST_POINT['pos'].copy(p);
    T_RESPONSE.clear();
    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
    if (result) {
      result = T_RESPONSE['aInB'];
    }
    return result;
  }
  SAT['pointInPolygon'] = pointInPolygon;

  // Check if two circles collide.
  /**
   * @param {Circle} a The first circle.
   * @param {Circle} b The second circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   the circles intersect.
   * @return {boolean} true if the circles intersect, false if they don't.
   */
  function testCircleCircle(a, b, response) {
    // Check if the distance between the centers of the two
    // circles is greater than their combined radius.
    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);
    var totalRadius = a['r'] + b['r'];
    var totalRadiusSq = totalRadius * totalRadius;
    var distanceSq = differenceV.len2();
    // If the distance is bigger than the combined radius, they don't intersect.
    if (distanceSq > totalRadiusSq) {
      T_VECTORS.push(differenceV);
      return false;
    }
    // They intersect.  If we're calculating a response, calculate the overlap.
    if (response) {
      var dist = Math.sqrt(distanceSq);
      response['a'] = a;
      response['b'] = b;
      response['overlap'] = totalRadius - dist;
      response['overlapN'].copy(differenceV.normalize());
      response['overlapV'].copy(differenceV).scale(response['overlap']);
      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];
      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];
    }
    T_VECTORS.push(differenceV);
    return true;
  }
  SAT['testCircleCircle'] = testCircleCircle;

  // Check if a polygon and a circle collide.
  /**
   * @param {Polygon} polygon The polygon.
   * @param {Circle} circle The circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testPolygonCircle(polygon, circle, response) {
    // Get the position of the circle relative to the polygon.
    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);
    var radius = circle['r'];
    var radius2 = radius * radius;
    var points = polygon['calcPoints'];
    var len = points.length;
    var edge = T_VECTORS.pop();
    var point = T_VECTORS.pop();

    // For each edge in the polygon:
    for (var i = 0; i < len; i++) {
      var next = i === len - 1 ? 0 : i + 1;
      var prev = i === 0 ? len - 1 : i - 1;
      var overlap = 0;
      var overlapN = null;

      // Get the edge.
      edge.copy(polygon['edges'][i]);
      // Calculate the center of the circle relative to the starting point of the edge.
      point.copy(circlePos).sub(points[i]);

      // If the distance between the center of the circle and the point
      // is bigger than the radius, the polygon is definitely not fully in
      // the circle.
      if (response && point.len2() > radius2) {
        response['aInB'] = false;
      }

      // Calculate which Voronoi region the center of the circle is in.
      var region = voronoiRegion(edge, point);
      // If it's the left region:
      if (region === LEFT_VORONOI_REGION) {
        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.
        edge.copy(polygon['edges'][prev]);
        // Calculate the center of the circle relative the starting point of the previous edge
        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
        region = voronoiRegion(edge, point2);
        if (region === RIGHT_VORONOI_REGION) {
          // It's in the region we want.  Check if the circle intersects the point.
          var dist = point.len();
          if (dist > radius) {
            // No intersection
            T_VECTORS.push(circlePos);
            T_VECTORS.push(edge);
            T_VECTORS.push(point);
            T_VECTORS.push(point2);
            return false;
          } else if (response) {
            // It intersects, calculate the overlap.
            response['bInA'] = false;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }
        T_VECTORS.push(point2);
        // If it's the right region:
      } else if (region === RIGHT_VORONOI_REGION) {
        // We need to make sure we're in the left region on the next edge
        edge.copy(polygon['edges'][next]);
        // Calculate the center of the circle relative to the starting point of the next edge.
        point.copy(circlePos).sub(points[next]);
        region = voronoiRegion(edge, point);
        if (region === LEFT_VORONOI_REGION) {
          // It's in the region we want.  Check if the circle intersects the point.
          var dist = point.len();
          if (dist > radius) {
            // No intersection
            T_VECTORS.push(circlePos);
            T_VECTORS.push(edge);
            T_VECTORS.push(point);
            return false;
          } else if (response) {
            // It intersects, calculate the overlap.
            response['bInA'] = false;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }
        // Otherwise, it's the middle region:
      } else {
        // Need to check if the circle is intersecting the edge,
        // Change the edge into its "edge normal".
        var normal = edge.perp().normalize();
        // Find the perpendicular distance between the center of the
        // circle and the edge.
        var dist = point.dot(normal);
        var distAbs = Math.abs(dist);
        // If the circle is on the outside of the edge, there is no intersection.
        if (dist > 0 && distAbs > radius) {
          // No intersection
          T_VECTORS.push(circlePos);
          T_VECTORS.push(normal);
          T_VECTORS.push(point);
          return false;
        } else if (response) {
          // It intersects, calculate the overlap.
          overlapN = normal;
          overlap = radius - dist;
          // If the center of the circle is on the outside of the edge, or part of the
          // circle is on the outside, the circle is not fully inside the polygon.
          if (dist >= 0 || overlap < 2 * radius) {
            response['bInA'] = false;
          }
        }
      }

      // If this is the smallest overlap we've seen, keep it.
      // (overlapN may be null if the circle was in the wrong Voronoi region).
      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {
        response['overlap'] = overlap;
        response['overlapN'].copy(overlapN);
      }
    }

    // Calculate the final overlap vector - based on the smallest overlap.
    if (response) {
      response['a'] = polygon;
      response['b'] = circle;
      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
    }
    T_VECTORS.push(circlePos);
    T_VECTORS.push(edge);
    T_VECTORS.push(point);
    return true;
  }
  SAT['testPolygonCircle'] = testPolygonCircle;

  // Check if a circle and a polygon collide.
  //
  // **NOTE:** This is slightly less efficient than polygonCircle as it just
  // runs polygonCircle and reverses everything at the end.
  /**
   * @param {Circle} circle The circle.
   * @param {Polygon} polygon The polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testCirclePolygon(circle, polygon, response) {
    // Test the polygon against the circle.
    var result = testPolygonCircle(polygon, circle, response);
    if (result && response) {
      // Swap A and B in the response.
      var a = response['a'];
      var aInB = response['aInB'];
      response['overlapN'].reverse();
      response['overlapV'].reverse();
      response['a'] = response['b'];
      response['b'] = a;
      response['aInB'] = response['bInA'];
      response['bInA'] = aInB;
    }
    return result;
  }
  SAT['testCirclePolygon'] = testCirclePolygon;

  // Checks whether polygons collide.
  /**
   * @param {Polygon} a The first polygon.
   * @param {Polygon} b The second polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testPolygonPolygon(a, b, response) {
    var aPoints = a['calcPoints'];
    var aLen = aPoints.length;
    var bPoints = b['calcPoints'];
    var bLen = bPoints.length;
    // If any of the edge normals of A is a separating axis, no intersection.
    for (var i = 0; i < aLen; i++) {
      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {
        return false;
      }
    }
    // If any of the edge normals of B is a separating axis, no intersection.
    for (var i = 0; i < bLen; i++) {
      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {
        return false;
      }
    }
    // Since none of the edge normals of A or B are a separating axis, there is an intersection
    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
    // final overlap vector.
    if (response) {
      response['a'] = a;
      response['b'] = b;
      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
    }
    return true;
  }
  SAT['testPolygonPolygon'] = testPolygonPolygon;

  return SAT;
}));


// * SAT Library colliders save/load support

//@[ALIAS]
var _alias_JsonEx__decode = JsonEx._decode;
JsonEx._decode = function (value) {
    try {
        const type = Object.prototype.toString.call(value);
        if (type === "[object Object]" || type === "[object Array]") {
            if (value["@"]) {
                let className = value["@"];
                if(['Vector', 'Circle', 'Polygon'].contains(className)) {
                    const constructor = window.SAT[value["@"]];
                    Object.setPrototypeOf(value, constructor.prototype);

                    for (const key of Object.keys(value)) {
                        value[key] = this._decode(value[key]);
                    }

                    return value;
                }
            }
        }
    } catch (error) {
        KDCore.warning(error);
    }
    return _alias_JsonEx__decode.call(this, ...arguments);
};


var Vector2 = function (x,y) {
	this.x= x || 0;
	this.y = y || 0;
};

Vector2.prototype = {

	reset: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	toString : function (decPlaces) {
	 	decPlaces = decPlaces || 3; 
		var scalar = Math.pow(10,decPlaces); 
		return "[" + Math.round (this.x * scalar) / scalar + ", " + Math.round (this.y * scalar) / scalar + "]";
	},
	
	clone : function () {
		return new Vector2(this.x, this.y);
	},
	
	copyTo : function (v) {
		v.x = this.x;
		v.y = this.y;
	},

    getRandomPointOnCircleEdge : function (radius) {
        var angle = Math.random() * Math.PI * 2;
        return new Vector2(this.x + Math.cos(angle) * radius, this.y + Math.sin(angle) * radius);
    },
	
	copyFrom : function (v) {
		this.x = v.x;
		this.y = v.y;
	},	
	
	magnitude : function () {
		return Math.sqrt((this.x*this.x)+(this.y*this.y));
	},
	
	magnitudeSquared : function () {
		return (this.x*this.x)+(this.y*this.y);
	},
	
	normalize : function () {
		
		var m = this.magnitude();
				
		this.x = this.x/m;
		this.y = this.y/m;

		return this;	
	},
	
	reverse : function () {
		this.x = -this.x;
		this.y = -this.y;
		
		return this; 
	},
	
	plusEq : function (v) {
		this.x+=v.x;
		this.y+=v.y;
		
		return this; 
	},
	
	plusNew : function (v) {
		 return new Vector2(this.x+v.x, this.y+v.y); 
	},
	
	minusEq : function (v) {
		this.x-=v.x;
		this.y-=v.y;
		
		return this; 
	},

	minusNew : function (v) {
	 	return new Vector2(this.x-v.x, this.y-v.y); 
	},	
	
	multiplyEq : function (scalar) {
		this.x*=scalar;
		this.y*=scalar;
		
		return this; 
	},
	
	multiplyNew : function (scalar) {
		var returnvec = this.clone();
		return returnvec.multiplyEq(scalar);
	},
	
	divideEq : function (scalar) {
		this.x/=scalar;
		this.y/=scalar;
		return this; 
	},
	
	divideNew : function (scalar) {
		var returnvec = this.clone();
		return returnvec.divideEq(scalar);
	},

	dot : function (v) {
		return (this.x * v.x) + (this.y * v.y) ;
	},
	
	angle : function (useRadians) {
		
		return Math.atan2(this.y,this.x) * (useRadians ? 1 : Vector2Const.TO_DEGREES);
		
	},

	facingAngleTo : function (v, useRadians) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		return Math.atan2(dy, dx) * (useRadians ? 1 : Vector2Const.TO_DEGREES);
	},
	
	rotate : function (angle, useRadians) {
		
		var cosRY = Math.cos(angle * (useRadians ? 1 : Vector2Const.TO_RADIANS));
		var sinRY = Math.sin(angle * (useRadians ? 1 : Vector2Const.TO_RADIANS));
	
		Vector2Const.temp.copyFrom(this); 

		this.x= (Vector2Const.temp.x*cosRY)-(Vector2Const.temp.y*sinRY);
		this.y= (Vector2Const.temp.x*sinRY)+(Vector2Const.temp.y*cosRY);
		
		return this; 
	},	
		
	equals : function (v) {
		return((this.x==v.x)&&(this.y==v.x));
	},
	
	isCloseTo : function (v, tolerance) {	
		if(this.equals(v)) return true;
		
		Vector2Const.temp.copyFrom(this); 
		Vector2Const.temp.minusEq(v); 
		
		return(Vector2Const.temp.magnitudeSquared() < tolerance*tolerance);
	},
	
	rotateAroundPoint : function (point, angle, useRadians) {
		Vector2Const.temp.copyFrom(this); 
		//trace("rotate around point "+t+" "+point+" " +angle);
		Vector2Const.temp.minusEq(point);
		//trace("after subtract "+t);
		Vector2Const.temp.rotate(angle, useRadians);
		//trace("after rotate "+t);
		Vector2Const.temp.plusEq(point);
		//trace("after add "+t);
		this.copyFrom(Vector2Const.temp);
		
	}, 
	
	isMagLessThan : function (distance) {
		return(this.magnitudeSquared()<distance*distance);
	},
	
	isMagGreaterThan : function (distance) {
		return(this.magnitudeSquared()>distance*distance);
	}
	

};

Vector2Const = {
	TO_DEGREES : 180 / Math.PI,		
	TO_RADIANS : Math.PI / 180,
	temp : new Vector2()
	};

//@[EXTENSION]
AA.mz3d_patch = function () {


    // Thanks to Cutievirus and Cantux for the MZ3D compatibility code

    if (!window.mz3d) {
        return;
    }

    function parameter(name, dfault) {
        var r = AA.PP.getParam(name, dfault);
        return r;
    }

    const ANIMATION_DEPTH = parameter('ANIMATION_DEPTH', true);
    const ANIMATION_SCALE = parameter('ANIMATION_SCALE', .5);
    const WALL_HIT_BEHAVIOR = parameter('WALL_HIT_BEHAVIOR', true);
    const PROJECTILE_Z_OFF = parameter('PROJECTILE_Z_OFF', .5);
    const PROJECTILE_CLIMB_HEIGHT = parameter('PROJECTILE_CLIMB_HEIGHT', 1);
    const PROJECTILE_CLIMB_TIME = parameter('PROJECTILE_CLIMB_TIME', 5);
    const PROJECTILE_FALL_TIME = parameter('PROJECTILE_FALL_TIME', 25);

    const WEAPON_POSITION_X = parameter('WEAPON_POSITION_X', .5);
    const WEAPON_POSITION_Z = parameter('WEAPON_POSITION_Z', .333);
    const WEAPON_SCALE = parameter('WEAPON_SCALE', 1);
    const WEAPON_INHERIT_SCALE = parameter('WEAPON_INHERIT_SCALE', true);


    console.log("AABSZ.mz3d_patch applied");

    // MZ3D compatibility

    new mz3d.Feature('mz3d-alpha', {
        loadMap() {
            mz3d.diagonalMovement.smart = false;
            const orphans = [...mz3d.orphanModelList];
            orphans.forEach(orphan => orphan.dispose())

            if (window.AA) {
                AA.Input.applyKeybindings();
                if (mz3d.diagonalMovement.enabled) {
                    AA.Input.diagonalSpeed = 1
                }
            }

        }
    });

    mz3d.getTurnKey = k => 'rot' + k;
    mz3d.getStrafeKey = k => k;

    // mouse over 3D objects
    const raycastPredicate = mesh => {
        if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
            return false;
        }
        return true;
    }

    _TouchInput_toMapPoint = TouchInput.toMapPoint;
    TouchInput.toMapPoint = function () {
        //console.log("TOMAPPOINT")
        if (!mv3d.is3D()) {
            return _TouchInput_toMapPoint.apply(this, arguments);
        }
        const intersection = mz3d.scene.pick(this.x * mv3d.RES_SCALE, this.y * mv3d.RES_SCALE, raycastPredicate);
        if (intersection.hit) {
            const point = intersection.pickedPoint;
            $gameTemp._mz3d_anet_pointer = point;
            const mesh = intersection.pickedMesh;
            if (mesh.character) {
                return new Point(
                    Math.round(mesh.character.x),
                    Math.round(mesh.character.y),
                );
            }
            return new Point(
                Math.round(point.$x),
                Math.round(point.$y),
            );
        } else {
            return _TouchInput_toMapPoint.apply(this, arguments);
        }

    }

    // display mini hp bar
    const _aaSetupMiniHpGauge = Sprite_Character.prototype._aaSetupMiniHpGauge;
    Sprite_Character.prototype._aaSetupMiniHpGauge = function () {
        _aaSetupMiniHpGauge.apply(this, arguments);
        //SceneManager._scene._spriteset.addChild(this.aaMiniHPGauge);
    }

    // update mini hp bar position
    const _aaUpdate = Sprite_Character.prototype._aaUpdate;
    Sprite_Character.prototype._aaUpdate = function () {
        _aaUpdate.apply(this, arguments);
        if (this.aaMiniHPGauge && this.aaMiniHPGauge.isVisible()) {
            const scale = getScreenScale(this._character.mv3d_sprite);
            this.aaMiniHPGauge.refreshPosition(this._character.screenX(), this._character.screenY() + this.height - this.height * scale);
        }
    }

    // shake effect
    const _mz3d_updateNormal = mz3d.Character.prototype.updateNormal;
    mz3d.Character.prototype.updateNormal = function () {
        _mz3d_updateNormal.apply(this, arguments);
        if (!this.needsPositionUpdate && !mz3d.blendCameraPitch.updated || !mz3d.blendCameraYaw.updated &&
            this.char.aaIsShakeRequested()) {
            this.updatePositionOffsets();
        }
    }

    const _mz3d_updatePositionOffsets = mz3d.Character.prototype.updatePositionOffsets;
    mz3d.Character.prototype.updatePositionOffsets = function () {
        this.model.position.set(0, 0, 0);
        _mz3d_updatePositionOffsets.apply(this, arguments);
        if (!this.char.aaIsShakeRequested()) {
            return;
        }
        const cameraRotation = mv3d.cameraRotation();
        const billboardOffset = new BABYLON.Vector2(Math.cos(cameraRotation.y), Math.sin(cameraRotation.y));
        const shake = this.char.aaMotionDX() / $gameMap.tileWidth();
        this.model.x += billboardOffset.x * shake;
        this.model.y += billboardOffset.y * shake;
    }

    // dynamic sprites (shatter effect)
    const aaRegisterDynamicSprite = Spriteset_Map.prototype.aaRegisterDynamicSprite;
    Spriteset_Map.prototype.aaRegisterDynamicSprite = function (sprite, char) {
        aaRegisterDynamicSprite.apply(this, arguments);
        if (sprite.parent === this._tilemap) {
            this.addChild(sprite);
            const _update = sprite.update;
            sprite.update = function () {
                _update.apply(this, arguments);
                if (char.mv3d_sprite) {
                    const scale = getScreenScale(char.mv3d_sprite);
                    this.scale.set(scale, scale);
                }
            }
        }
    }

    // weapon sprite
    const _aaUpdateWeaponMotion = Sprite_Character.prototype._aaUpdateWeaponMotion;
    Sprite_Character.prototype._aaUpdateWeaponMotion = function () {
        _aaUpdateWeaponMotion.apply(this, arguments);
        this._mz3d_alpha_updateWeaponMotion();
    }

    Sprite_Character.prototype._mz3d_alpha_updateWeaponMotion = function () {
        if (!this.isABSEntity()) {
            return;
        }
        if (!this._aaSprWeapMotionHolder) {
            return;
        }
        //SceneManager._scene._spriteset.addChild(this._aaSprWeapMotionHolder);

        if (!this._character.mv3d_sprite) {
            return;
        }

        //const scale = getScreenScale(this._character.mv3d_sprite);
        //this._aaSprWeapMotionHolder.scale.set(scale,scale);
        //update model
        if (this._aaSprWeapon && this._aaSprWeapon._originalSprWeapon &&
            this._aaSprWeapon._originalSprWeapon._mz3d_weapon_model) {
            const weapon = this._aaSprWeapon._originalSprWeapon;
            weapon._mz3d_alpha_characterSprite = this;
            const model = weapon._mz3d_weapon_model;
            if (!model.isEnabled()) return;
            const char = this._character.mv3d_sprite;
            const direction = char.getDirection()
            model.parent = char.spriteOrigin;
            model.yaw = direction - 180;
            //model.z = char.getCHeight()/2;
            const scale = (WEAPON_INHERIT_SCALE ? char.model.mesh.scaling.x : 1) * WEAPON_SCALE;
            model.scalingDeterminant = scale;
            const v = transformVectorForCharacter(new mz3d.Vector3(0, 0, char.getCHeight() * WEAPON_POSITION_Z), char)
                .subtract(char.model.mesh.getAbsolutePosition());
            model.position.set(v.x, v.y, v.z);
            model.x += Math.sin(mz3d.util.degtorad(direction)) * WEAPON_POSITION_X * scale;
            model.y += Math.cos(mz3d.util.degtorad(direction)) * WEAPON_POSITION_X * scale;

            const cameraPitch = mz3d.blendCameraPitch.currentValue();
            const yawdiff = mz3d.util.degtorad(
                mz3d.blendCameraYaw.currentValue() - 180 - direction
            );
            // fix angle so it's still visible at 90 degrees
            const anglefix = Math.abs(Math.sin(mz3d.util.degtorad(mz3d.blendCameraPitch.currentValue())));
            if (anglefix > .95) {
                const pitchFactor = Math.abs(Math.cos(yawdiff));
                const rollFactor = Math.abs(Math.sin(yawdiff));
                if (pitchFactor > rollFactor) {
                    model.pitch = pitchFactor * 45;
                    model.roll = 0;
                } else {
                    model.pitch = 0;
                    model.roll = rollFactor * -45;
                }
            } else {
                model.pitch = 0;
                model.roll = 0;
            }
        }
    }

    // model for weapon sprite
    const _spriteWeapon_setup = Sprite_Weapon.prototype.setup;
    Sprite_Weapon.prototype.setup = function (weaponImageId) {
        _spriteWeapon_setup.apply(this, arguments);
        const url = this._bitmap._url;
        if (!url) return;
        if (!this._mz3d_weapon_model) {
            this._mz3d_weapon_model = new mz3d.Model();
            this._mz3d_weapon_model.setMeshForShape(mz3d.enumShapes.FLAT);
            this._mz3d_weapon_model.scaling.x = 1.5;
        }
        this._mz3d_weapon_model.setEnabled(false);
        this._mz3d_weapon_model.setMaterial(url).then(() => {
            this._mz3d_weapon_model.setEnabled(true);
            if (this._mz3d_weapon_model.texture) this._mz3d_weapon_model.cropTexture(this._frame.x, this._frame.y, this._frame.width, this._frame.height);
        });
    }
    const _spriteWeapon_setFrame = Sprite_Weapon.prototype.setFrame;
    Sprite_Weapon.prototype.setFrame = function (x, y, width, height) {
        _spriteWeapon_setFrame.apply(this, arguments);
        if (this._mz3d_weapon_model && this._mz3d_weapon_model.texture) {
            if (width || height) {
                if (!this._mz3d_weapon_model.isEnabled()) {
                    this._mz3d_weapon_model.setEnabled(true);
                    if (this._mz3d_alpha_characterSprite) {
                        this._mz3d_alpha_characterSprite._mz3d_alpha_updateWeaponMotion();
                    }
                }
                if (this._mz3d_weapon_model.texture) this._mz3d_weapon_model.cropTexture(x, y, width, height);
            } else {
                this._mz3d_weapon_model.setEnabled(false);
            }
        }
    }
    const _mz3d_character_dispose = mz3d.Character.prototype.dispose;
    mz3d.Character.prototype.dispose = function () {
        _mz3d_character_dispose.apply(this, arguments);
        if (!this.char.mv_sprite._aaSprWeapon || !this.char.mv_sprite._aaSprWeapon._originalSprWeapon) return;
        const weapon = this.char.mv_sprite._aaSprWeapon._originalSprWeapon;
        if (!weapon._mz3d_weapon_model) return;
        weapon._mz3d_weapon_model.dispose();
    }

    // skill impact selector
    const _aaCreateExtraMapDownLayer = Spriteset_Map.prototype.aaCreateExtraMapDownLayer;
    Spriteset_Map.prototype.aaCreateExtraMapDownLayer = function () {
        _aaCreateExtraMapDownLayer.apply(this, arguments);
        this.addChild(this._aaLayer01);
    }

    const _skillImpactSelector_update = AA.Sprite_SkillImpactSelector.prototype.update;
    AA.Sprite_SkillImpactSelector.prototype.update = function () {
        _skillImpactSelector_update.apply(this, arguments);
        if (!this.visible) return;
        if (mz3d.is3D() && $gameTemp._mz3d_anet_pointer) {
            const pointer = $gameTemp._mz3d_anet_pointer;
            const dist = BABYLON.Vector3.Distance(mz3d.camera.globalPosition, pointer);
            const scale = mz3d.getScaleForDist(dist);
            const yscale = Math.max(.2, Math.abs(Math.cos(mz3d.util.degtorad(mz3d.blendCameraPitch.currentValue()))));
            const xskew = (TouchInput.x / Graphics.width - .5) * (1 - yscale) * Math.PI;
            this.scale.set(scale, scale * yscale);
            this.skew.x = xskew;
        } else {
            this.scale.set(1, 1);
            this.skew.set(0, 0);
        }
    }

    if (mv3d.features.highlight) {
        const highlightMesh = mz3d.features.highlight.methods.highlightMesh.bind(mz3d.features.highlight.methods);
        const unHighlightMesh = mz3d.features.highlight.methods.unHighlightMesh.bind(mz3d.features.highlight.methods);
        const configureChar = mz3d.features.highlight.methods.configureChar.bind(mz3d.features.highlight.methods);

        const _aaSetSelectionBySkill = Sprite_Character.prototype._aaSetSelectionBySkill;
        Sprite_Character.prototype._aaSetSelectionBySkill = function () {
            _aaSetSelectionBySkill.apply(this, arguments);
            if (this._aaSelectBlendColor && this._character && this._character.mv3d_sprite) {
                const char = this._character.mv3d_sprite;
                const color = new BABYLON.Color3(...this._aaSelectBlendColor.slice(0, 3).map(c => c / 255));
                for (const mesh of char.model.meshes) {
                    highlightMesh(mesh, color);
                }
            }
        }
        const _aaResetSelectionBySkill = Sprite_Character.prototype._aaResetSelectionBySkill;
        Sprite_Character.prototype._aaResetSelectionBySkill = function () {
            _aaResetSelectionBySkill.apply(this, arguments);
            if (this._character && this._character.mv3d_sprite) {
                configureChar(this._character.mv3d_sprite);
            }
        }

    }

    // fix skill targeting (don't use screen positions)
    const _collectTargetsForPlayerSelector = AATargetsManager.collectTargetsForPlayerSelector;
    AATargetsManager.collectTargetsForPlayerSelector = function (aaSkill) {
        if (!mz3d.is3D()) return _collectTargetsForPlayerSelector.apply(this, arguments);
        try {
            let targets;
            const point = TouchInput.toMapPoint();
            if (AA.Utils.Math.getDistanceMapPlayerPoint(point) <= aaSkill.gRange()) {
                targets = this.collectTargetsForSkillInMapPoint(aaSkill, point);
            } else {
                targets = [];
            }
            return this.filteredTargetsForSubject($gamePlayer, aaSkill, targets);
        } catch (error) {
            AA.w(error);
            return [];
        }
    }

    // fix mappings on q&e (rotleft and rotright)
    // and also prevent pageup&pagedown from mapping to q&w.
    const reverseKeyLookup = Object.fromEntries(Object.entries(Input.KeyMapperPKD).map(([k, v]) => [k > 90 ? null : v, +k]));
    const convertUnsafeKey = AA.Input.convertUnsafeKey;
    AA.Input.convertUnsafeKey = function (key) {
        const code = reverseKeyLookup[String(key).toLowerCase()];
        if (code in Input.keyMapper) return Input.keyMapper[code];
        return convertUnsafeKey.apply(this, arguments);
    };

    // projectile sprites
    const aaCreateNewMapSkill = Spriteset_Map.prototype.aaCreateNewMapSkill;
    Spriteset_Map.prototype.aaCreateNewMapSkill = function (index) {
        aaCreateNewMapSkill.apply(this, arguments);
        const skill = this._aaMapSkills[index];
        if (skill) {
            //this.addChild(this._aaMapSkills[index]);
            skill._mz3d_skill_model = new mz3d.Model();
            skill._mz3d_skill_model.setMeshForShape(mz3d.enumShapes.FLAT);
            //skill._mz3d_skill_model.mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_NONE;
            skill._mz3d_skill_model.setEnabled(false);
            skill._mz3d_skill_model.setMaterial(decodeURIComponent(skill.image.bitmap._url)).then(() => {
                skill._updatePosition();
                skill._mz3d_skill_model.setEnabled(true);
                if (skill._mz3d_skill_model.texture) skill._mz3d_skill_model.cropTexture(skill.image._frame.x, skill.image._frame.y, skill.image._frame.width, skill.image._frame.height);
                skill._mz3d_skill_model.scaling.x = skill.image._frame.width / $gameMap.tileWidth();
                skill._mz3d_skill_model.scaling.z = skill.image._frame.height / $gameMap.tileHeight();
                try {
                    if(skill._mz3d_skill_model.material)
                        skill._mz3d_skill_model.material.emissiveColor.set(1, 1, 1);
                } catch (error) {
                    console.warn(error);
                }
            });
        }
    }

    const _projectile_setFrame = Sprite_AAMapSkill2Projectile.prototype._setImageFrame;
    Sprite_AAMapSkill2Projectile.prototype._setImageFrame = function (x, y, width, height) {
        _projectile_setFrame.apply(this, arguments);
        if (this._mz3d_skill_model && this._mz3d_skill_model.texture) {
            if (this._mz3d_skill_model.texture) this._mz3d_skill_model.cropTexture(x, y, width, height);
            this._mz3d_skill_model.scaling.x = width / $gameMap.tileWidth();
            this._mz3d_skill_model.scaling.z = height / $gameMap.tileHeight();
        }
    };

    const _projectile_update_position = Sprite_AAMapSkill2Projectile.prototype._updatePosition;
    Sprite_AAMapSkill2Projectile.prototype._updatePosition = function () {
        if (!mz3d.is3D()) return _projectile_update_position.apply(this, arguments);
        if (this.isEnd()) return;
        const skill = this.skill;
        const x = skill.x / $gameMap.tileWidth() - .5;
        const y = skill.y / $gameMap.tileHeight() - .5;
        const cosX = Math.cos(mz3d.util.degtorad(this._angle));
        const sinY = Math.sin(mz3d.util.degtorad(this._angle));
        const zTarget = mz3d.getWalkHeight(x + cosX, y + sinY) + PROJECTILE_Z_OFF;
        const zWall = mz3d.getWalkHeight(x + cosX / 2, y + sinY / 2) + PROJECTILE_Z_OFF;
        const zCurrent = mz3d.getWalkHeight(x, y) + PROJECTILE_Z_OFF;

        if (this._mz3d_z == undefined) {
            const subject = this.skill.getSubject();
            this._mz3d_z = isFinite(subject.z) ? Math.max(subject.z, Math.min(zWall, subject.z + PROJECTILE_CLIMB_HEIGHT)) : zWall;
            if (subject.jumpVelocity) this._mz3d_z += subject.jumpVelocity / 5;
        }

        const collisionSoon = zTarget - zCurrent > PROJECTILE_CLIMB_HEIGHT;

        if ((WALL_HIT_BEHAVIOR ? zWall : zCurrent) - this._mz3d_z > PROJECTILE_CLIMB_HEIGHT && !this._mz3d_collision) {
            this._mz3d_collision = WALL_HIT_BEHAVIOR ? {
                // hit the previous tile position instead of the top of the wall
                x: Math.floor((this.skill.x - this.dx) / $gameMap.tileWidth()),
                y: Math.floor((this.skill.y - this.dy) / $gameMap.tileHeight()),
            } : true;
        }
        if (!this._mz3d_collision && !collisionSoon) {
            let diff = zTarget - this._mz3d_z;
            if (Math.abs(diff) > 0.1) {
                this._mz3d_z = diff / (diff > 0 ? PROJECTILE_CLIMB_TIME : PROJECTILE_FALL_TIME) + this._mz3d_z;
            } else {
                this._mz3d_z = zTarget;
            }

        }

        if (this._mz3d_skill_model) {
            const model = this._mz3d_skill_model;
            model.x = x;
            model.y = y;
            model.z = this._mz3d_z;

            model.yaw = -this._angle + 270;
            model.pitch = 0;
            //model.update();

            const yawdiff = mz3d.util.degtorad(model.yaw - mz3d.blendCameraYaw.currentValue());
            const yawFactor = Math.sin(yawdiff);
            const pitchFactor = Math.sin(mz3d.util.degtorad(mz3d.blendCameraPitch.currentValue()));
            if (pitchFactor > .9) {
                const p = (pitchFactor - .9) * 10 * (mz3d.blendCameraPitch.currentValue() > 90 ? 1 : -1) * -Math.sign(Math.cos(yawdiff))
                model.pitch = p * 10;
            }

            model.roll = -yawFactor * pitchFactor * 90;
        }

        _projectile_update_position.apply(this, arguments);

    }

    // fix projectile collision
    const _checkCollision = Sprite_AAMapSkill2Projectile.prototype._checkCollision;
    Sprite_AAMapSkill2Projectile.prototype._checkCollision = function () {
        if (!mz3d.is3D()) return _checkCollision.apply(this, arguments);
        const x = this.x;
        const y = this.y;
        const disabled = mz3d.$saveData.disabled;
        mz3d.$saveData.disabled = true;
        _projectile_update_position.apply(this, arguments);
        _checkCollision.apply(this, arguments);
        mz3d.$saveData.disabled = disabled;
        this.x = x;
        this.y = y;
    }
    const _checkHitMap = Sprite_AAMapSkill2Projectile.prototype._checkHitMap;
    Sprite_AAMapSkill2Projectile.prototype._checkHitMap = function (tx, ty) {
        if (_checkHitMap.apply(this, arguments)) return true;
        return !!this._mz3d_collision;
    }
    const _onHit = Sprite_AAMapSkill2Projectile.prototype.onHit;
    Sprite_AAMapSkill2Projectile.prototype.onHit = function (target) {
        if (typeof this._mz3d_collision === 'object') {
            _onHit.call(this, this._mz3d_collision);
        } else {
            _onHit.apply(this, arguments);
        }
        if (this._hasHit && this._mz3d_skill_model) {
            this._mz3d_skill_model.dispose();
        }
    }
    const _onTimeEnded = Sprite_AAMapSkill2Projectile.prototype._onTimeEnded;
    Sprite_AAMapSkill2Projectile.prototype._onTimeEnded = function () {
        _onTimeEnded.apply(this, arguments);
        if (this._mz3d_skill_model) {
            this._mz3d_skill_model.dispose();
        }
    }

    // ==============================================
    // Path finding
    // ----------------------------------------------
    // Since both MZ3D and Alpha_ABSZ seem to make 
    // the pathing a bit more expensive, there are
    // some situations where the plugins together 
    // cause slowdown.
    // For example, when moving to an unreachable
    // position.
    // ==============================================

    // fix laggy path finding when moving to impassable tiles
    const character_findDirectionTo = Game_Character.prototype.findDirectionTo;
    const player_findDirectionTo = Game_Player.prototype.findDirectionTo;
    Game_Player.prototype.findDirectionTo = function (goalX, goalY) {
        // if the goal is impassible or we recently spent too much time pathfinding,
        // use the faster pathfinding method.
        if (this.canPass(goalX, goalY) &&
            !(Date.now() - this._mz3d_anet_slow_pathtime < 10000)) {
            // this is the more expensive branch
            delete this._mz3d_anet_last_dir;
            delete this._mz3d_anet_disallow_diagonal;
            delete this._mz3d_anet_slow_pathtime;
            const time1 = Date.now();
            const d = player_findDirectionTo.apply(this, arguments);
            const time2 = Date.now();
            if (time2 - time1 > 100) {
                // We spent too much time pathfinding :(
                this._mz3d_anet_disallow_diagonal = true;
                this._mz3d_anet_slow_pathtime = time2;
            }
            return d;
        } else {
            // this branch is cheaper
            let d;
            if (this._mz3d_anet_disallow_diagonal) {
                // this is the EXTRA cheap branch,
                // we save performance by not using ABSZ's path finding
                // as a result we can't move diagonal.
                this._mz3d_anet_search_limit = 12;
                d = character_findDirectionTo.apply(this, arguments);
                delete this._mz3d_anet_search_limit;
                return d;
            }
            // we know we can't reach the goal anyway so we leave the search limit at 1.
            this._mz3d_anet_search_limit = 1;
            d = player_findDirectionTo.apply(this, arguments);
            delete this._mz3d_anet_search_limit;
            if (!this.canPassDiagonally(this.x, this.y, mz3d.util.dirtoh(d), mz3d.util.dirtov(d))) {
                // if the diagonal direction we found is impassible, we try again without diagonal movement.
                // we can avoid getting stuck behind walls this way.
                d = character_findDirectionTo.apply(this, arguments);
            }
            if (this.reverseDir(d) === this._mz3d_anet_last_dir) {
                // if this happens the player is probably moving back and forth.
                // let's turn off diagonal movement until a new goal is chosen.
                this._mz3d_anet_disallow_diagonal = true;
                d = this._mz3d_anet_last_dir;
            }
            this._mz3d_anet_last_dir = d;
            return d;
        }
    }

    const searchLimit = Game_Character.prototype.searchLimit;
    Game_Character.prototype.searchLimit = function () {
        if (this._mz3d_anet_search_limit) {
            // override the search limit
            return this._mz3d_anet_search_limit;
        } else {
            if (this instanceof Game_Event) {
                // give events a smaller search limit to save performance.
                return Math.max(1, Math.round(searchLimit.apply(this, arguments) / 4)) // probably 6
            }
            return searchLimit.apply(this, arguments);
        }
    }

    // animations
    AABattleActionsManager.playAnimationOnCharacter = function (char, animationId) {
        try {
            if ((animationId != null) && animationId > 0) {
                if (char.z == undefined) {
                    char.z = mz3d.getWalkHeight(char.x, char.y);
                }
                AANetworkManager.playAnimationOnCharacter(char, animationId);
                $gameTemp.requestAnimation([char], animationId, {
                    depth: ANIMATION_DEPTH,
                    scale: ANIMATION_SCALE,
                });
            }
        } catch (error) {
            KDCore.warning("playAnimationOnCharacter", error);
        }
    }

    const processMapTouch = Scene_Map.prototype.processMapTouch;
    Scene_Map.prototype.processMapTouch = function () {
        if (Imported.PKD_MapInventory && PKD_MI.isProcessEUITouch()) {
            return;
        }
        if ($gameTemp.floatingWindowUnderMouse != null || $gameTemp.kdButtonUnderMouse != null) {
            return true;
        }
        return processMapTouch.call(this);
    };

    if (mz3d.setDestination && Scene_Map.prototype.onMapTouchAA) {
        const _setDestination = mz3d.setDestination;
        mz3d.setDestination = function (x, y, z) {
            Scene_Map.prototype.onMapTouchAA.call(SceneManager._scene);
            if ($gameTemp.isDestinationValid()) _setDestination.apply(this, arguments);
            delete $gamePlayer._mz3d_anet_disallow_diagonal;
        }
    }

    const Tilemap = window.ShaderTilemap || window.Tilemap;
    const removeChild = Tilemap.prototype.removeChild;
    Tilemap.prototype.removeChild = function (child) {
        removeChild.apply(this, arguments);
        if (child && child.parent) child.parent.removeChild(child);
    }

    function getScreenScale(pos) {
        if (!(pos instanceof BABYLON.Vector3)) {
            if (typeof pos.getAbsolutePosition === 'function') {
                pos = pos.getAbsolutePosition();
            } else if (pos.globalPosition) {
                pos = pos.globalPosition;
            }
        }
        let scale;
        if (mz3d.camera.mode === BABYLON.Constants.ORTHOGRAPHIC_CAMERA) {
            scale = mz3d.getScaleForDist();
        } else {
            const dist = BABYLON.Vector3.Distance(mz3d.camera.globalPosition, pos);
            scale = mz3d.getScaleForDist(dist);
        }
        return scale;
    }

    if (Imported.PKD_AnimaX && PKD_ANIMAX.version <= 131) {
        const _characterPatternY = Sprite_Character.prototype.characterPatternY;
        Sprite_Character.prototype.characterPatternY = function () {
            if (this.isAnimX()) {
                return 0;
            }
            return _characterPatternY.apply(this, arguments);
        };

        const _mz3d_isImageChanged = mz3d.Character.prototype.isImageChanged;
        mz3d.Character.prototype.isImageChanged = function () {
            if (_mz3d_isImageChanged.apply(this, arguments)) return true;
            if (this._character.mv_sprite && this._character.mv_sprite.isAnimX()) {
                return this._animaXBitmap !== this._character.mv_sprite.bitmap._url;
            }
            return false;
        }

        const _mz3d_updateCharacter = mz3d.Character.prototype.updateCharacter;
        mz3d.Character.prototype.updateCharacter = function () {
            if (this._character.mv_sprite && this._character.mv_sprite.isAnimX()) {
                this._animaXBitmap = this._character.mv_sprite.bitmap._url;
            }
            _mz3d_updateCharacter.apply(this, arguments);
        }

        const _mz3d_setMaterial = mz3d.Character.prototype.setMaterial;
        mz3d.Character.prototype.setMaterial = async function (src) {
            if (this._character.mv_sprite && this._character.mv_sprite.isAnimX()) {
                if (!this.model.material) await _mz3d_setMaterial.apply(this, arguments);
                let texture;
                if (!this.model.material._animaX_Textures) this.model.material._animaX_Textures = {};
                if (this.model.material._animaX_Textures[this._animaXBitmap]) {
                    texture = this.model.material._animaX_Textures[this._animaXBitmap];
                } else {
                    texture = await mz3d.createTexture(this._animaXBitmap);
                    if(this.model.material) {
                        try {
                            this.model.material._animaX_Textures[this._animaXBitmap] = texture;
                        } catch (error) {
                            console.warn(error);
                        }
                    }
                }
                await mz3d.waitTextureLoaded(texture);
                this.model.textureLoaded = true;
                texture.hasAlpha = true;
                this.model.texture = texture
                try {
                    if(this.model.material)
                        this.model.material.diffuseTexture = texture;
                } catch (error) {
                    console.warn(error);
                }
                //await this.model.setMaterial(this._animaXBitmap);
                this.updateScale();
                this.needsMaterialUpdate = true;
            } else {
                await _mz3d_setMaterial.apply(this, arguments);
            }
        }

        mz3d.util.override(XAnimaSet.prototype, 'getAnimationByDirection', o => function (dir) {
            return o.call(this, mz3d.transformFacing(dir, mz3d.blendCameraYaw.currentValue(), true));
        });


    }

    if(Imported.PKD_ExtendedLoot && PKD_ExtendedLoot.version <= 120){

        function sprite_updateTransform(pos){
            const screenPos = mz3d.getScreenPosition(pos);
            const scale = getScreenScale(pos);
            this.x = screenPos.x - this.width/2;
            this.y = screenPos.y - this.height;
            this.scale.set(scale,scale);
            this.visible = !screenPos.behindCamera;
        }

        const createDestination = Spriteset_Map.prototype.createDestination;
        Spriteset_Map.prototype.createDestination = function() {
            createDestination.apply(this,arguments);
            this.addChild(this._pelVisualDropItemsBase);
        }

        //const getDistanceToPlayerInPx = VisualDropItem.prototype.getDistanceToPlayerInPx;
        mz3d.util.override(VisualDropItem.prototype,'getDistanceToPlayerInPx', o=> function(){
            return $gameMap.distance(this.mx, this.my, $gamePlayer.x, $gamePlayer.y)*$gameMap.tileWidth();
        });

        const setStaticPosition = VisualDropItem.prototype.setStaticPosition;
        VisualDropItem.prototype.setStaticPosition = function(mx,my){
            setStaticPosition.apply(this,arguments);
            this.mz = mz3d.getWalkHeight(mx,my);
        }
        //const _updatePositionOnScreen = VisualDropItem.prototype._updatePositionOnScreen;
        mz3d.util.override(VisualDropItem.prototype,'_updatePositionOnScreen', o=> function(){
            //_updatePositionOnScreen.apply(this,arguments);
            const pos = new mz3d.Vector3(this.mx,this.my,this.mz);
            sprite_updateTransform.call(this,pos);
        });

        mz3d.util.override(VisualDropItem.prototype,'_updatePositionJump',o=>function() {
            this._char.updateJump();
            let jumpProgress = 1-(this._char._jumpCount/(this._char._jumpPeak*2));
            let jumpHeight = Math.pow(jumpProgress-0.5,2)*-4+1;
            let jumpDiff = Math.abs(this._char.mv3d_jumpHeightEnd - this._char.mv3d_jumpHeightStart);
            let z = this._char.mv3d_jumpHeightStart*(1-jumpProgress)
                + this._char.mv3d_jumpHeightEnd*jumpProgress + jumpHeight*jumpDiff/2
                + this._char.jumpHeight()/$gameMap.tileHeight();

            sprite_updateTransform.call(this,new mz3d.Vector3(this._char._realX,this._char._realY,z));
            if (!this._char.isJumping()) {
                this._completeJump();
            }
        });
        mz3d.util.override(VisualDropItem.prototype,'_startMoving', o=> function(){
            this._mz3d_move_duration = this.getSettings().moveSpeed;
            this._mz3d_move_x = this.mx;
            this._mz3d_move_y = this.my;
            this._mz3d_move_z = this.mz;
        });
        mz3d.util.override(VisualDropItem.prototype,'_updateMoveToPlayer', o=> function(){
            if(this._pic){ return o.apply(this,arguments); }
            this._mz3d_move_targetX = $gamePlayer._realX;
            this._mz3d_move_targetY = $gamePlayer._realY;
            this._mz3d_move_targetZ = $gamePlayer.z;
            const d = this._mz3d_move_duration;
            this._mz3d_move_x = (this._mz3d_move_x * (d - 1) + this._mz3d_move_targetX) / d;
            this._mz3d_move_y = (this._mz3d_move_y * (d - 1) + this._mz3d_move_targetY) / d;
            this._mz3d_move_z = (this._mz3d_move_z * (d - 1) + this._mz3d_move_targetZ) / d;
            this._mz3d_move_duration--;

            sprite_updateTransform.call(this,new mz3d.Vector3(this._mz3d_move_x,this._mz3d_move_y,this._mz3d_move_z));

            if (this._mz3d_move_duration <= 0) {
                this._completeMove();
            }
        },true);
        mz3d.util.override(VisualDropItem.prototype,'_completeMove', o=> function(){
            if(this._pic){ return o.apply(this,arguments); }
            this.setStaticPosition(this._mz3d_move_x, this._mz3d_move_y);
            delete this._mz3d_move_duration;
            delete this._mz3d_move_x;
            delete this._mz3d_move_y;
            delete this._mz3d_move_z;
            delete this._mz3d_move_targetX;
            delete this._mz3d_move_targetY;
            delete this._mz3d_move_targetZ;
            this._isMoving = false;
            this.gainItem();
        },true);

        mz3d.util.override(PEL_PopUpController.prototype,'_linkMe', o=> function(){
            o.apply(this,arguments);
            SceneManager._scene._spriteset.addChild(this);
            const char = this.parentCharacter._character;
            this.move(char.screenX()+this.params.margins.x, char.screenY()+this.params.margins.y);
        });

        mz3d.util.override(PEL_PopUpController.prototype,'update', o=> function(){
            o.apply(this,arguments);
            const char = this.parentCharacter._character;
            this.move(char.screenX()+this.params.margins.x, char.screenY()+this.params.margins.y);
        });

        mz3d.util.override(PEL_PopUpController.prototype,'_destroyMe', o=> function(){
            o.apply(this,arguments);
            if(this.parent) this.parent.removeChild(this);
        },true);
    }


};

// * Данный класс вынесен в .JS со старой реализацией, чтобы
// * вызвать this.eventId = eventId перед родительским конструктором
// * Остальной код в 2_AAEnemyBattler_Impl.coffee

function AAEnemyBattler() {
    this.initialize.apply(this, arguments);
}

AAEnemyBattler.prototype = Object.create(Game_Enemy.prototype);
AAEnemyBattler.prototype.constructor = AAEnemyBattler;

// * Так же передаём номер события, чтобы был доступ к модели и логике
AAEnemyBattler.prototype.initialize = function (enemyId, eventId) {
    this.eventId = eventId;
    Game_Enemy.prototype.initialize.call(this, enemyId, 0, 0);
    this.aaInit();
};

function Game_AASpawnedEvent() {
    this.initialize.apply(this, arguments);
}

Game_AASpawnedEvent.prototype = Object.create(Game_Event.prototype);
Game_AASpawnedEvent.prototype.constructor = Game_AASpawnedEvent;

Game_AASpawnedEvent.prototype.initialize = function (refEventId, x, y) {
    this.refEventId = refEventId;
    let newEventId = $gameMap._events.length;
    Game_Event.prototype.initialize.call(this, $gameMap.mapId(), newEventId);
    DataManager.extractMetadata(this.event());
    $gameMap._events[newEventId] = this;
    if (Imported.VisuMZ_1_EventsMoveCore == true && $gameMap._eventCache) {
        $gameMap._eventCache.push(this);
    }
    this.setPosition(x, y);
    this.aaAddOnSpriteset();
    this.aaCheckAndActivateABSBehaviour();
};

//$[OVER]
Game_AASpawnedEvent.prototype.aaIsSpawned = function () {
    return true;
};

//$[OVER]
Game_AASpawnedEvent.prototype.event = function () {
    return $dataAASpawnMap.events[this.refEventId];
};


//?[NEW]
// * Добавляемм спрайт события на карту (если текущая сцена карты)
Game_AASpawnedEvent.prototype.aaAddOnSpriteset = function () {
    try {
        if (!KDCore.Utils.isSceneMap()) {
            return;
        }
        SceneManager._scene._spriteset.aaAddSpawnedEvent(this); //this.eventId()
    } catch (e) {
        AA.w(e);
    }
};

//?[NEW]
// * Активируем ABS у события
Game_AASpawnedEvent.prototype.aaCheckAndActivateABSBehaviour = function() {
    if(this.isABS()) {
        this.initABS();
    }
};

class AA_Sprite_MapPathGrid extends KDCore.Sprite {
    constructor() {
        super();
        this._mapAnchor = new KDCore.MapAnchorPoint(0, 0);
        this.drawNodeGrid();
        this._pathSprites = [];
        this._refreshPathTimer = 0;
        this.opacity = 60;
    }

    static Show() {
        if(!this._instance) {
            this._instance = new AA_Sprite_MapPathGrid();
            SceneManager._scene.addChild(this._instance);
        } else {
            // * Remove old instance
            SceneManager._scene.removeChild(this._instance);
            this._instance = null;
            this.Show();
        }
    }

    update() {
        super.update();
        this.updatePathDrawing();
        this.x = this._mapAnchor.screenX(true) - 24;
        this.y = this._mapAnchor.screenY(true) - 48;
    }

    addNotPassableCell(x, y) {
        var cellSprite = new KDCore.Sprite(new Bitmap(48, 48));
        cellSprite.bitmap.fillAll('#FF0000');
        cellSprite.opacity = 140;
        cellSprite.x = x * 48;
        cellSprite.y = y * 48;
        this.addChild(cellSprite);
    }

    drawNodeGrid() {
        var grid = $gameMap.aaGetMapGrid();
        for(var i = 0; i < grid.width; i++) {
            for(var j = 0; j < grid.height; j++) {
                if(!grid.isWalkableAt(i, j)) {
                    this.addNotPassableCell(i, j);
                }
            }
        }
    }

    drawPath(path) {
        this.clearPath();
        if(!path) return;
        for(var i = 0; i < path.length; i++) {
            var cell = path[i];
            var cellSprite = new KDCore.Sprite(new Bitmap(48, 48));
            cellSprite.bitmap.fillAll('#0000FF');
            cellSprite.opacity = 190;
            cellSprite.x = cell[0] * 48;
            cellSprite.y = cell[1] * 48;
            this.addChild(cellSprite);
            this._pathSprites.push(cellSprite);
        }
    }

    updatePathDrawing() {
        if(this._refreshPathTimer > 0) {
            this._refreshPathTimer--;
            return;
        }

        if($gameMap._aaLastPath) {
            this.drawPath($gameMap._aaLastPath);
            this._refreshPathTimer = 30;
        }
    }

    clearPath() {
        for(var i = 0; i < this._pathSprites.length; i++) {
            this.removeChild(this._pathSprites[i]);
        }
        this._pathSprites = [];
    }

}

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){

    var _ = Game_CharacterBase.prototype;

    _.aaMakePathTo = function(x, y) {
        var path = $gameMap.aaFindPathFromCharacterToPoint(this, x, y);
        if(path && path.length > 0) {
            path.shift();   // * Remove first cell (current cell)
            this.aaStartMoveByPath(path);
        } else {
            this.aaClearMovePath();
        }
    };

    _.aaMakePathToCharacter = function(character) {
        var path = $gameMap.aaFindPathBetweenCharacters(this, character);
        if(path && path.length > 0) {
            path.shift();   // * Remove first cell (current cell)
            this.aaStartMoveByPath(path);
        } else {
            this.aaClearMovePath();
        }
    };


    _.aaStartMoveByPath = function(path) {
        this._aaMovePath = path;
    };

    _.aaIsHaveMovePath = function() {
        return this._aaMovePath && this._aaMovePath.length > 0;
    };

    _.aaGetMovePath = function() {
        return this._aaMovePath;
    };

    _.aaClearMovePath = function() {
        this._aaMovePath = null;
    };

    _.aaMakeNextMoveByPath = function() {
        if(this.aaIsHaveMovePath()) {
            var cell = this._aaMovePath.shift();
            var withDiagonal = this.aaIsThisCharCanUseDiagMovement();
            var direction = this.aaGetDirectionTo(cell[0], cell[1], withDiagonal);
            var isDiagonalDirection = direction % 2 === 1;
            if(isDiagonalDirection) {
                var [h, v] = AA.Utils.get8Dir(direction);
                this.moveDiagonally(h, v);
            } else
                this.moveStraight(direction);
        }
    };

    _.onMoveByPathEnd = function() {
        if(!this._aaMovePath) return;
        this.aaClearMovePath();
        //console.log('Path end');
    };

    _.aaGetDirectionTo = function(x, y, withDiagonal) {

        var dx = x - this.x;
        var dy = y - this.y;

        if (dx === 0 && dy === 0) {
            return 0;
        }

        if(withDiagonal) {
            if (dx > 0 && dy > 0) {
                return 3;
            } else if (dx < 0 && dy > 0) {
                return 1;
            } else if (dx > 0 && dy < 0) {
                return 9;
            } else if (dx < 0 && dy < 0) {
                return 7;
            }
        }

        var absDx = Math.abs(dx);
        var absDy = Math.abs(dy);
        if (absDx > absDy) {
            return dx > 0 ? 6 : 4;
        } else {
            return dy > 0 ? 2 : 8;
        }
    };

    _.aaGetRandomPointAroundMyPosition = function(radius, withDiagonal) {
        var angle = Math.random() * Math.PI * 2;
        var x = this.x + Math.cos(angle) * radius;
        var y = this.y + Math.sin(angle) * radius;

        if(x < 0) x = 0;
        if(y < 0) y = 0;

        if(withDiagonal) {
            return {x: Math.round(x), y: Math.round(y)};
        } else {
            return {x: Math.floor(x), y: Math.floor(y)};
        }
    };

})();
// ■ END Game_CharacterBase.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    var _ = Game_CharacterBase.prototype;

    _.aaSmartPathRefreshTime = function() {
        return 20;
    };

    _.aaMoveTypeToTarget = function() {
        try {
            var target = this.AAEntity().getTarget();
            if(!target) {
                this.aaClearMovePath();
                return;
            }
            this.aaUpdateSmartMoveToTarget(target);
            if(!this.isMoving()) {
                this.aaTurnTowardTarget();
            }
            this.aaUpdateMoveByPathForAI();
        } catch (error) {
            console.warn(error);
            this.aaClearMovePath();
        }
    };

    _.aaUpdateMoveByPathForAI = function() {
        if(this.aaIsHaveMovePath()) {
            if(!this.isMoving()) {
                this.aaMakeNextMoveByPath();
            }
        } else {
            this.onMoveByPathEnd();
        }
    };

    _.aaIsCanPerformNextMoveAction = function(target) {
        return !target.aaIsDodging();
    };

    _.aaUpdateSmartMoveToTarget = function(target) {
        if(this._aaSmartPathTimer === undefined) {
            this._aaSmartPathTimer = 0;
        }
        if(this._aaSmartPathTimer > 0) {
            this._aaSmartPathTimer--;
            return;
        } else {
            if(!this.aaIsCanPerformNextMoveAction(target)) {
                this.aaTurnTowardTarget();
                return;
            }
            this._aaSmartPathTimer = this.aaSmartPathRefreshTime();
            //console.log('MAKE PATH TO TARGET');
            this.aaMakePathToCharacter(target);
            if(!this.aaIsHaveMovePath()) {
                //console.log('Direct Path not found');
                // * Try get point around target and get closer
                var randomPoint = target.aaGetRandomPointAroundMyPosition(3, true);
                if(randomPoint) {
                    //console.log(randomPoint);
                    this.aaMakePathTo(randomPoint.x, randomPoint.y);
                }
            }
        }
    };

    _.aaMoveTypeToPoint = function(point) {
        try {
            if(!point) {
                this.aaClearMovePath();
                return;
            }
            this.aaUpdateSmartMoveToPoint(point);
            this.aaUpdateMoveByPathForAI();
        } catch (error) {
            this.aaClearMovePath();
        }
    };

    _.aaUpdateSmartMoveToPoint = function(point) {
        if(this._aaSmartPathTimer === undefined) {
            this._aaSmartPathTimer = 0;
        }
        if(this._aaSmartPathTimer > 0) {
            this._aaSmartPathTimer--;
            return;
        } else {
            this._aaSmartPathTimer = this.aaSmartPathRefreshTime();
            try {
                if(point instanceof Game_CharacterBase) {
                    this.aaMakePathToCharacter(point);
                } else {
                    this.aaMakePathTo(point.x, point.y);
                }
            } catch (error) {
                console.warn(error);
                this.aaClearMovePath();
            }
        }
    };

})();
// ■ END Game_CharacterBase.js
//---------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    var _ = Game_Event.prototype;

    _.aaIsPassableOnMap = function() {
        if(this.isThrough()) {
            return true;
        }
        if(this.isDebugThrough()) {
            return true;
        }
        if(!this.isNormalPriority()) {
            return true;
        }
        if(this._erased) {
            return true;
        }
        return false;
    };

})();
// ■ END Game_Event.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){

    var _ = Game_Map.prototype;

    _.aaFindPath = function(x1, y1, x2, y2, isDiagonal = true) {
        var finder = new PF.AStarFinder({
            allowDiagonal: isDiagonal,
            dontCrossCorners: true
        });
        var grid = this.aaGetMapGrid();
        var path = finder.findPath(x1, y1, x2, y2, grid);
        this._aaLastPath = path;
        return path;
    };

    _.aaFindPathBetweenCharacters = function(char1, char2) {
        $gameTemp.aaPathFindIgnoreCharacters = [char1, char2];
        var path = this.aaFindPath(char1.x, char1.y, char2.x, char2.y, char1.aaIsThisCharCanUseDiagMovement());
        $gameTemp.aaPathFindIgnoreCharacters = null;
        return path;
    };

    _.aaFindPathFromCharacterToPoint = function(character, x, y) {
        $gameTemp.aaPathFindIgnoreCharacters = [character];
        var path = this.aaFindPath(character.x, character.y, x, y, character.aaIsThisCharCanUseDiagMovement());
        $gameTemp.aaPathFindIgnoreCharacters = null;
        return path;
    };

    _.aaGetMapGrid = function() {
        if(!this._aaMapPathGrid) {
            this.aaCreateMapGrid();
        }
        let actualGrid = this._aaMapPathGrid.clone();

        if(!$gameTemp.aaPathFindIgnoreCharacters) {
            $gameTemp.aaPathFindIgnoreCharacters = [];
        }

        // * Add dynamic colliders
        this.aaAddDynamicCollidersToGrid(actualGrid);

        return actualGrid;
    };

    _.aaCreateMapGrid = function() {
        this._aaMapPathGrid = new PF.Grid(this.width(), this.height());
            for(var x = 0; x < this.width(); x++) {
                for(var y = 0; y < this.height(); y++) {
                    if(!this.aaIsPassableForMapGrid(x, y)) {
                        this.aaSetNotWalkableCellForGrid(this._aaMapPathGrid, x, y);
                    }
                }
            }
    };

    _.aaSetNotWalkableCellForGrid = function(mapGrid, x, y) {
        mapGrid.setWalkableAt(x, y, false);
    };

    _.aaIsPassableForMapGrid = function(x, y) {
        return this.isPassable(x, y, 8);
    };

    _.aaAddDynamicCollidersToGrid = function(grid) {
        if(!$gameTemp.aaPathFindIgnoreCharacters.contains($gamePlayer)) {
            this.aaSetNotWalkableCellForGrid(grid, $gamePlayer.x, $gamePlayer.y);
        }
        var events = this.events();
        for(var i = 0; i < events.length; i++) {
            var event = events[i];
            if(!event.aaIsPassableOnMap() && !$gameTemp.aaPathFindIgnoreCharacters.contains(event)) {
                var x = event.x;
                var y = event.y;
                if(x > 0 && y > 0) {
                    this.aaSetNotWalkableCellForGrid(grid,x, y);
                }
            }
        }
    };

})();
// ■ END Game_Map.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

// * Теперь будет работать мульти тоуч, т.е. можно будет нажимать несколько
// кнопок сразу (навыки и кнопки), работает с Mobile Controls
// можно ходить на джойстик (удерживая) и нажимать при этом атаку или навыки

AA.ApplyMultitouchMode = function(){
    
    //$[OVER]
    TouchInput._onTouchStart = function(event) {
        this._pMultiTouches = [];
        for (const touch of event.changedTouches) {
            const x = Graphics.pageToCanvasX(touch.pageX);
            const y = Graphics.pageToCanvasY(touch.pageY);
            if (Graphics.isInsideCanvas(x, y)) {
                this._screenPressed = true;
                this._pressedTime = 0;
                if (event.touches.length >= 2) {
                    //this._onCancel(x, y);
                    for(let touchX of event.touches) {
                        let xx = Graphics.pageToCanvasX(touchX.pageX);
                        let yy = Graphics.pageToCanvasX(touchX.pageY);
                        this._pMultiTouches.push({x: xx, y: yy});
                    }
                    this._onTrigger(x, y);
                } else {
                    this._onTrigger(x, y);
                }
                event.preventDefault();
            }
        }
        if (window.cordova || window.navigator.standalone) {
            event.preventDefault();
        }
    };

    TouchInput.pIsMultiTouched = function() {
        return this._pMultiTouches && this._pMultiTouches.length > 0;
    };

    TouchInput.pClearMultiTouch = function() {
        this._pMultiTouches = [];
    };

    //@[ALIAS]
    var _alias_TouchInput__onTouchEnd = TouchInput._onTouchEnd;
    TouchInput._onTouchEnd = function (event) {
        if(this.pIsMultiTouched()) {
            this.pClearMultiTouch();
            _alias_TouchInput__onTouchEnd.call(this, event);
            this._screenPressed = true;
        } else
            _alias_TouchInput__onTouchEnd.call(this, event);
    };

    // * KDCore.Sprite Extension
    (function(){
        var _ = KDCore.Sprite.prototype;

        _.isUnderMouse = function() {
            let isUnderMouseX = this.inPosition(TouchInput);
            if(isUnderMouseX) {
                return true;
            } else {
                if(TouchInput.pIsMultiTouched()) {
                    for(let touch of TouchInput._pMultiTouches) {
                        if(this.inPosition(touch)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };
    })();

};


if (KDCore.isMV() && !window.FontManager) {

    //-----------------------------------------------------------------------------
    // FontManager
    //
    // The static class that loads font files.

    function FontManager() {
        throw new Error("This is a static class");
    }

    FontManager._urls = {};
    FontManager._states = {};

    FontManager.load = function(family, filename) {
        if (this._states[family] !== "loaded") {
            if (filename) {
                const url = this.makeUrl(filename);
                this.startLoading(family, url);
            } else {
                this._urls[family] = "";
                this._states[family] = "loaded";
            }
        }
    };

    FontManager.isReady = function() {
        for (const family in this._states) {
            const state = this._states[family];
            if (state === "loading") {
                return false;
            }
            if (state === "error") {
                this.throwLoadError(family);
            }
        }
        return true;
    };

    FontManager.startLoading = function(family, url) {
        const source = "url(" + url + ")";
        const font = new FontFace(family, source);
        this._urls[family] = url;
        this._states[family] = "loading";
        font.load()
            .then(() => {
                document.fonts.add(font);
                this._states[family] = "loaded";
                return 0;
            })
            .catch(() => {
                this._states[family] = "error";
            });
    };

    FontManager.throwLoadError = function(family) {
        const url = this._urls[family];
        const retry = () => this.startLoading(family, url);
        throw ["LoadError", url, retry];
    };

    FontManager.makeUrl = function(filename) {
        return "fonts/" + Utils.encodeURI(filename);
    };

    Utils.encodeURI = function(str) {
        return encodeURIComponent(str).replace(/%2F/g, "/");
    };


}

/*Spriteset_Base.prototype.createAnimation = function(request) {
    const animation = $dataAnimations[request.animationId];
    const targets = request.targets;
    const mirror = request.mirror;
    let delay = this.animationBaseDelay();
    const nextDelay = this.animationNextDelay();
    if (this.isAnimationForEach(animation)) {
        for (const target of targets) {
            this.createAnimationSprite([target], animation, mirror, delay);
            delay += nextDelay;
        }
    } else {
        this.createAnimationSprite(targets, animation, mirror, delay);
    }
};

Spriteset_Base.prototype.createAnimationSprite = function(
    targets, animation, mirror, delay
) {
    const mv = this.isMVAnimation(animation);
    const sprite = new (mv ? Sprite_AnimationMV : Sprite_Animation)();
    const targetSprites = this.makeTargetSprites(targets);
    const baseDelay = this.animationBaseDelay();
    const previous = delay > baseDelay ? this.lastAnimationSprite() : null;
    if (this.animationShouldMirror(targets[0])) {
        mirror = !mirror;
    }
    sprite.targetObjects = targets;
    sprite.setup(targetSprites, animation, mirror, delay, previous);
    this._effectsContainer.addChild(sprite);
    this._animationSprites.push(sprite);
};

Sprite_Animation.prototype.updateEffectGeometry = function() {
    const scale = this._animation.scale / 100;
    const r = Math.PI / 180;
    const rx = this._animation.rotation.x * r;
    const ry = this._animation.rotation.y * r;
    const rz = this._animation.rotation.z * r;
    if (this._handle) {
        this._handle.setLocation(0, 0, 0);
        this._handle.setRotation(rx, ry, rz);
        this._handle.setScale(scale, scale, scale);
        this._handle.setSpeed(this._animation.speed / 100);
    }
};

Sprite_Animation.prototype.update = function() {
    Sprite.prototype.update.call(this);
    if (this._delay > 0) {
        this._delay--;
    } else if (this._playing) {
        if (!this._started && this.canStart()) {
            if (this._effect) {
                if (this._effect.isLoaded) {
                    this._handle = Graphics.effekseer.play(this._effect);
                    this._started = true;
                } else {
                    EffectManager.checkErrors();
                }
            } else {
                this._started = true;
            }
        }
        if (this._started) {
            this.updateEffectGeometry();
            this.updateMain();
            this.updateFlash();
        }
    }
};


Game_Temp.prototype.animation = function(x, y) {

    SceneManager._scene._spriteset.aaCreateAnimationOnMap(x, y);
    
};

Game_Temp.prototype.animationCursor = function() {
    setTimeout(() => {
        "START".p();
        SceneManager._scene._spriteset.aaCreateLinkedAnimation();
    }, 250);
};
*/

/*Sprite_Animation.prototype._render = function(renderer) {
    if (this._targets.length > 0 && this._handle && this._handle.exists) {
        this.onBeforeRender(renderer);
        this.setProjectionMatrix(renderer);
        this.setCameraMatrix(renderer);
        this.setViewport(renderer);
        Graphics.effekseer.beginDraw();
        Graphics.effekseer.drawHandle(this._handle);
        Graphics.effekseer.endDraw();
        this.resetViewport(renderer);
        this.onAfterRender(renderer);
    }
};

Sprite_Animation.prototype.targetSpritePosition = function(sprite) {
    const point = new Point(0, -sprite.height / 2);
    if (this._animation.alignBottom) {
        point.y = 0;
    }
    if(!sprite.parent) {
        sprite.parent = SceneManager._scene._spriteset._tilemap;
    }
    sprite.updateTransform();
    return sprite.worldTransform.apply(point);
};*/

// Generated by CoffeeScript 2.6.1
// * Основной класс объекта АБС на карте (монстр, игрок и т.д.)

//@[STORABLE]
//@[GLOBAL]
var AAEntity;

AAEntity = class AAEntity {
  constructor() {
    this._setup();
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
  }

  _setup() {
    this._active = false;
    this._target = null;
    this._dead = false;
    // * Состояние
    return this._state = null;
  }

  // * UPDATE
  // -----------------------------------------------------------------------
  update() {}

  // * ABS
  // -----------------------------------------------------------------------
  initABS() {
    return this.activate();
  }

  // * PROPERTIES
  // -----------------------------------------------------------------------
  isHaveTeamId() {
    return (this.battler() != null) && (this.battler().aaNetGetTeamId() != null);
  }

  teamId() {
    return 0;
  }

  character() {}

  battler() {}

  sprite() {
    if ($gameMap.aaSpriteset() != null) {
      return $gameMap.aaSpriteset().findTargetSprite(this.character());
    } else {
      return null;
    }
  }

  logic() {
    return null;
  }

  // * HELPERS
  // -----------------------------------------------------------------------
  isMyEnemy(aaEntity) {
    if (aaEntity == null) {
      return false;
    }
    if (!aaEntity.isActive()) {
      return false;
    }
    return aaEntity.teamId() !== this.teamId();
    return false;
  }

  // * Эти поля используются для опеределения типа дочернего класса
  isPlayer() {
    return false;
  }

  isAlly() {
    return false;
  }

  isNetChar() {
    return false;
  }

  isEnemy() {
    return false;
  }

  // * TARGET
  // -----------------------------------------------------------------------
  setTarget(target) {
    return this._target = AA.Utils.packAAEntity(target);
  }

  resetTarget() {
    return this.setTarget(null);
  }

  getTarget() {
    return AA.Utils.unpackAAEntity(this._target);
  }

  isHasTarget() {
    return this._target != null;
  }

  
    // * MAIN STATE
  // -----------------------------------------------------------------------
  isActive() {
    return this._active === true;
  }

  activate() {
    return this._active = true;
  }

  deactivate() {
    return this._active = false;
  }

  // * BATTLE STATE
  // -----------------------------------------------------------------------
  // * Зависит от наличия цели
  inBattle() {
    return this.isHasTarget();
  }

  resetBattle() {
    return this.resetTarget();
  }

  // * DEAD STATE
  // -----------------------------------------------------------------------
  isDead() {
    return this._dead === true;
  }

  setDead() {
    return this._dead = true;
  }

  resetDead() {
    return this._dead = false;
  }

  // * NETWORK
  // -----------------------------------------------------------------------
  _setupForNetwork() {
    return this._createNetworkObserver();
  }

  //TODO: Возможно нужен Instant режим?
  _createNetworkObserver() {
    this.netDataObserver = new DataObserver();
    this.netDataObserver.setCheckInterval(ANET.PP.playerDataRefreshRate());
    this._fillNetworkObserver();
    this.netDataObserver.refreshAll(this);
  }

  _fillNetworkObserver() {
    this.netDataObserver.addFields(this, ["_target", "_active"]);
  }

  updateDataObserver() {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.check(this);
    if (this.netDataObserver.isDataChanged()) {
      this.dataObserverHaveChanges();
      this.netDataObserver.refreshAll(this);
    }
  }

  // * Этот метод вызывается, когда изменились сихнронизируеммые данные
  dataObserverHaveChanges() {
    AANetworkManager.syncAAEntityObserver(this.character(), this.getObserverDataForNetwork());
  }

  getObserverDataForNetwork() {
    var data;
    data = this.netDataObserver.getDataForNetwork(this);
    return data;
  }

  applyObserverData(data) {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.setDataFromNetwork(this, data);
  }

};


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер расширений (кода совместимости)

//rev 26.02.2022 (используется аналогичный в NETZ)
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ IMPLEMENTATION.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA;
  // * Добавить метод расширения
  _.extend = function(method) {
    if (AA.__extenders == null) {
      AA.__extenders = [];
    }
    AA.__extenders.push(method);
  };
  // * Загрузить (выполнить) все методы расширения
  _.loadExtensions = function() {
    var i, len, method, ref;
    if (AA.__extenders == null) {
      return;
    }
    ref = AA.__extenders;
    for (i = 0, len = ref.length; i < len; i++) {
      method = ref[i];
      method();
    }
    // * Освобождение памяти
    AA.__extenders = null;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менедреж управления персонажем в АБС
AA.Input = function() {};

// * Кнопки управления
AA.IKey = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Input;
  // * Коэффицент скорости перемещения по диагонали
  _.diagonalSpeed = 0.95;
  // * Клавишы навыков (ячеек) для левой и правой кнопок мыши
  _.primarySkillSymbol = function() {
    return this.skillPanelSymbols[0];
  };
  _.secondarySkillSymbol = function() {
    return this.skillPanelSymbols[1];
  };
  // * Количество ячеек для навыков (и соответсвенно кнопок для них)
  // * Кнопки имеют имя SKL_(INDEX), от 0
  _.skillsSymbolsCount = function() {
    return this.skillPanelSymbols.length;
  };
  _.getTriggeredSkillSymbol = function() {
    var i, key, len, ref;
    ref = this.__skillSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (Input.isTriggered(AA.IKey[key[0]])) {
        return key[1];
      }
    }
    return null;
  };
  _.init = function(settings1) {
    this.settings = settings1;
    _.IsDiagonal = this.settings.isDiagonalMovement;
    // * Параметр был добавлен позже, поэтому проверка что он существует
    if (this.settings.isDiagonalMovementAI == null) {
      _.IsDiagonalForAI = _.IsDiagonal;
    } else {
      _.IsDiagonalForAI = this.settings.isDiagonalMovementAI;
    }
    _.IsStaticAttackWhenRotating = this.settings.isStaticAtkRot;
    this._loadSkillPanelSymbols();
    this.applyInputSettings();
    this.applyKeybindings();
    return this.applyMultitouch();
  };
  //"INIT ABS INPUT SUB SYSTEM".p()

  // * Загружаем кнопки, которые назначены для панели навыков
  _._loadSkillPanelSymbols = function() {
    return this.skillPanelSymbols = AA.PP.getUISkillsItems().map(function(item) {
      return item.symbol;
    });
  };
  // * Загружает данные с настроек плагина
  _.applyKeybindings = function() {
    // * WASD нельзя переопределить из параметров
    this._asignKeyForAASymbol("ML", "a");
    this._asignKeyForAASymbol("MR", "d");
    this._asignKeyForAASymbol("MU", "w");
    this._asignKeyForAASymbol("MD", "s");
    this._asignDefaultActionsKeys();
    this._asingSkillPanelKeys();
  };
  _._asignKeyForAASymbol = function(symbol, key) {
    key = this.convertUnsafeKey(key);
    AA.IKey[symbol] = key;
  };
  _._asignDefaultActionsKeys = function() {
    this._asignKeyForAASymbol("REL", this.settings.kbReload);
    this._asignKeyForAASymbol("CMD", this.settings.kbCommandMenu);
    this._asignKeyForAASymbol("ROT", this.settings.kbRotate);
  };
  _._asingSkillPanelKeys = function() {
    var i, index, key, len, ref, symb;
    // * Дополнительно присвоим для атак свои индтификаторы кнопок
    this._asignKeyForAASymbol("ATK1", this.primarySkillSymbol());
    this._asignKeyForAASymbol("ATK2", this.secondarySkillSymbol());
    // * Теперь для всех навыков (включая атаки тоже, дублируются)
    // * Для более быстрой проверки нажатия, отдельный массив
    this.__skillSymbols = [];
    ref = this.skillPanelSymbols;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      symb = ref[index];
      key = "SKL_" + index;
      this._asignKeyForAASymbol(key, symb);
      this.__skillSymbols.push([key, symb]);
    }
  };
  // * Проверка на кнопки, которые переопределены RPG Maker'ом и не будут работать так
  _.convertUnsafeKey = function(key) {
    if (key == null) {
      return '';
    }
    key = key.toLowerCase();
    switch (key) {
      case 'q':
        return 'pageup';
      case 'w':
        return 'pagedown';
      case 'x':
        return 'escape';
      case 'z':
      case 'space':
        return 'ok';
      default:
        return key;
    }
  };
  _.applyInputSettings = function() {
    this._applyMoveType();
    this._applyLMBMapTouchMode();
    this._applyRMBMapTouchMode();
    this._applyLMBTargetTouchMode();
    this._applyRMBTargetTouchMode();
  };
  _._applyMoveType = function() {
    var mt;
    mt = this.settings.moveType;
    if (mt.contains("WASD")) {
      this._applyWasdAndArrowMoveType();
    }
  };
  // * Движение и на WASD и на стрелки
  _._applyWasdAndArrowMoveType = function() {
    var signXAA, signXAAmc, signYAA, signYAAmc;
    // * Store default methods
    AA.Input.__Input_signX = Input._signX;
    AA.Input.__Input_signY = Input._signY;
    signXAA = function() {
      var x;
      x = 0;
      if (this.isPressed(AA.IKey.ML) || this.isPressed("left")) {
        x--;
      }
      if (this.isPressed(AA.IKey.MR) || this.isPressed("right")) {
        x++;
      }
      return x;
    };
    signYAA = function() {
      var y;
      y = 0;
      if (this.isPressed(AA.IKey.MU) || this.isPressed("up")) {
        y--;
      }
      if (this.isPressed(AA.IKey.MD) || this.isPressed("down")) {
        y++;
      }
      return y;
    };
    if (Imported.PKD_MobileControls === true) {
      signXAAmc = function() {
        if (PKD_MobileControls.IsInputInJoystick()) {
          return AA.Input.__Input_signX();
        } else {
          return signXAA.bind(Input)();
        }
      };
      signYAAmc = function() {
        if (PKD_MobileControls.IsInputInJoystick()) {
          return AA.Input.__Input_signY();
        } else {
          return signYAA.bind(Input)();
        }
      };
    }
    //$[OVER]
    // * Переопределяет методы Input
    if (Imported.PKD_MobileControls === true) {
      Input._signX = signXAAmc;
      Input._signY = signYAAmc;
    } else {
      Input._signX = signXAA;
      Input._signY = signYAA;
    }
  };
  // * Режим нажатия ЛЕВОЙ кнопкой мыши ПО КАРТЕ (без цели)
  //? 0 - Attack only
  //? 1 - Default (move)
  //? 2 - Nothing
  _._applyLMBMapTouchMode = function() {
    var option;
    _.LMBMapTouchMode = 1; // * Deafult
    option = this.settings.LMBMapTouchMode;
    if (option.contains("att")) {
      _.LMBMapTouchMode = 0;
    } else if (option.contains("Noth")) {
      _.LMBMapTouchMode = 2;
    }
  };
  // * Режим нажатия ПРАВОЙ кнопкой мыши ПО КАРТЕ (без цели)
  //? 0 - Default (open menu)
  //? 1 - Attack only (second skill)
  //? 2 - Move
  //? 3 - Turn
  //? 4 - Nothing
  _._applyRMBMapTouchMode = function() {
    var option;
    _.RMBMapTouchMode = 0; // Default
    option = this.settings.RMBMapTouchMode;
    if (option.contains("att")) {
      _.RMBMapTouchMode = 1;
    } else if (option.contains("Mov")) {
      _.RMBMapTouchMode = 2;
    } else if (option.contains("Tur")) {
      _.RMBMapTouchMode = 3;
    } else if (option.contains("Noth")) {
      _.RMBMapTouchMode = 4;
    }
  };
  //? 0 - Attack only
  //? 1 - Default (move)
  //? 2 - Smart attack
  //? 3 - Turn
  // * Режим нажатия ЛЕВОЙ кнопкой мыши ПО ЦЕЛИ
  _._applyLMBTargetTouchMode = function() {
    var option;
    _.LMBTargetTouchMode = 1; // * Default (Move)
    option = this.settings.LMBTargetTouchMode;
    if (option.contains("Smar")) {
      _.LMBTargetTouchMode = 2;
    } else if (option.contains("Primary")) {
      _.LMBTargetTouchMode = 0;
    } else if (option.contains("Tur")) {
      _.LMBTargetTouchMode = 3;
    }
  };
  //? 0 - Attack only
  //? 1 - Move
  //? 2 - Smart attack
  //? 3 - Turn
  // * Режим нажатия ПРАВОЙ кнопкой мыши ПО ЦЕЛИ
  _._applyRMBTargetTouchMode = function() {
    var option;
    _.RMBTargetTouchMode = 0; // * Attack only
    option = this.settings.RMBTargetTouchMode;
    if (option.contains("Smart")) {
      _.RMBTargetTouchMode = 2;
    } else if (option.contains("Mov")) {
      _.RMBTargetTouchMode = 1;
    } else if (option.contains("Tur")) {
      _.RMBTargetTouchMode = 3;
    }
  };
  // * Вспомогательные методы
  // ==================================================================

  // * Данный слот можно редактировать
  _.isEditableSymbol = function(symbol) {
    var e, settings;
    try {
      settings = AA.PP.getUISkillItemSlotSettings(symbol);
      if (settings == null) {
        return true;
      }
      // * Для совместимости со старыми настройками
      // (когда не было isEditable) исп. != false
      return settings.isEditable !== false;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Слот поддерживает автоматическое добавление в него
  _.isSymbolSupportAutoBinding = function(symbol) {
    var e, settings;
    try {
      settings = AA.PP.getUISkillItemSlotSettings(symbol);
      if (settings == null) {
        return true;
      }
      // * Для совместимости со старыми настройками
      // (когда не было isAutoset) исп. != false
      return settings.isAutoset !== false;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * MULTITOUCH (mobile only)
  // ======================================================================
  _.applyMultitouch = function() {
    var e;
    try {
      if (this.settings.multiTouch !== true) {
        return;
      }
      return AA.ApplyMultitouchMode();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер сетевого режима (совместимость с Alpha NET Z)
AA.Network = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Network;
  //@[DEPRECATED]
  _.NETCmdPrefix = "aabsz:";
  _.setPvPMode = function() {
    return $gameSystem.aaIsPvPActive = true;
  };
  _.setPvEMode = function() {
    return $gameSystem.aaIsPvPActive = false;
  };
  _.isNetworkGame = function() {
    if (Imported.Alpha_NETZ === true) {
      return ANNetwork.isConnected();
    } else {
      AA.Network.isNetworkGame = function() {
        return false;
      };
      return false;
    }
  };
  _.isNetworkPvPGame = function() {
    // * load default value
    if ($gameSystem.aaIsPvPActive == null) {
      $gameSystem.aaIsPvPActive = AA.PP.isNetworkPvPGame();
    }
    return this.isNetworkGame() && $gameSystem.aaIsPvPActive === true;
  };
  //TODO: Это скорее всего можно убрать, новый метод broadcast
  _.isShouldIgnoreServerCommand = function(servCommand) {
    var actorId;
    ({actorId} = servCommand);
    return actorId === ANGameManager.myActorId();
  };
  _.isAvailableForVisual = function(servCommand) {
    return $gameTemp._aaCanReceiveVisualFromServer === true && this.isOnSameMap(servCommand) && KDCore.Utils.isSceneMap() && !SceneManager.isSceneChanging();
  };
  _.isOnSameMap = function(servCommand) {
    var mapId;
    ({mapId} = servCommand);
    return $gameMap.mapId() === mapId;
  };
  //TODO: На новый формат ANNetwork.send(NMS.AABSZ(name, data))
  // * Теперь broadcast, т.е. можно проверку myActorId пропускать

  // * Собирает базовую команду для отправки на сервер
  _.createServCommand = function(content) {
    return {
      mapId: $gameMap.mapId(),
      actorId: ANGameManager.myActorId(),
      content
    };
  };
  _.packMapChar = function(character) {
    var e;
    if (character == null) {
      return null;
    }
    try {
      if (character === $gamePlayer) {
        return {
          type: 0,
          id: ANNetwork.myId()
        };
      } else if (character instanceof Game_Event) {
        return {
          type: 1,
          id: character.eventId(),
          mapId: $gameMap.mapId()
        };
      } else if (character instanceof NETCharacter) {
        return {
          type: 0,
          id: character.id
        };
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return null; // * Unknown
  };
  _.unpackMapChar = function(packed) {
    var e;
    try {
      if (packed == null) {
        return null;
      }
      if (packed.type == null) {
        return null;
      }
      switch (packed.type) {
        case 0:
          if (packed.id === ANNetwork.myId()) {
            return $gamePlayer;
          } else {
            return $gameMap.networkCharacterById(packed.id);
          }
          break;
        case 1:
          if ($gameMap.mapId() === packed.mapId) {
            return $gameMap.event(packed.id);
          }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return null;
  };
  //TODO: вообще не вызывается?
  _.refreshABSMembers = function() {
    var char, e, i, len, ref, ref1, results;
    try {
      ref = $gameMap.netChars();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        char = ref[i];
        results.push((ref1 = char.AASprite()) != null ? ref1.initABS() : void 0);
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  return _.loadExtensions = function() {
    var __alias_ANGM_jdc, __alias_ANGM_orgm, __alias_ANPM_bar, _alias_GCB_fillNetworkObserver, _alias_SA_r, _alias_SA_tsp;
    if (Imported.Alpha_NETZ !== true) {
      return;
    }
    this.SetupNETCharacter(); // AA_Network/3_NETCharacter_AA.coffee
    
    //@[ALIAS]
    // * Запускать АБС по готовности персонажа
    __alias_ANPM_bar = ANPlayersManager.bindActorResult;
    ANPlayersManager.bindActorResult = function(result) {
      __alias_ANPM_bar.call(this, ...arguments);
      if (!result) {
        return;
      }
      // * На всякий случай с задержкой
      AA.Utils.callDelayed(AA.System.checkABSPlayerExists.bind(AA.System), 10);
    };
    //@[ALIAS]
    __alias_ANGM_jdc = ANGameManager.applyJoinedDataCorrects;
    ANGameManager.applyJoinedDataCorrects = function(result) {
      __alias_ANGM_jdc.call(this, ...arguments);
      // * Без этой паузы будет StackOverflow
      uAPI.pauseABS(true);
    };
    //@[ALIAS]
    __alias_ANGM_orgm = ANGameManager.onRefreshGameParty;
    ANGameManager.onRefreshGameParty = function() {
      __alias_ANGM_orgm.call(this, ...arguments);
      // * В PVP режиме, других игроков не будет в партии (пока так)
      if (AA.Network.isNetworkPvPGame()) {
        AA.Utils.callDelayed(ANGameManager.aaRefreshGamePartyOnPvPMode.bind(ANGameManager), 10);
      }
      AA.Network.refreshABSMembers();
    };
    //?[NEW]
    ANGameManager.aaRefreshGamePartyOnPvPMode = function() {
      var e;
      try {
        $gameParty.nClearBeforeRefresh();
        $gameParty._actors.push(ANGameManager.myActorId());
        $gamePlayer.refresh();
        $gameMap.nSafeRefresh();
        return KDCore.GEventsManager.call("netzRefreshNameplate");
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Старый способ (через nAPI)
    /*_alias_nAPI_onCustomCommandABSZ = nAPI.onCustomCommand
    nAPI.onCustomCommand = (name) ->
        _alias_nAPI_onCustomCommandABSZ.call(@, ...arguments)
        if name.contains(AA.Network.NETCmdPrefix)
            AANetworkManager.onServerCommand(...arguments)
        return*/
    //$[OVER]
    NetClientMethodsManager.event_aabz = function(name, data) {
      AANetworkManager.onServerCommand(...arguments);
    };
    _alias_GCB_fillNetworkObserver = Game_CharacterBase.prototype._fillNetworkObserver;
    Game_CharacterBase.prototype._fillNetworkObserver = function() {
      _alias_GCB_fillNetworkObserver.call(this);
      this.aaFillNetworkDataObserver();
    };
    // * На всякий случай, с анимацией были проблемы
    _alias_SA_r = Sprite_Animation.prototype._render;
    Sprite_Animation.prototype._render = function() {
      var e;
      try {
        _alias_SA_r.call(this, ...arguments);
      } catch (error) {
        e = error;
        AA.w(e);
        this._render = function() {}; // * EMPTY
      }
    };
    // * Почему-то случается Game Crush при проигрывании анимаций по сети
    // * Теряется родитель, присваиваю на авось (вроде работает)
    _alias_SA_tsp = Sprite_Animation.prototype.targetSpritePosition;
    Sprite_Animation.prototype.targetSpritePosition = function(sprite) {
      var e;
      try {
        if (sprite instanceof Sprite_Character && (sprite.parent == null) && KDCore.Utils.isSceneMap()) {
          sprite.parent = SceneManager._scene._spriteset._tilemap;
        }
        return _alias_SA_tsp.call(this, sprite);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return {
          x: 0,
          y: 0
        };
      }
    };
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менедреж выполнения скриптовых действий
AA.SAaction = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.SAaction;
  _.ACTIONS = ["ss", "sw", "vr", "ce", "ap", "ev", "an", "ef", "se", "ba", "es", "ax", "as"];
  _.isProper = function(actionLine) {
    var cmd, e, parts;
    if (actionLine == null) {
      return false;
    }
    if (isFinite(actionLine)) {
      return false;
    }
    try {
      parts = actionLine.split("_");
      cmd = parts[0];
    } catch (error) {
      e = error;
      AA.w(e);
      cmd = null;
    }
    return _.ACTIONS.contains(cmd);
  };
  //%[MAIN] OUTER (Основной метод вызова)
  // * Выполнить AA Script Action
  _.execute = function(action, char) {
    var cmd, e;
    if (!_.isProper(action)) {
      return;
    }
    if (char instanceof Game_Interpreter) {
      char = this.extractProperChar(char);
    }
    AANetworkManager.executeSA(action, char);
    try {
      cmd = action.split("_")[0];
      switch (cmd) {
        case "ss":
          return _.executeSelfSwitchAction(action, char);
        case "sw":
          return _.executeSwitchAction(action);
        case "vr":
          return _.executeVariableAction(action);
        case "ce":
          return _.executeCommonEventAction(action, char);
        case "ap":
          return _.executeAIModelAction(action, char);
        case "ev":
          return _.executeMapEventAction(action);
        case "an":
          return _.executeAnimationAction(action, char);
        case "ef":
          return _.executeEffectAction(action, char);
        case "se":
          return _.executeSESoundAction(action);
        case "ba":
          return _.executeBallonIcon(action, char);
        case "es":
          return _.executeSkill(action, char);
        case "ax":
          return _.executeAnimaXAction(action, char);
        case "as":
          return _.executeAddState(action, char);
        default:
          return AA.w("Unknown script action: " + action);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Если было вызвано из события, то преобразуем в Event
  _.extractProperChar = function(char) {
    if (char.eventId() > 0) {
      return $gameMap.event(char.eventId());
    } else {
      return null;
    }
  };
  // * ss_A_true_2 , ss_B_false, ss_C_false_3 (evId)
  _.executeSelfSwitchAction = function(action, char) {
    var args, evId, key, switchId, switchState;
    args = action.split("_");
    if (args.length < 3) {
      return;
    }
    switchId = args[1];
    if (!AA.Utils.checkSwitch(switchId)) {
      return;
    }
    switchState = Boolean(args[2].toLowerCase());
    if (args[3] != null) {
      evId = parseInt(args[3]);
    } else {
      if (char == null) {
        return;
      }
      if (char.eventId == null) {
        return;
      }
      evId = char.eventId();
    }
    key = [$gameMap.mapId(), evId, switchId];
    $gameSelfSwitches.setValue(key, switchState);
  };
  // * ss_A_true_2 , ss_B_false, ss_C_false_3 (evId)
  // * Данный метод вызывается от севрера, поддерживает смену переключателя на другой карте
  _.executeSelfSwitchActionFromNetwork = function(action, forceEventId, mapId) {
    var args, evId, key, switchId, switchState;
    // * Если карта текущая, то как обычное SS действие (распаковка персонажа)
    if (mapId === $gameMap.mapId()) {
      this.executeSelfSwitchAction(action, AA.Network.unpackMapChar(forceEventId));
    } else {
      args = action.split("_");
      if (args.length < 3) {
        return;
      }
      switchId = args[1];
      if (!AA.Utils.checkSwitch(switchId)) {
        return;
      }
      switchState = Boolean(args[2].toLowerCase());
      if (args[3] != null) {
        evId = parseInt(args[3]);
      } else {
        if (forceEventId == null) {
          return;
        }
        if (forceEventId <= 0) {
          return;
        }
        evId = forceEventId;
      }
      key = [mapId, evId, switchId];
      $gameSelfSwitches.setValue(key, switchState);
    }
  };
  // * sw_43_true, sw_222_false
  _.executeSwitchAction = function(action) {
    var args, switchId, switchState;
    args = action.split("_");
    if (args.length < 3) {
      return;
    }
    switchId = parseInt(args[1]);
    if (switchId <= 0) {
      return;
    }
    switchState = Boolean(args[2].toLowerCase());
    $gameSwitches.setValue(switchId, switchState);
  };
  // * vr_54_2123, vr_44_9932
  _.executeVariableAction = function(action) {
    var args, value, varId;
    args = action.split("_");
    if (args.length < 3) {
      return;
    }
    varId = parseInt(args[1]);
    if (varId <= 0) {
      return;
    }
    value = args[2];
    if (isFinite(value)) {
      value = parseInt(value);
    }
    $gameVariables.setValue(varId, value);
  };
  // * ce_43, ce_11_this (?)
  _.executeCommonEventAction = function(action, char) {
    var args, ceId;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    ceId = parseInt(args[1]);
    if (ceId <= 0) {
      return;
    }
    if ((args[2] != null) && args[2] === "this" && char instanceof Game_Event) {
      if (char != null) {
        char.aaStartCommonEvent(ceId);
      }
    } else {
      AA.Utils.startCE(ceId);
    }
  };
  // * ev_5 ; start event 5 on this map
  _.executeMapEventAction = function(action) {
    var args, event;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    event = this._getEventByArgId(args[1]);
    if (event != null) {
      event.start();
    }
  };
  _._getEventByArgId = function(argX) {
    var eventId;
    eventId = parseInt(argX);
    if (eventId <= 0) {
      return null;
    }
    return $gameMap.event(eventId);
  };
  // * ap_viewRadius_5, ap_viewRadius_4_12 (evId)
  _.executeAIModelAction = function(action, char) {
    var args, event, paramName, paramValue;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    paramName = args[1];
    if (!String.any(paramName)) {
      return;
    }
    paramValue = args[2];
    if (isFinite(paramValue)) {
      // * Преобразование числа
      paramValue = Number(paramValue);
    }
    //TODO: Как быть с массивами данных??? approachMoveData
    if (args[3] != null) {
      event = this._getEventByArgId(args[4]);
      if (event == null) {
        return;
      }
      char = event;
    }
    // * char
    if (char == null) {
      return;
    }
    if (!char.isABS()) {
      return;
    }
    char.aaChangeModelParam(paramName, paramValue);
  };
  // * an_4 (self), an_5_3 (evId), an_2_1_2 (x,y)
  _.executeAnimationAction = function(action, char) {
    var animationId, args, event, mapX, mapY;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    animationId = parseInt(args[1]);
    if (animationId <= 0) {
      return;
    }
    // * x, y
    if (args[3] != null) {
      mapX = parseInt(args[2]);
      mapY = parseInt(args[3]);
      AABattleActionsManager.playAnimationOnMap(mapX, mapY, animationId);
    } else if (args[2] != null) {
      event = this._getEventByArgId(args[2]);
      if (event == null) {
        return;
      }
      AABattleActionsManager.playAnimationOnCharacter(event, animationId); // * on self
    } else {
      if (char == null) {
        return;
      }
      AABattleActionsManager.playAnimationOnCharacter(char, animationId);
    }
  };
  // * ef_shake_10, ef_shake_10_12 (evId)
  // * ef_shatter_4_4 (dx, dy), ef_shatter_4_4_2 (evId)
  _.executeEffectAction = function(action, char) {
    var args, effectName;
    args = action.split("_");
    if (args.length < 3) {
      return;
    }
    effectName = args[1];
    switch (effectName) {
      case "shatter":
        _._executeEffect_Shatter(args, char);
        break;
      case "shake":
        _._executeEffect_Shake(args, char);
        break;
      default:
        AA.w("SAction: effect " + effectName + " not registred in ABS");
    }
  };
  _._executeEffect_Shatter = function(args, char) {
    var dx, dy, event;
    dx = parseInt(args[2]);
    dy = parseInt(args[3]);
    if (args[4] != null) {
      event = this._getEventByArgId(args[4]);
      if (event != null) {
        event.aaRequestShatterEffect(dx, dy); // * char
      }
    } else {
      if (char != null) {
        char.aaRequestShatterEffect(dx, dy);
      }
    }
  };
  _._executeEffect_Shake = function(args, char) {
    var event, time;
    time = parseInt(args[2]);
    if (args[3] != null) {
      event = this._getEventByArgId(args[3]);
      if (event != null) {
        event.aaRequestShakeEffect(time); // * char
      }
    } else {
      if (char != null) {
        char.aaRequestShakeEffect(time);
      }
    }
  };
  // * se_Bell1_90_100 (volume, pitch)
  _.executeSESoundAction = function(action) {
    var args, name, pitch, volume;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    name = args[1];
    if (!String.any(name)) {
      return;
    }
    // * volume and pitch - не обязательные
    if (args[2] != null) {
      volume = parseInt(args[2]);
      if (args[3]) {
        pitch = parseInt(args[3]);
      }
    }
    KDCore.Utils.playSE(name, volume, pitch);
  };
  // * ba_1, ba_2_4 (evId)
  _.executeBallonIcon = function(action, char) {
    var args, balloonId;
    args = action.split("_");
    if (args.length < 2) {
      return;
    }
    balloonId = parseInt(args[1]);
    if (args[2] != null) {
      char = this._getEventByArgId(args[2]);
    }
    if (char != null) {
      $gameTemp.requestBalloon(char, balloonId);
    }
  };
  // * es_0_-1_303, es_0_0_304_0 (gamePlayer), es_0_0_304_10_20 (XY)
  _.executeSkill = function(action, char) {
    var args, charId, ownerId, skillId, teamId, x, y;
    args = action.split("_");
    if (args.length < 4) {
      return;
    }
    ownerId = parseInt(args[1]);
    teamId = parseInt(args[2]);
    skillId = parseInt(args[3]);
    x = y = null;
    if ((args[4] != null) && (args[5] != null)) {
      x = parseInt(args[4]);
      y = parseInt(args[5]);
      if ((x != null) && (y != null)) {
        uAPI.executeAASkillOnMap(ownerId, teamId, skillId, x, y);
      }
    } else if (args[4] != null) {
      charId = parseInt(args[4]);
      uAPI.executeAASkillOnChar(ownerId, teamId, skillId, charId);
    } else {
      if (char != null) {
        ({x, y} = char);
      }
      if ((x != null) && (y != null)) {
        uAPI.executeAASkillOnMap(ownerId, teamId, skillId, x, y);
      }
    }
  };
  // * ax_name, ax_name_0 (0 - player, X - event ID)
  _.executeAnimaXAction = function(action, char) {
    var animationActionName, args, e;
    try {
      if (!Imported.PKD_AnimaX) {
        return;
      }
      args = action.split("_");
      if (args.length < 2) {
        return;
      }
      animationActionName = args[1];
      if (args[2] != null) {
        char = this._getEventByArgId(args[2]);
      }
      if (char == null) {
        return;
      }
      if (char.isAnimX()) {
        return char.startAnimaXCustomAction(animationActionName, false, true);
      } else {
        return console.warn(action + " Character not have AnimaX controller on it, add XA: comment");
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * as_STATE, as_STATE_0 (0 - player, X - event ID)
  // * works only for AAEntities
  _.executeAddState = function(action, char) {
    var args, e, stateId;
    try {
      args = action.split("_");
      if (args.length < 2) {
        return;
      }
      stateId = parseInt(args[1]);
      if ($dataStates[stateId] == null) {
        return;
      }
      if (args[2] != null) {
        char = this._getEventByArgId(args[2]);
      }
      if (char == null) {
        return;
      }
      if (char.isABS() && (char.AABattler != null)) {
        return char.AABattler().addState(stateId);
      } else {
        return console.warn(action + " Character is not ABS support one");
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();


// Generated by CoffeeScript 2.6.1
// * Класс АБС навыка (дейсвтия), может быть спелл или предмет
// * Содержки настройки навыка
// * Новая версия - не требует целей

// * Не требует цели совсем
// * Базируется на 4х основных парметрах:
// Расстояние (0 или X)
// Область поражения (1 или Radius (square))
// Направление (direction or point(cursor))
// Скорость (0 или Х) - если больше 0, то летит, если 0 то мнгновенно

// * Пока новый навык не умеет следовать за целью (возможно введу потом)

//TODO: АБС навыки могут быть и в обычной битве тоже, т.е. используется два вида настроек
//TODO: Навыки с ABS всегда есть на карте и в бою, а вот без ABS - нет на карте

//%[I] Превратить некоторые параметры в Extended Values (например Radius или targetLimitType)

//@[STORABLE]
var AASkill2;

AASkill2 = class AASkill2 {
  constructor(idA) {
    this.idA = idA;
    this._initBase();
    this._initMain();
    this._initOnMapSettings();
    this._initOtherSettings();
    this._initAnimationSettings();
    return;
  }

  name() {
    var ref;
    return (ref = this.dbItem()) != null ? ref.name : void 0;
  }

  isItem() {
    return AA.Utils.isAAItem(this.idA);
  }

  isSkill() {
    return !this.isItem();
  }

  databaseId() {
    if (this.isItem()) {
      return this.idA - AA.Utils.ItemsIDStart;
    } else {
      return this.idA;
    }
  }

  // * Установить набор параметров из Note (принимает массив пар: имя - значение)
  setNoteParameters(params) {
    var i, len, p;
    for (i = 0, len = params.length; i < len; i++) {
      p = params[i];
      this[p[0]] = p[1];
    }
    this._convertParameters();
  }

  animationId() {
    var hitAnimationId;
    hitAnimationId = this.gHitAnimationId();
    if (hitAnimationId > 0) {
      return hitAnimationId;
    } else {
      return this.dbItem().animationId;
    }
  }

  gHitAnimationId() {
    return AA.Utils.getSafeEValue(this.hitAnimationId, 0);
  }

  dbItem() {
    return AA.Utils.getAASkillObject(this.idA);
  }

  // * Надо выбирать зону поражения для навыка
  isNeedSelectZone() {
    return this.selectZone === 1 && this.gRange() > 0;
  }

  // * Нет "полёта", приминение сразу в точке (зоне поражения)
  isInstant() {
    return this.gSpeed() <= 0;
  }

  isProjectile() {
    return !this.isInstant();
  }

  gMultiProjectileMode() {
    return AA.Utils.getSafeEValue(this.multiProjectile, 0);
  }

  getMultiProjectileModeCustomSet() {
    return this.customProjDirs || [];
  }

  isMultiProjectile() {
    return this.isProjectile() && this.isInPoint() && this.gMultiProjectileMode() > 0;
  }

  isMultiProjectileFixed() {
    return this.isMultiProjectile() && this.fixProjWithCharDir > 0;
  }

  isHomingProjectile() {
    return this.isProjectile() && this.homingProjectile > 0;
  }

  isNoRotationImage() {
    return this.isProjectile() && this.noRotationImage > 0;
  }

  gSpeed() {
    return AA.Utils.getSafeEValue(this.speed, 0);
  }

  // * Имеет направление (точка)
  isInPoint() {
    return this.direction > 0;
  }

  // * Имеет конечную точку (летит прямо в точку)
  isInCertainPoint() {
    return this.direction === 1;
  }

  // * Летит по направлению точки
  isInPointDirection() {
    return this.direction === 2;
  }

  isNoContact() {
    return this.noContact > 0;
  }

  // * Поражает только одну цель
  isSingleTargetArea() {
    return this.gRadius() <= 1;
  }

  gRadius() {
    return AA.Utils.getSafeEValue(this.radius, 1);
  }

  isSelfAction() {
    return this.gRange() <= 0 && this.isInstant();
  }

  gRange() {
    return AA.Utils.getSafeEValue(this.range, 1);
  }

  isHaveTimer() {
    var reloadTime;
    reloadTime = this.gReloadTime();
    return String.any(reloadTime) || reloadTime > 0;
  }

  // * Ближний бой = дистанция 1 и по направлению
  isMelee() {
    return !this.isInPoint() && this.gRange() === 1;
  }

  isForEnemies() {
    return this.opponentsEffect === 1;
  }

  isForEnemiesOnly() {
    return this.isForEnemies() && !this.isForFriends();
  }

  isForFriends() {
    return this.friendlyEffect === 1;
  }

  isForFriendsOnly() {
    return this.isForFriends() && !this.isForEnemies();
  }

  isHaveWeaponMotion() {
    return this.weaponMotion >= 1;
  }

  isHaveTargetLimit() {
    return !this.isSingleTargetArea() && this.targetLimit > 0;
  }

  isHaveWeaponMotionSpecialType() {
    return this.weaponMotionType > 0;
  }

  isRepeatable() {
    return this.gRepeat() > 1;
  }

  gRepeat() {
    return AA.Utils.getSafeEValue(this.repeat, 1);
  }

  isRepeatableOnUse() {
    return this.gRepeatOnUse() > 1;
  }

  gRepeatOnUse() {
    return AA.Utils.getSafeEValue(this.repeatOnUse, 1);
  }

  gRepeatDelay() {
    return AA.Utils.getSafeEValue(this.repeatDelay, 120);
  }

  isRequireStateOnUser() {
    return this.gUsableIfState() > 0;
  }

  gUsableIfState() {
    return AA.Utils.getSafeEValue(this.usableIfState, 0);
  }

  isRequireStateOnTarget() {
    return this.gUsableIfTargetState() > 0;
  }

  gUsableIfTargetState() {
    return AA.Utils.getSafeEValue(this.usableIfTargetState, 0);
  }

  isHaveExtraAnimation() {
    return this.extraAnimation != null;
  }

  isHaveImpulsePower() {
    return this.getImpulsePower() > 0;
  }

  isRandomImpulseDirection() {
    return this.impulseRandom > 0;
  }

  isJumpImpulseType() {
    return this.impulseJump > 0;
  }

  isReversedImpulseType() {
    return this.impulseReversed > 0;
  }

  isAroundUser() {
    return this.isInstant() && !this.isSingleTargetArea() && this.direction === 0;
  }

  getImpulsePower() {
    return AA.Utils.getSafeEValue(this.impulse, 0);
  }

  getPiercePower() {
    return AA.Utils.getSafeEValue(this.pierce, 0);
  }

  isExplosive() {
    return this.getExplosiveRadius() > 0;
  }

  isExplosiveHaveSkill() {
    return this.getExplosiveDmgSkillId() > 0;
  }

  getExplosiveRadius() {
    return AA.Utils.getSafeEValue(this.explosive, 0);
  }

  getExplosiveDmgKoef() {
    return AA.Utils.getSafeEValue(this.explosiveDmgKoef, 0);
  }

  getExplosiveDmgSkillId() {
    return AA.Utils.getSafeEValue(this.explosiveDmgSkill, 0);
  }

  isSwing() {
    return this.swing > 0 && this.getSwingKoef() > 0 && this.isSingleTargetArea();
  }

  getSwingKoef() {
    return AA.Utils.getSafeEValue(this.swingKoef, 1);
  }

  isTeleport() {
    return this.teleport > 0;
  }

  isValidExplosiveSkill() {
    var id;
    id = this.getExplosiveDmgSkillId();
    //TODO: Может наоборот только обычные навыки чтобы урон получать?
    return id > 0 && ($dataSkills[id] != null) && ($dataSkills[id].AASkill != null);
  }

  getAnimaXActionName() {
    if (String.any(this.animaXAction)) {
      return this.animaXAction;
    } else {
      return "Skill"; // * По умолчанию
    }
  }

  
    // * Время перезарядки навыка (cooldown)
  getReloadTime(battlerOrChar) {
    var reloadTime;
    reloadTime = this.gReloadTime();
    if (isFinite(reloadTime)) {
      return reloadTime;
    } else {
      if (battlerOrChar == null) {
        return 0;
      } else {
        if (battlerOrChar instanceof Game_Character) {
          battlerOrChar = battlerOrChar.AABattler();
        }
        return battlerOrChar.aaCalculateFormula(reloadTime);
      }
    }
  }

  gReloadTime() {
    return AA.Utils.getSafeEValue(this.reloadTime, 0);
  }

  // * Приминить стандартные настройки навыка 001 Атака
  applyDefaultAttack001() {
    // * Ближний бой перед собой (контактный только)
    this.radius = 1;
    this.range = 1;
    this.direction = 0;
    this.speed = 0;
    this.noContact = 0;
    this.skillImg = "";
    this.actionStartDelay = 10;
    this.reloadTime = 1.2;
    this.animaXAction = "Attack";
    this.animaXPriority = 1;
    this.weaponMotion = 1;
  }

  // * Extended Values =========================================
  getETargetLimitType() {
    return this.targetLimitType;
  }

  gTargetLimit() {
    return AA.Utils.getSafeEValue(this.targetLimit, 0);
  }

  // * Casting ==================================================
  gCastingTime() {
    return AA.Utils.getSafeEValue(this.castingTime, 0);
  }

  isHaveCastingAnimation() {
    return String.any(this.castingAnimation);
  }

  isNeedCasting() {
    return this.gCastingTime() > 0;
  }

};

(function() {  //TODO: splash damage (от каждой цели считается ещё доп. цели)

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AASkill2.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AASkill2.prototype;
  //custom action common ev,  switch, var (на любые события с Note)
  // события, которые могут пропускать через себя Proj, но выполнять действия

  //TODO: shake effect strheng for target

  //TODO: animationFor: eachTarget, centerPoint

  // * Базовые (фундаментальные) АБС параметры навыка
  _._initBase = function() {
    // * Область поражения (1 - Х)
    this.radius = 1; //@[EVal]
    this.range = 1; //@[EVal]
    //facing dir 0, point position 1, point direction 2
    this.direction = 0;
    this.speed = 0; //@[EVal]
  };
  // * Основные АБС параметры навыка
  _._initMain = function() {
    //@[EVal]
    this.targetLimit = 0; // * Нет ограничения по количеству целей
    this.targetLimitType = 0; // * 0 - Любая цель, 1 - Ближайшая, 2 - Дальняя
    this.friendlyEffect = 0; // * Еффект на дружественную команду (и себя)
    this.opponentsEffect = 1; // * Еффект на противоположную команду
    // * В СЕКУНДАХ
    //@[EVal]
    this.reloadTime = 0; // * Данный параметр может быть строкой
    //@[EVal]
    this.repeat = 1; // * Количество повторений 0 = 1 (0 - игнорируется, т.е. = 1)
    //@[EVal]
    this.repeatOnUse = 1; // * Количество повторений старта 0 = 1 (0 - игнорируется, т.е = 1)
    //@[EVal]
    this.repeatDelay = 120; // * Задержка между повторами (в миллисекундах)
    // * Проверка состояний условий
    //@[EVal]
    this.usableIfState = 0;
    //@[EVal]
    this.usableIfTargetState = 0;
    this.impulse = 0; //@[EVal]
    this.impulseRandom = 0;
    this.impulseJump = 0;
    this.impulseReversed = 0;
    // * Только для Projectile
    this.pierce = 0; //@[EVal]
    this.keepOutScreen = 0;
    this.colliderRadius = 8;
    // * Урон будет по одной и тойже цели наносится пока навык находится в её  области
    this.pierceContinues = 0;
    this.explosive = 0; //@[Eval]
    this.explosiveDmgKoef = 1; //@[Eval]
    this.explosiveDmgSkill = 0; //@[Eval]
    this.multiProjectile = 0; //@[Eval]
    this.fixProjWithCharDir = 1;
    this.homingProjectile = 0;
    this.customProjDirs = [];
    // * Изображение Projectile не будет поворачивать по направлению полёта
    this.noRotationImage = 0;
    // * Урон по соседним (взмах)
    this.swing = 0;
    this.swingKoef = 1; //@[Eval]
    this.teleport = 0;
    this.teleportInAnim = 0;
    this.teleportOutAnim = 0;
    // * Casting
    this.castingAnimation = ""; // * XAnima Looped Action Name
    this.castingTime = 0; //@[Eval] (in seconds)
    // * Add extra casting time when hit (in seconds)
    this.castingDelayWhenHit = 0;
    // * Abort Casting when hit
    this.castingStopWhenHit = 0;
    this.onCastingStartCE = 0;
    this.onCastingCompletedCE = 0;
    this.onCastingAbortedCE = 0;
    this.castingRotation = 1;
    this.castingSE = "";
  };
  // * Настройки поведения на карте
  _._initOnMapSettings = function() {
    this.z = 3;
    this.selectZone = 0;
    this.skillImg = "";
    this.hitOffset = 28; //$gameMap.tileWidth() * 0.6
    // * Если 1, то навык срабатывает в конце своего пути в любом случае
    // * Если 0, то навык, НЕ достигнув цели, просто изчезнет
    this.noContact = 0;
    //TODO: to WIKI (+ image and example)
    this.popUpStyleId = ""; // * Default
    // * Дополнительная анимация (используется на АБС карте, используется взамен параметра из БД)
    this.hitAnimationId = 0; //@[EVal]
    // * Если 1 , то в любом случае анимация будет на карте
    this.animationOnMap = 0;
    // * Непроходимые регионы
    this.noPassRegions = [];
    // * Непроходимые Terrain tags
    this.noPassTerrains = [];
    // * Селектор карты
    this._initSelector();
    // * Анимация взмаха оружием (стандартная)
    this.weaponMotion = 0; // * 0 - нету, 1 - есть
    // * Только если weaponMotion > 0
    this.weaponMotionType = 0; //* 0 - оружие в руке (Actor), 1-X тип оружия из списка Types
    //TODO: Для файла оружия отдельный параметр, в самом оружии и для Enemies тоже
    // * Приоритет анимации ( 1 - в приоритете, 0 - нет. 2 - вместе)
    this.animaXPriority = 1;
    // * Дополнительная анимация (картинки)
    this.extraAnimation = null;
    this.extraAnimationOX = 0;
    this.extraAnimationOY = 0;
    this.extraAnimationSE = "";
  };
  // * Параметры селектора на карте
  _._initSelector = function() {
    this.selectorColor = "#bf9324"; //"#FF22AA"
    this.selectorImg = null;
    return this.selectorOpacity = 220; //200
  };
  
  // * Дополнительные настройки навыка
  _._initOtherSettings = function() {
    this.hideOutsideABS = 0;
    // * Когда навык поражает цель (попадает в цель) (см. AABattleActionsManager._onActionResult)
    this.onHit = null; //SA
    // * Когда запускаем (используем) навык (см. AABattleActionsManager.startAASkill)
    this.onStart = null; //SA
    // * Изображение для слота навыка
    this.ssImg = null;
    // * Когда навык был выполнен
    this.onDone = null; //SA
  };
  // * Настройки анимации xAnima
  _._initAnimationSettings = function() {
    this.animaXAction = null;
    return this.actionStartDelay = 0;
  };
  
  // * Преобразует некоторые параметры
  _._convertParameters = function() {
    // * Из строки 1,2,3 в массив [1,2,3]
    this.noPassRegions = AA.Utils.Parser.convertArrayFromParameter(this.noPassRegions);
    this.noPassTerrains = AA.Utils.Parser.convertArrayFromParameter(this.noPassTerrains);
    this.customProjDirs = AA.Utils.Parser.convertArrayFromParameter(this.customProjDirs);
  };
})();

// ■ END AASkill2.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс оболочка навыка на карте (т.е. когда навык уже "запущен")
// * Содержит методы обработки урона, целей и прочие механики работы АБС навыка

//@[STORABLE]
var AASkill2MapAction;

AASkill2MapAction = class AASkill2MapAction {
  constructor(aaSkill, subject, point) {
    this.aaSkill = aaSkill;
    // * Эти значения меняются из Sprite_AAMapSkill2Projectile
    this.x = 0;
    this.y = 0;
    this.totalFlyTime = this._calculateFlyTime();
    this.setSubject(subject);
    this.setTargetPoint(point);
    // * Сгенерировать уникальный ID 
    this.setUniqueId();
    return;
  }

  isHoming() {
    return this.aaSkill.isHomingProjectile();
  }

  isKeepOutScreen() {
    return this.aaSkill.keepOutScreen > 0;
  }

  isStaticAngle() {
    return this.aaSkill.isNoRotationImage();
  }

  isHaveHomingTarget() {
    return this._packedHomingTarget != null;
  }

  getHomingTarget() {
    return AA.Utils.unpackAAEntity(this._packedHomingTarget);
  }

  // * Используется в Continues Hit, когда сбрасывается цель
  resetHoming() {
    this._packedHomingTarget = null;
  }

  // * Projectile достиг цели (заканчивает полёт) - отпускаем его в свободный полёт
  offHoming() {
    this.resetHoming();
    this.isHoming = function() {
      return false;
    };
  }

  setHomingTarget(targ) {
    var e;
    try {
      this._packedHomingTarget = AA.Utils.packAAEntity(targ);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._packedHomingTarget = null;
    }
  }

  setSubject(subject) {
    this.packedSubject = null;
    if (!subject.isABS()) {
      return;
    }
    this.packedSubject = AA.Utils.packAAEntity(subject);
    this._initStartPoint();
  }

  // * Уникальный ID для сетевой игры, чтобы можнобыло найти конкретный Projectile
  // * из запроса от сервера (завершить Projectile например)
  setUniqueId(uniqueId) {
    if (uniqueId == null) {
      return this.uniqueId = KDCore.makeid(6) + "_" + this.aaSkill.idA;
    } else {
      return this.uniqueId = uniqueId;
    }
  }

  // * Данный навык обрабатвается на мастере карты
  // * Просчёт коллизий на данном клиенте должен быть отключён
  isPhantom() {
    return AA.Network.isNetworkGame() && !ANGameManager.isMapMaster();
  }

  //TODO: Нормальный метод обработки Direction Point Mouse!!
  setTargetPoint(point) {
    if (point instanceof Game_Character) {
      if (this.isHoming()) {
        this.setHomingTarget(point);
      }
    }
    if (this.packedSubject != null) {
      point = this.preparePoint(point);
    }
    if (point instanceof Game_Character) {
      point = point.toPoint();
    }
    this.refreshPoints(point);
  }

  // point - targetPoint
  refreshPoints(point) {
    // * Точки на экране
    //if point.touchXY?
    //    @scX = point.touchXY.x
    //    @scY = point.touchXY.y
    //else
    this.scX = this._convertPointValue(point.x);
    this.scY = this._convertPointValue(point.y);
    // * Точки на карте
    this.tX = point.x;
    this.tY = point.y;
  }

  refreshHomingPoint() {
    if (!this.isHoming()) {
      return;
    }
    if (this.isHaveHomingTarget()) {
      this.refreshPoints(this.getHomingTarget().toPoint());
    } else {
      // * Call this method NOT every frame, but every 10th frame
      if (this._homingSearchRefreshRate == null) {
        this._homingSearchRefreshRate = 10;
      } else {
        this._homingSearchRefreshRate--;
        if (this._homingSearchRefreshRate <= 0) {
          this._checkForHomingTarget();
          this._homingSearchRefreshRate = null;
        }
      }
    }
  }

  _checkForHomingTarget() {
    var candidate, p;
    // * Берём точку Projectile на данный момент (от него ищем, не от Subject)
    p = {
      x: this.tX,
      y: this.tY
    };
    candidate = AATargetsManager.findCandidateForHomingProjectile(this.getSubject(), this.aaSkill, p);
    if (candidate != null) {
      this.setHomingTarget(candidate);
    }
  }

  preparePoint(point) {
    var direction, subject;
    if (this.aaSkill.isInPoint()) {
      return point;
    } else {
      // * По направлению персонажа (face direction)
      subject = this.getSubject();
      if ((subject._diagonalDir != null) && subject._diagonalDir !== false) {
        direction = subject._diagonalDir;
      } else {
        direction = subject.direction();
      }
      return AA.Utils.Math.getProjectilePointByDirection(subject.toPoint(), direction);
    }
  }

  //TODO: Если будет Friendly Fire или PVP, то поменять
  isSubjectIsPlayer() {
    return (this.packedSubject != null) && this.packedSubject.type === 0;
  }

  isSubjectIsNetChar() {
    return AA.Network.isNetworkGame() && this.isSubjectIsPlayer() && this.packedSubject.id !== ANNetwork.myId();
  }

  isSubjectIsAlly() {
    return (this.packedSubject != null) && this.packedSubject.type === 2;
  }

  isSubjectIsEvent() {
    return (this.packedSubject != null) && this.packedSubject.type === 1;
  }

  getSubjectEvId() {
    if (this.isSubjectIsEvent()) {
      return this.packedSubject.id;
    } else {
      return -1;
    }
  }

  getSubjectNetId() {
    if (this.isSubjectIsNetChar()) {
      return this.packedSubject.id;
    } else {
      return -1;
    }
  }

  getSubjectTeamId() {
    return this.getSubject().AAEntity().teamId();
  }

  getSubject() {
    return AA.Utils.unpackAAEntity(this.packedSubject);
  }

  id() {
    return this.aaSkill.idA;
  }

  zLevel() {
    return this.aaSkill.z;
  }

  image() {
    return this.aaSkill.skillImg;
  }

  hitOffset() {
    return this.aaSkill.hitOffset;
  }

  hitsCount() {
    return this.aaSkill.getPiercePower();
  }

  isHitsContinues() {
    return this.aaSkill.pierceContinues > 0;
  }

  speed() {
    if (this._speed == null) {
      this._speed = this.aaSkill.gSpeed();
    }
    return this._speed;
  }

  isHaveRegion(regionId) {
    var globalRegions;
    globalRegions = AA.PP.getProjectileRestrictedRegions();
    if (globalRegions.contains(regionId)) {
      return true;
    }
    return this.aaSkill.noPassRegions.contains(regionId);
  }

  isHaveTerrain(terrainTag) {
    var globalTerrains;
    globalTerrains = AA.PP.getProjectileRestrictedTerrains();
    if (globalTerrains.contains(terrainTag)) {
      return true;
    }
    return this.aaSkill.noPassTerrains.contains(terrainTag);
  }

  isCanHitPoint() {
    return this.aaSkill.isInCertainPoint();
  }

  isNoContact() {
    return this.aaSkill.isNoContact();
  }

  isDummySubject() {
    return this.packedSubject.type === 1000;
  }

  isSubjInSamePointWith(char) {
    var e, subj;
    try {
      subj = this.getSubject();
      return subj.x === char.x && subj.y === char.y;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  }

  isHaveCollider() {
    return this._collider != null;
  }

  getCollider() {
    if (this.isHaveCollider()) {
      return this._collider;
    } else {
      return null;
    }
  }

  refreshColliderPosition(x, y) {
    var e;
    try {
      if (!this.isHaveCollider()) {
        return;
      }
      return this._collider.setPositionXY(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  createCollider() {
    var config, e;
    try {
      config = this.getDefaultProjectileCollider();
      if (this.aaSkill.colliderRadius != null) {
        config.radius = this.aaSkill.colliderRadius;
      }
      this._collider = AACollider.FromConfig(config);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return this._collider;
  }

  getDefaultProjectileCollider() {
    return {
      type: 'c',
      dx: 0,
      dy: 0,
      radius: 8,
      flag: "projectile"
    };
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AASkill2MapAction.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AASkill2MapAction.prototype;
  _._initStartPoint = function() {
    var subject;
    subject = this.getSubject();
    this.x = this._convertPointValue(subject.x);
    this.y = this._convertPointValue(subject.y);
  };
  // * Приводим обе точки (старт и финишь) к одному формату
  _._convertPointValue = function(value) {
    var tw;
    tw = $gameMap.tileWidth();
    return Number(value * tw + tw / 2);
  };
  
  // * Дистанцию полёта определяем по времени, а не по дистанции
  _._calculateFlyTime = function() {
    var dist, range;
    range = this.aaSkill.gRange();
    if (range <= 0 || this.speed() <= 0) {
      return 10;
    } else {
      dist = range * $gameMap.tileWidth() + $gameMap.tileWidth() / 2;
      return dist / this.speed();
    }
  };
})();

// ■ END AASkill2MapAction.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс АБС состояния (содержит настройки)

//@[STORABLE]
var AAState;

AAState = class AAState {
  constructor(id) {
    this.id = id;
    // * SActions
    this.onStart = null;
    this.onTick = null; // * каждую секунду
    this.onEnd = null;
    this.activeSkill = null;
    this.speedMod = null;
    return;
  }

  //%[I] Специальный параметр hideOnUI, чтобы скрыть из иконок состояний
  state() {
    return AA.Utils.getAAStateObject(this.id);
  }

  // * Данное состояние надо "снять" по завершению Х действия (А)
  isActionEndState() {
    return this.state().autoRemovalTiming === 1;
  }

  // * Данное состояние надо "снять" после Х секунд
  isTimeEndState() {
    return this.state().autoRemovalTiming === 2;
  }

  // * Стоит флаг Remove at Battle End
  isRemovedAtBattleEnd() {
    return this.state().removeAtBattleEnd === true;
  }

  isHaveActiveSkill() {
    return this.activeSkill != null;
  }

  isHaveSpeedMod() {
    return this.speedMod != null;
  }

  // * Получить случайное значение Duration in Turns
  // * Значение между state.minTurns и state.maxTurns
  getTurnsValue() {
    var state, variance;
    state = this.state();
    if (state.maxTurns === state.minTurns) {
      return state.maxTurns;
    }
    variance = 1 + Math.max(state.maxTurns - state.minTurns, 0);
    return state.minTurns + Math.randomInt(variance);
  }

  // * Установить набор параметров из Note (принимает массив пар: имя - значение)
  setNoteParameters(params) {
    var j, len, p;
    for (j = 0, len = params.length; j < len; j++) {
      p = params[j];
      this[p[0]] = p[1];
    }
    this._convertParameters();
  }

  getActiveSkillParameters() {
    var e, params;
    if (!this.isHaveActiveSkill()) {
      return null;
    }
    try {
      // * Собираем один раз для оптимизации
      if (this._activeSkillParams == null) {
        this._activeSkillParams = {};
      }
      //%[I] Перейти на Extended Values ?
      params = this.activeSkill.toString().split(',').map(function(i) {
        return parseInt(i);
      });
      this._activeSkillParams.skillId = params[0];
      this._activeSkillParams.rate = params[1] || 1;
      this._activeSkillParams.radius = params[2];
      if (this._activeSkillParams.radius == null) {
        this._activeSkillParams.radius = 0; // * Self
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return this._activeSkillParams;
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AAState.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AAState.prototype;
  // * Преобразует некоторые параметры
  _._convertParameters = function() {};
})();

// ■ END AAState.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер с основными методами системы
AA.System = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.System;
  (function() {    // * Начальная загрузка компонентов
    // -----------------------------------------------------------------------
    //TODO: * Лог свой для сообщений версий
    _.initSystem = function() {
      //"INIT ABS SYSTEM".p()
      //AA.EV.init()
      this.initGEvents();
      this.loadParameters();
      this.loadExtensions();
    };
    _.loadParameters = function() {
      AA.PP = new AA.ParamsManager();
      AA.Input.init(AA.PP.getParam('inputSettings'));
    };
    // * Загрузка доп. методов совместимости с другими плагинами
    _.loadExtensions = function() {
      var e;
      try {
        AA.loadExtensions();
        return AA.Network.loadExtensions();
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.loadFonts = function() {
      var font, i, len, ref;
      ref = ["AABS_0", "AABS_1", "AABS_2", "AABS_3"];
      // * Загрузка стандартных шрифтов системы
      for (i = 0, len = ref.length; i < len; i++) {
        font = ref[i];
        KDCore.Utils.loadFont(font);
      }
      this.loadUserFonts();
    };
    // * Загрузка пользовательских шрифтов (из параметров плагина)
    _.loadUserFonts = function() {
      var font, i, len, ref;
      if (AA.PP == null) {
        return;
      }
      ref = AA.PP.fonts();
      for (i = 0, len = ref.length; i < len; i++) {
        font = ref[i];
        if (String.any(font)) {
          KDCore.Utils.loadFont(font);
        }
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Управление АБС системой
    // -----------------------------------------------------------------------
    // * Этот метод выполняется всегда когда загружается карта
    // * Не зависимо, ABS в паузе или нет
    _.startABS = function() {
      var _prevPause;
      if ($gameSystem._isABS == null) {
        //"START ABS SESSION ON MAP".p()
        // * По умлочанию, система всегда активированна
        $gameSystem._isABS = true;
      }
      _prevPause = !$gameSystem._isABS;
      $gameMap.initABS();
      this.checkABSPlayerExists();
      if (_prevPause === true) {
        setTimeout((function() {
          return uAPI.pauseABS();
        }), 1);
      }
    };
    _.resumeABS = function() {
      // * Нельзя возобновить, если игрока нету
      if (!$gamePlayer.isABS()) {
        return;
      }
      $gameSystem._isABS = true;
    };
    _.pauseABS = function() {
      if (!this.isABSActive()) {
        return;
      }
      //"PAUSE ABS SESSION ON MAP".p()
      $gameSystem._isABS = false;
      AA.GlobalHandler.PauseABS();
    };
    _.isABSActive = function() {
      return $gameSystem._isABS === true && !$gameTemp._noABSPlayer;
    };
    _.isExCollisionActive = function() {
      return AA.PP.isUseExtCollisionsSystem() === true;
    };
    // * Сейчас игра находится в режиме UI редактора
    // * Данный метод используется чтобы некоторые UI элементы отображали себя в редакторе иначе
    // * например невидимые становились видимыми
    _.isUIEditor = function() {
      if (AA.isPro()) {
        return SceneManager._scene instanceof AA.Scene_UIEditor;
      } else {
        return false;
      }
    };
    _.update = function() {};
    _.checkABSPlayerExists = function() {
      // * Если нет персонажа, АБС не запускаем
      if ($gameParty.leader() == null) {
        this.onNoABSPlayer();
      } else {
        this.onNewABSPlayer();
      }
    };
    // * Когда в партии стало пусто (убрали всех, нет gameParty.leader())
    _.onNoABSPlayer = function() {
      $gameTemp._noABSPlayer = true;
      this.pauseABS();
      AA.EV.call("ABSPartyLeaderNone");
    };
    // * Когда появился хоть один член партии (gameParty.leader())
    _.onNewABSPlayer = function() {
      $gameTemp._noABSPlayer = false;
      if ($gameSystem._isABS === true) {
        this.resumeABS();
      }
      AA.EV.call("ABSPartyLeaderReady");
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Управление переходами и состояниями
    // -----------------------------------------------------------------------
    // * Главное меню (или Scene_Boot)
    _.onGameDataLoaded = function() {
      // * Применяем динамические параметры
      AA.PP.applyParameters();
      // * Парсим (читаем) АБС параметры в БД
      AA.Utils.Parser.processABSSkillsNotetags();
      AA.Utils.Parser.processABSEnemiesNotetags();
      AA.Utils.Parser.processABSStatesNotetags();
      AA.Utils.Parser.processABSActorsNotetags();
      AA.Utils.Parser.processABSWeaponsNotetags();
    };
    // * Сцена карты загрузилась (или попали на сцену из меню, или Transfer)
    _.onMapSceneLoaded = function() {
      AA.UI.init();
      $gameSystem.aaOnMapLoaded();
      this.startABS();
      AA.UI.refresh();
    };
    // * Сцена карты завершается (переключение сцены)
    _.onMapSceneStopped = function() {
      AA.UI.terminate();
      $gameSystem.aaBeforeMapStopped();
      $gamePlayer.aaOnMapSceneEnd();
      $gameTemp.aaClearAllAILogicThreads();
      this.clearSceneMapGEvents();
    };
    _.onTitleScreen = function() {};
    // * Новая карта (Data)
    _.onNewMapLoaded = function() {
      // * Сброс всех предыдущих потоков АИ
      $gameTemp.aaClearAllAILogicThreads();
      // * Ссылка на последнее событие, которое было динамически создано
      $gameTemp.aaLastSpawnedEvent = null;
      // * Очищаем флаг, что есть хоть одна точка спавна
      $gameTemp.aaSpawnPointExistsOnMap = null;
      // * Очищам флаг, что есть хоть одно событие локатор
      $gameTemp.aaLocatorEventExistsOnMap = null;
      $gameSystem.aaBeforeMapLoaded();
    };
    // * Перед сохранением
    _.onBeforeGameSave = function() {
      var e;
      try {
        return $gameScreen.aaOnBeforeSave();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * После загрузки
    _.onGameLoaded = function() {
      var e;
      try {
        $gameScreen.onAfterLoad();
        $gameMap.refreshABSMembers();
        return $gamePlayer.aaAfterLoad();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Глобальные события KDCore 2.9+
    // -----------------------------------------------------------------------
    // * Очищаем события которые существют только на сцене карты
    _.clearSceneMapGEvents = function() {
      AA.EV.clear('PlayerSkillSelector');
      AA.EV.clear('MapSkillsRequestsClean');
      AA.EV.clear('UnderMouseEventChanged');
      AA.EV.clear('ABSPartyLeaderReady');
      AA.EV.clear('ABSPartyLeaderNone');
    };
    _.initGEvents = function() {
      var i, item, len, list;
      //@[SHORTCUT]
      AA.EV = KDCore.GEventsManager;
      list = [
        'PlayerSkillSelector', // * Когда игрок начинает выбирать зону действия навыка
        // * Когда выполнился (закончился) навык Projectile на карте
        // * Запрашивает очистку кеша
        'MapSkillsRequestsClean',
        'UnderMouseEventChanged', // * Смена события под курсором
        'ABSPartyLeaderReady', // * Персонаж игрока готов
        'ABSPartyLeaderNone' // * Больше нет персонажа игрока (пустая партия)
      ];
      for (i = 0, len = list.length; i < len; i++) {
        item = list[i];
        KDCore.GEventsManager.register(item);
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AATimer.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
// * Таймер для навыков, хранит время в кадрах (frames)
var AATimer;

AATimer = class AATimer {
  constructor(maxValue1 = 0, value1 = 0) {
    this.maxValue = maxValue1;
    this.value = value1;
  }

  update() {
    if (!this.isReady()) {
      return this.value++;
    }
  }

  isReady() {
    return this.value >= this.maxValue;
  }

  start(maxValue) {
    this.reset();
    return this.maxValue = Math.abs(Math.round(maxValue));
  }

  reset() {
    return this.value = 0;
  }

  getSeconds() {
    return AATimer.ConvertFramesToSeconds(this.value);
  }

  getMaxSeconds() {
    return AATimer.ConvertFramesToSeconds(this.maxValue);
  }

  getSecondsLeft() {
    return this.getMaxSeconds() - this.getSeconds();
  }

  static ConvertFramesToSeconds(value) {
    return (value / 60.0).toFixed(1);
  }

};

// ■ END AATimer.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ
//@[STORABLE]
var AIFlowMachine;

AIFlowMachine = class AIFlowMachine {
  constructor(id) {
    this.id = id;
    this.state = 0;
    this.prevState = -1;
    this._stateFlows = [];
    this._setup();
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
    return;
  }

  registerFlowForState(stateId, flowObject) {
    return this._stateFlows[stateId] = flowObject;
  }

  char() {
    return $gameMap.event(this.id);
  }

  entity() {
    return this.char().AAEntity();
  }

  battler() {
    return this.char().AABattler();
  }

  isActive() {
    return this.char().isActive();
  }

  logic() {
    return this.char().AALogic();
  }

  model() {
    return this.char().AAModel();
  }

  getStateFlow(stateId) {
    return this._stateFlows[stateId];
  }

  // * Сбросить состояние
  resetState() {
    return this.setState(0);
  }

  // * Установить состояние
  setState(newState) {
    // * Предыдущее состояние
    this.prevState = this.state;
    // * Текущее состояние (новое)
    this.state = newState;
    this._onStateChanged();
  }

  // * Перейти в состояние (без сброса данных, плавно)
  translateToState(newState) {
    this.prevState = this.state;
    this.state = newState;
    this._onStateTranslated();
  }

  update() {
    if (this.char() == null) {
      return;
    }
    if (!this.isActive()) {
      return;
    }
    // * Логика состояний работает только на мастере карты
    if (AA.Network.isNetworkGame() && !ANGameManager.isMapMaster()) {
      return;
    }
    this._updateStates();
    this._updateForNetwork();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AIFlowMachine.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AIFlowMachine.prototype;
  _._setup = function() {}; // * EMPTY
  _._setupForNetwork = function() {
    // * Сетевые методы вынесенны отдельно
    this._createNetworkObserver();
  };
  _._updateStates = function() {
    if (this.state < 0) {
      return;
    }
    if (this._stateFlows.length === 0) {
      return;
    }
    return this._stateFlows[this.state].update();
  };
  _._onStateChanged = function() {
    if (this.prevState >= 0) {
      this._stateFlows[this.prevState].onStateEnd();
    }
    this._stateFlows[this.state].onStateStart();
  };
  _._onStateTranslated = function() {
    if (this.prevState >= 0) {
      this._stateFlows[this.prevState].onStatePause();
    }
    this._stateFlows[this.state].onStateResume(this.prevState);
  };
  _._updateForNetwork = function() {
    return this._updateDataObserver();
  };
})();

// ■ END AIFlowMachine.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Обработка глобальных команд системы АБС
// (алтернатива KDCore.GEventsManager)
AA.GlobalHandler = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.GlobalHandler;
  _.PauseABS = function() {
    var e;
    try {
      $gamePlayer.gev_onABSPaused();
      $gameMap.eventsAA().forEach(function(e) {
        return e.gev_onABSPaused();
      });
      return $gameMap.followersAA().forEach(function(f) {
        return f.gev_onABSPaused();
      });
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//TODO: переместить в A_CORE или KDCOre

//TODO: см метод hitIndex в Window_Selectable - Там конверт глобал координат в локальные простой

//TODO: Убрать когда во всех моих плагинах будет KDCore 2.8
setTimeout((function() {
  return String.isNullOrEmpty = function(str) {
    if (str != null) {
      return str.toString().isEmpty();
    } else {
      return true;
    }
  };
}), 1000);

(function() {  // * Расширение, чтобы без XDev работал плагин
  var __STR_P;
  __STR_P = String.prototype.p;
  String.prototype.p = function(anotherText) {
    if (AA.isDEV()) {
      if (__STR_P != null) {
        __STR_P.call(this, anotherText);
      } else {
        console.log(this.toString(), anotherText);
      }
    } else {

    }
  };
  // * NOTHING
  Bitmap.prototype.drawTriangle = function(w, h, color) {
    var sy;
    this._context.save();
    this._context.fillStyle = color;
    this._context.beginPath();
    sy = this.height / 2;
    this._context.moveTo(0, sy);
    this._context.lineTo(w, sy - h);
    this._context.lineTo(w, sy + h);
    this._context.lineTo(0, sy);
    this._context.fill();
    this._context.restore();
    if (KDCore.isMV()) {
      this._setDirty();
    }
  };
})();

//TODO: NOT USED YET
// * Shake effect to Sprite
/*
do ->

    _ = KDCore.Sprite::

    _.startShake = (frames) ->
        #"START SHAKE".p()
 * * Создаём данные о движении
        @_shakeData = [frames, @x, @y]
        return

    #@[ALIAS]
    ALIAS__update = _.update
    _.update = ->
        ALIAS__update.call(@)
        @_updateShakeEffect() if @_shakeData?

    _._updateShakeEffect = ->
 * * Отсчёт
        @_shakeData[0]--
        #console.log(@_shakeData[0])
        remainingTime = @_shakeData[0]
 * * Пока только по X
        shakeX = Math.round(remainingTime * 0.4 * Math.cos(remainingTime))
        @x += shakeX
        @_endShake() if remainingTime <= 0
        return

    _._endShake = () ->
 * * Возвращаем начальные значения
        @x = @_shakeData[1]
        #@y = @_shakeData[2]
 * * Удаляем данные о движении
        @_shakeData = null
        return

    return

 * * Draggable sprite
#? KDCore.Sprite extension
do ->

    _ = KDCore.Sprite::

    _.setDraggable = (@_isDragActive) ->
        if @_isDragActive is true
            @_updateDragging = @_updateDraggingActive
        else
            @resetDrag() if @isDragging()
            @_updateDragging = () -> # * EMPTY

    _.isDraggable = -> @_isDragActive is true

    _.activateDrag = ->
        $gameTemp._kdDragSprite = @
        @_dragging = true
        @_lastTouchPosition = TouchInput.toPoint()
        @_deltaXY = @toPoint().delta(@_lastTouchPosition)
        do @dragStartHandler if @dragStartHandler?

    _.resetDrag = ->
        @_dragging = false
        unless @_lastTouchPosition.isSame(TouchInput.toPoint())
            do @dragEndHandler if @dragEndHandler?
        if $gameTemp._kdDragSprite is @
            $gameTemp._kdDragSprite = null
        @_lastTouchPosition = null
        return

    _.isDragging = -> @_dragging is true

    _.setOnDragEnd = (@dragEndHandler) ->

    _.setOnDragStart = (@dragStartHandler) ->

    _.setOnDrag = (@dragProcessHandler) ->

    _.isCanStartDragging = -> true

    #@[ALIAS]
    ALIAS__update = _.update
    _.update = ->
        ALIAS__update.call(@)
        @_updateDragging()

    #?DYNAMIC
    _._updateDragging = -> # * DUMMY

    _._updateDraggingActive = ->
        if @isDragging()
            @_updateDraggingProcess()
        else
            return if $gameTemp._kdDragSprite?
            if TouchInput.isPressed() and @isCanStartDragging()
                @activateDrag() if @isUnderMouse()

    _._updateDraggingProcess = ->
        if TouchInput.isPressed()
            return unless KDCore.Utils.isPointInScreen(TouchInput)
            @move TouchInput.x - @_deltaXY.x, TouchInput.y - @_deltaXY.y
            do @dragProcessHandler if @dragProcessHandler?
        else
            @resetDrag()

    return

 */


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ 1_PatchForMV.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _ALIAS_GHWG, _ALIAS_IMLA;
  if (KDCore.isMZ()) {
    return;
  }
  _ALIAS_GHWG = Graphics.hasWebGL;
  Graphics.hasWebGL = function() {
    if (Graphics.__hasWebGl != null) {
      return Graphics.__hasWebGl;
    }
    Graphics.__hasWebGl = _ALIAS_GHWG.call(this);
    return Graphics.__hasWebGl;
  };
  _ALIAS_IMLA = ImageManager.loadAnimation;
  ImageManager.loadAnimation = function(filename, hue) {
    if (Graphics.hasWebGL()) {
      hue = 0;
    }
    return _ALIAS_IMLA.call(this, filename, hue);
  };
  (function() {
    var ALIAS_SA_IM, ALIAS_SA_LB, ALIAS_SA_UCS, _;
    
    //@[DEFINES]
    _ = Sprite_Animation.prototype;
    ALIAS_SA_IM = _.initMembers;
    _.initMembers = function() {
      ALIAS_SA_IM.call(this);
      if (!Graphics.hasWebGL()) {
        return;
      }
      this._filter = this._filter || [];
      this._colorMatrix1 = new PIXI.filters.ColorMatrixFilter();
      return this._colorMatrix2 = new PIXI.filters.ColorMatrixFilter();
    };
    ALIAS_SA_LB = _.loadBitmaps;
    _.loadBitmaps = function() {
      if (Graphics.hasWebGL()) {
        this._colorMatrix1.hue(this._animation.animation1Hue);
        this._colorMatrix2.hue(this._animation.animation2Hue);
      }
      return ALIAS_SA_LB.call(this);
    };
    ALIAS_SA_UCS = _.updateCellSprite;
    _.updateCellSprite = function(sprite, cell) {
      var a;
      ALIAS_SA_UCS.call(this, sprite, cell);
      if (!Graphics.hasWebGL()) {
        return;
      }
      a = cell[0];
      if (a >= 0 && a < 100) {
        this._colorMatrix1.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix1];
      } else if (a >= 0 && a >= 100) {
        this._colorMatrix2.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix2];
      }
    };
  })();
  (function() {
    var _ALIAS_WBTC;
    AA.__CCACHE = {};
    _ALIAS_WBTC = Window_Base.prototype.textColor;
    Window_Base.prototype.textColor = function(color) {
      var colorD;
      if (AA.__CCACHE[color] != null) {
        return AA.__CCACHE[color];
      } else {
        colorD = _ALIAS_WBTC.call(this, color);
        AA.__CCACHE[color] = colorD;
        return colorD;
      }
    };
  })();
})();

// ■ END Patch_00.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var UIElementController;
  // * Общий класс для UI контролллеров (которые должны обновлять UI элементы)

    //?rev 17.10.20
  UIElementController = class UIElementController {
    constructor() {}

    setup(source) { // * EMPTY
      this.source = source;
      this._setup();
      return this._setupThread();
    }

    // * DYNAMIC значит что тело метода может быть изменнено позже
    //?DYNAMIC
    update() {} // * DUMMY

    
      // * Общий метод
    refresh() {
      var e;
      if (this.source == null) {
        return;
      }
      try {
        this._refresh();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Убираем источник с ошибкой и отключаем поток
        this.clear();
      }
    }

    clear() {
      this.source = null;
      this.thread = null;
      return this.update = function() {};
    }

    // * Создать поток обнолвения
    createThread(t = 10, dt = 4) {
      this.thread = new KDCore.TimedUpdate(t, () => {
        return this.refresh();
      });
      // * чтобы все контроллеры не делали проверку в один фрейм
      this.thread.applyTimeRange(-dt, dt);
      // * Добавим поток в метод Update
      this.update = () => {
        return this.thread.update();
      };
      // * Обновим значения сразу
      return this.thread.call();
    }

  };
  AA.link(UIElementController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UIElementController.prototype;
  _._setup = function() {}; // * Метод для потомков (настройка)
  _._setupThread = function() {}; // * Метод для потомков (создание потока)
  _._refresh = function() {}; // * Метод для потомков (обновление)
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Данный класс используется чтобы вызывать (использовать)
// ABS навыки через uAPI
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AADummyCharacter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var AADummyCharacter;

AADummyCharacter = class AADummyCharacter extends Game_Character {
  constructor(ownerId, teamId, uId = null) {
    super();
    this.ownerId = ownerId;
    this.teamId = teamId;
    this.uId = uId;
    if (this.uId == null) {
      this.generateId();
      AANetworkManager.sendDummyCharacterData(this.ownerId, this.teamId, this.uId);
    }
    this.aaEntity = new AADummyEntity(this.ownerId, this.teamId, this.uId);
    $gameMap.aaRegisterGlobalSkill(this.uId, this);
    return;
  }

  setFromNetwork() {
    return this._isFromNetwork = true;
  }

  AASprite() {
    return null;
  }

  AAEntity() {
    return this.aaEntity;
  }

  isActive() {
    return true;
  }

  generateId() {
    return this.uId = this.ownerId + this.teamId + $gameMap.mapId() + KDCore.makeId(3);
  }

  dispose() {
    // * Те, которые пришли от сервера, от него и уничтожаться
    if (!this._isFromNetwork) {
      AANetworkManager.sendDisposeDummyCharacter(this.uId);
    }
    return $gameMap.aaDisposeGlobalSkill(this.uId);
  }

};


// ■ END AADummyCharacter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Определение класса в файле 1_AAEnemyBattler.js
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEnemyBattler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  _.aaInit = function() {
    // * Проверка делается один раз, так как навыки не меняются
    this._isHaveAnyAASkill = this._checkAASkillsInActions();
    this._aaAttackHitAnimationId = this.char().AAModel().hitAnimationId;
  };
  _.AACharacter = function() {
    return this.char();
  };
  _.char = function() {
    return $gameMap.event(this.eventId);
  };
  _.getAASkills = function() {
    return this._selectAASkillsFromActions().map(function(skillId) {
      return $dataSkills[skillId];
    });
  };
  
  // * Если ли у врага хотябы одно действие с АБС навыком
  _.isHaveAnyAASkill = function() {
    return this._isHaveAnyAASkill === true;
  };
  _.aaIsActionValid = function(action) {
    return AA.Utils.isAAObject(action.skillId);
  };
  _.isActionValid = function(action) {
    var isABS;
    isABS = this.aaIsActionValid(action);
    return isABS && Game_Enemy.prototype.isActionValid.call(this, action);
  };
  _.attackAnimationId1 = function() {
    return this._aaAttackHitAnimationId;
  };
  // * У монстров не может быть двуручной атаки, поэтому всегда 0
  _.attackAnimationId2 = function() {
    return 0;
  };
  //$[OVER]
  return _.getDefaultWeaponMotionAnimationWeaponId = function() {
    var e;
    try {
      return this.char().AAModel().weaponMotionType;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return 0;
  };
})();

(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  // * Среди всех действий врага, есть хотябы одно АБC
  // * Эта проверка нужна, чтобы сразу отметить врага как неспособного сражаться
  _._checkAASkillsInActions = function() {
    var aaActions;
    aaActions = this.enemy().actions.filter((a) => {
      return this.aaIsActionValid(a);
    });
    return aaActions.length > 0;
  };
  // * Выборка всех возможных АБС навыков из доступных действий
  // * (Тут смотритеся и canUse и можно ли использовать действие по условию в самом действии)
  _._selectAASkillsFromActions = function() {
    var aaSkills, actionList;
    aaSkills = [];
    actionList = this.enemy().actions.filter((a) => {
      return this.isActionValid(a);
    });
    if (actionList.length > 0) {
      aaSkills = this._aaSelectAllABSActions(actionList);
    }
    return aaSkills;
  };
  
  // * Метод аналогичен selectAllActions, только изменён под АБС
  // * Возвращает все АА навыки, которые проходят условия Action из БД
  _._aaSelectAllABSActions = function(actionList) {
    var aaSkills, action, i, j, ratingMax, ratingZero, ref;
    aaSkills = [];
    ratingMax = Math.max(...actionList.map(function(a) {
      return a.rating;
    }));
    ratingZero = ratingMax - 3;
    actionList = actionList.filter(function(a) {
      return a.rating > ratingZero;
    });
    for (i = j = 0, ref = actionList.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      action = this.selectAction(actionList, ratingZero);
      if (action != null) {
        aaSkills.push(action.skillId);
      }
    }
    return aaSkills;
  };
})();

// ■ END AAEnemyBattler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEnemyBattler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  //$[OVER]
  _.dataObserverHaveChanges = function() {
    AANetworkManager.syncAAEnemyBattlerObserver(this.AACharacter(), this.getObserverDataForNetwork());
  };
})();

// ■ END AAEnemyBattler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AAProjectile;

AAProjectile = class AAProjectile {
  constructor(aaSkill, subject, pointData) {
    this.aaSkill = aaSkill;
  }

};


// Generated by CoffeeScript 2.6.1
// * Данный класс хранит данные об АБС state для каждого Battler

// * Правила работы состояний

//onActionEnd - после выполнения любого АБС навыка (атаки в т.ч) Х раз (Duration in Turns)
//onBattleEnd - после отключения АБС режима (uAPI.pauseABS())
//onTurnEnd - после Х секунд (Duration in Turns)

// Каждую секунду вызывается onTick (если есть), приминимо к любому ABS состоянии
// (даже если у него нет onTurnEnd)

//@[STORABLE]
var AAStatesSet;

AAStatesSet = class AAStatesSet {
  constructor(battler) {
    this._packedSubject = AA.Utils.packAAEntity(battler.AACharacter());
    this._aaStateTimers = {};
    this._aaStateActionCounts = {};
    // * Таймеры для баффов (-1 значение не задано, таймер не идёт)
    this._aaBuffsTimers = [-1, -1, -1, -1, -1, -1, -1, -1];
    return;
  }

  isNotHaveBattler() {
    return this._packedSubject == null;
  }

  // * Значение для вывода на UI (оставшееся время или действия)
  getDisplayValueForState(stateId) {
    if (this._aaStateActionCounts[stateId] != null) {
      return this._aaStateActionCounts[stateId];
    } else if (this._aaStateTimers[stateId] != null) {
      return this._aaStateTimers[stateId][1];
    } else {
      return -1; // * no value
    }
  }

  battler() {
    var subject;
    subject = this.subject();
    if (subject != null) {
      return subject.AABattler();
    }
    return null;
  }

  subject() {
    return AA.Utils.unpackAAEntity(this._packedSubject);
  }

  // * Если система ABS была отключена
  onABSSystemStop(battler) {
    var battleEndStates, states;
    states = battler.states().filter(function(s) {
      return AA.Utils.isAAState(s);
    });
    battleEndStates = states.filter(function(s) {
      return s.AAState.isRemovedAtBattleEnd();
    });
    battleEndStates.forEach(function(s) {
      return battler.removeState(s.id);
    });
  }

  // * Когда battler выполнил какое-либо действие
  onAnyActionDone() {
    var k, ref, v;
    ref = this._aaStateActionCounts;
    //"ON ACTION DONE".p()
    // * Изменяем счётчик действий состояний
    for (k in ref) {
      v = ref[k];
      this._aaStateActionCounts[k]--;
      this.battler()._stateTurns[k] = this._aaStateActionCounts[k];
    }
  }

  // * battler передаётся чтобы управлять через него
  // * например удалить состояние (если время вышло)
  // * или выполнить Script Action
  // * или наложить доп. эффект (снять эффект)
  //? Не передаётся как @, потому что класс Storable
  // * Для оптимизации передаём battler сразу, без распаковки каждый кадр
  update(battler) {
    this._updateTimers(battler);
    this._updateActionCounters(battler);
    this._updateBuffs(battler);
  }

  checkBattler(battler) {
    var e;
    try {
      if (this._packedSubject == null) {
        return this._packedSubject = AA.Utils.packAAEntity(battler.AACharacter());
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  item(stateId) {
    return AA.Utils.getAAStateObject(stateId).AAState;
  }

  add(stateId) {
    var e;
    try {
      // * На battler состояние уже есть, когда этот метод вызывается
      this._pushNewState(stateId);
      this._onStateAdded(stateId);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  // * Все AAState объекты на персонаже
  allStates() {
    var e, states;
    try {
      states = this.battler().states().map((i) => {
        return this.item(i.id);
      });
      return states.filter(function(s) {
        return s != null;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  }

  remove(stateId) {
    var e;
    try {
      // * На battler состояния уже нету когда этот метод вызывается
      this._deleteState(stateId);
      this._onStateRemoved(stateId);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AAStatesSet.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AAStatesSet.prototype;
  _._pushNewState = function(stateId) {
    var aaState, ref, ref1;
    aaState = this.item(stateId);
    // * АБС состояние с onTick всё равно имеет таймер
    if (AA.SAaction.isProper(aaState.onTick)) {
      // * [текущий таймер, кол-во секунд осталось]
      // * так надо, чтобы выполнять onTick
      this._aaStateTimers[stateId] = [
        0,
        -1 // -1 - нет предела
      ];
    }
    if (aaState.isActionEndState()) {
      this._aaStateActionCounts[stateId] = aaState.getTurnsValue();
      if ((ref = this.battler()) != null) {
        ref._stateTurns[stateId] = this._aaStateActionCounts[stateId];
      }
    } else if (aaState.isTimeEndState()) {
      // * Заменяем бесконечное время (-1) на TurnsValue
      this._aaStateTimers[stateId] = [0, aaState.getTurnsValue()];
      // * Возвращаем новое значение на Battler
      if ((ref1 = this.battler()) != null) {
        ref1._stateTurns[stateId] = this._aaStateTimers[stateId][1];
      }
    }
  };
  _._deleteState = function(stateId) {
    delete this._aaStateTimers[stateId];
    delete this._aaStateActionCounts[stateId];
  };
  _._onStateAdded = function(stateId) {
    var e, state;
    try {
      state = this.item(stateId);
      if (state == null) {
        return;
      }
      this._checkStateExtraParameters(state);
      if (AA.SAaction.isProper(state.onStart)) {
        return AA.SAaction.execute(state.onStart, this.subject());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._checkStateExtraParameters = function(state) {
    var e, ref;
    if (state == null) {
      return;
    }
    try {
      if (state.isHaveSpeedMod()) {
        if ((ref = this.battler()) != null) {
          ref.aaSetSpeedMod(state.speedMod);
        }
      } else {
        // * На всякий случай
        this._checkForSpeedMods();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._onStateRemoved = function(stateId) {
    var e, state;
    try {
      this._checkForSpeedMods();
      state = this.item(stateId);
      if (state == null) {
        return;
      }
      if (AA.SAaction.isProper(state.onEnd)) {
        return AA.SAaction.execute(state.onEnd, this.subject());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._checkForSpeedMods = function() {
    var b, e, stateWithSpeed;
    try {
      b = this.battler();
      if (b == null) {
        return;
      }
      b.aaSetSpeedMod(null);
      // * Возможно есть другие с мод. скорости
      stateWithSpeed = this.allStates().find(function(s) {
        return s.isHaveSpeedMod();
      });
      if (stateWithSpeed != null) {
        return b.aaSetSpeedMod(stateWithSpeed.speedMod);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  
  // * Battler передаётся сразу (для оптимизации)
  // * Так как onStateTick вызывается из метода _updateTimers,
  // * который уже имеет ссылку на battler
  //? Вызывается каждую секунду действия состояния
  _._onStateTick = function(stateId, battler) {
    var state;
    state = this.item(stateId);
    if (state.onTick != null) {
      if (battler == null) {
        battler = this.battler();
      }
      AA.SAaction.execute(state.onTick, battler.AACharacter());
    }
    if (state.isHaveActiveSkill()) {
      this._executeStateActiveSkill(stateId, battler.AACharacter());
    }
  };
  // * Выполнить активный навык для состояния
  _._executeStateActiveSkill = function(stateId, character) {
    var absSkill, e, executeSkillDelayed, j, len, ownerId, params, skill, state, t, targets, teamId, turnsLeft;
    try {
      state = this.item(stateId);
      params = state.getActiveSkillParameters();
      // * Получаем остаток от оставшихся секунд, чтобы узнать можно выполнять или нет
      // * Если остаток == 0, значит делится, т.е. можно выполнить
      if (params.rate > 1) {
        turnsLeft = this.getDisplayValueForState(stateId);
        if (turnsLeft % params.rate !== 0) {
          return;
        }
      }
      skill = $dataSkills[params.skillId];
      if (skill == null) {
        return;
      }
      absSkill = skill.AASkill;
      if (absSkill == null) {
        return;
      }
      // * Если радиус 0, то выбираем себя
      if (params.radius === 0) {
        targets = [character];
      } else {
        // * Находим все возможные цели в области действия состояния
        targets = AATargetsManager.getAvailableTargetsInRadius(character, params.radius);
        // * Фильтруем по дистанции и лимиту
        targets = AATargetsManager.applySkillTargetsLimit(character, targets, absSkill);
      }
      if (targets == null) {
        return;
      }
      if (targets.length === 0) {
        return;
      }
      ownerId = character.aaCharId();
      teamId = character.AAEntity().teamId();
      executeSkillDelayed = function(charId) {
        return AA.Utils.callDelayed(function() {
          return uAPI.executeAASkillOnChar(ownerId, teamId, params.skillId, charId);
        }, Math.random() * 400);
      };
      for (j = 0, len = targets.length; j < len; j++) {
        t = targets[j];
        // * Через отдельный метод, чтобы не было дублирование eventId
        executeSkillDelayed(t.aaCharId());
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  _._updateTimers = function(battler) {
    var k, ref, v;
    ref = this._aaStateTimers;
    for (k in ref) {
      v = ref[k];
      this._aaStateTimers[k][0]++;
      if (this._aaStateTimers[k][0] >= 60) {
        this._aaStateTimers[k][0] = 0;
        // * Только если больше 0 (т.к. -1 - бесконечно)
        if (this._aaStateTimers[k][1] > 0) {
          this._aaStateTimers[k][1]--;
          // * зеркалим обратно на Battler
          battler._stateTurns[k] = this._aaStateTimers[k][1];
        }
        // * Tick не выполняется на последней секунде
        if (this._aaStateTimers[k][1] !== 0) {
          this._onStateTick(parseInt(k), battler);
        } else {
          //"REMOVE BY TIMER".p(k)
          // * ключи хранятся как String
          battler.removeState(parseInt(k));
        }
      }
    }
  };
  _._updateActionCounters = function(battler) {
    var k, ref, results, v;
    ref = this._aaStateActionCounts;
    results = [];
    for (k in ref) {
      v = ref[k];
      if (this._aaStateActionCounts[k] === 0) {
        //"REMOVE BY ACTION COUNT".p(k)
        results.push(battler.removeState(parseInt(k)));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  // * Этот метод считает секунды на каждый бафф и уменьшает количество "ходов" для баффов
  _._updateBuffs = function(battler) {
    var index, j, len, ref, turn;
    ref = battler._buffTurns;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      turn = ref[index];
      if (turn > 0) { // * Есть время (т.е. бафф действует)
        if (this._aaBuffsTimers[index] < 0) {
          this._aaBuffsTimers[index] = 60; // * один ход = 1 секунда
        } else if (this._aaBuffsTimers[index] === 0) { // * время вышло
          this._aaBuffsTimers[index] = 60;
          battler._buffTurns[index]--;
          if (battler._buffTurns[index] <= 0) {
            //"buff expired, index".p(index)
            battler.removeBuffsAuto();
            continue; // * Бафф удалён, таймер считать не надо, следующий
          }
        }
        this._aaBuffsTimers[index]--;
      } else {
        if (this._aaBuffsTimers[index] >= 0) {
          // * Обнуляем таймер
          //"reset buff timer for buff index".p(index)
          this._aaBuffsTimers[index] = -1;
        }
      }
    }
  };
})();

// ■ END AAStatesSet.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AIFlowMachine.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AIFlowMachine.prototype;
  _._createNetworkObserver = function() {
    this.netDataObserver = new DataObserver();
    this.netDataObserver.setCheckInterval(10); //TODO: ???
    this._fillNetworkObserver();
    return this.netDataObserver.refreshAll(this);
  };
  //TODO: Добавить API для разработчиков плагинов вносить свои поля (и так со всем Observers)
  // * Движение передаётся отдельным методом для достижения плавности
  _._fillNetworkObserver = function() {
    return this.netDataObserver.addFields(this, ["state", "prevState"]);
  };
  _._updateDataObserver = function() {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.check(this);
    if (this.netDataObserver.isDataChanged()) {
      this.dataObserverHaveChanges();
      this.netDataObserver.refreshAll(this);
    }
  };
  // * Этот метод вызывается, когда изменились сихнронизируеммые данные
  _.dataObserverHaveChanges = function() {
    AANetworkManager.syncAIFlowMachineObserver(this.id, this._getObserverDataForNetwork());
  };
  _._getObserverDataForNetwork = function() {
    return this.netDataObserver.getDataForNetwork(this);
  };
  _.applyObserverData = function(data) {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.setDataFromNetwork(this, data);
  };
})();

// ■ END AIFlowMachine.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит набор навыков на панели для персонажей
// * Хранит настройку панели навыков для каждого персонажа группы

//@[STORABLE]
var AASkillsSet;

AASkillsSet = class AASkillsSet {
  constructor() {
    // * Позиции на панели для навыков
    this.bingings = {};
    this.currentActorId = 0;
    return;
  }

  // * Установить ActorId из Game_Player (shortcut)
  setPlayerActorId() {
    return this.setActorId($gamePlayer.AABattler().actorId());
  }

  // * Установить персонажа, с которым будем работать
  setActorId(currentActorId) {
    this.currentActorId = currentActorId;
    // * Если персонаж не настроен, то показать стандартные навыки
    if (this.bingings[this.currentActorId] == null) {
      this.bingings[this.currentActorId] = {};
      this.setupDefaultSkillsForActor();
    }
  }

  allSymbols() {
    return AA.Input.skillPanelSymbols;
  }

  currentSet() {
    return this.bingings[this.currentActorId] || {};
  }

  setSkillInEmptySlot(skillId) {
    var i, len, s, symbols, tempId;
    symbols = this.allSymbols();
    for (i = 0, len = symbols.length; i < len; i++) {
      s = symbols[i];
      if (!AA.Input.isSymbolSupportAutoBinding(s)) {
        continue;
      }
      // * Автоматически нельзя поставить в E и Q слоты
      //continue if s == AA.Input.primarySkillSymbol()
      //continue if s == AA.Input.secondarySkillSymbol()
      tempId = this.getSkillForSymbol(s);
      if (tempId <= 0 && this.isCanAutoSetSkillToSymbol(skillId, s)) {
        this.setSymbolForSkill(skillId, s, null);
        break;
      }
    }
  }

  isCanAutoSetSkillToSymbol(skillId, symbol) {
    var e, obj, settings, specifiedIds;
    try {
      settings = AA.PP.getUISkillItemSlotSettings(symbol);
      if (settings == null) {
        return true;
      }
      if (settings.filter == null) {
        // * Проверка что данные актуальные (существуют поля)
        return true;
      }
      if (settings.filter === "Skills") {
        if (AA.Utils.isAAItem(skillId)) {
          return false;
        }
      }
      if (settings.filter === "Items") {
        if (AA.Utils.isAASkill(skillId)) {
          return false;
        }
      }
      try {
        if (String.any(settings.specifiedIds)) {
          specifiedIds = AA.Utils.Parser.convertArrayFromParameter(settings.specifiedIds);
        } else {
          specifiedIds = null;
        }
      } catch (error) {
        e = error;
        AA.w(e);
        specifiedIds = null;
      }
      if ((specifiedIds != null) && specifiedIds.length > 0) {
        obj = AA.Utils.getAASkillObject(skillId);
        if (obj != null) {
          return specifiedIds.contains(obj.id);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return true;
  }

  setSymbolForSkill(skillId, symbNew, symbOld) {
    var e, existsOnSymb, existsValues, set;
    //skillInNewPos = @getSkillForSymbol(symbNew)
    set = this.currentSet();
    try {
      // * Проверяем чтобы дубликатов не было
      if (skillId > 0) {
        existsValues = Object.values(set);
        if (existsValues.contains(skillId)) {
          existsOnSymb = this.getSymbolForSkill(skillId);
          this.setSymbolForSkill(0, existsOnSymb, null);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    set[symbNew] = skillId;
  }

  //if skillInNewPos > 0
  //    @currentSet()[symbOld] = skillInNewPos if symbOld?
  getSymbolForSkill(skillId) {
    var key, ref, value;
    ref = this.currentSet();
    for (key in ref) {
      value = ref[key];
      if (value === skillId) {
        return key;
      }
    }
    return null;
  }

  getSkillForSymbol(symbol) {
    var skillId;
    skillId = this.currentSet()[symbol];
    if (skillId > 0) {
      return skillId;
    } else {
      return 0;
    }
  }

  setupDefaultSkillsForActor() {
    var attackSkillId, battler, e, i, len, ref, s, secondarySkillId;
    try {
      this.setupActorAttackSkillInPrimarySlot();
      battler = $gameParty.leader();
      if (battler == null) {
        return;
      }
      attackSkillId = battler.attackSkillId();
      // * Добавляем остальные навыки
      secondarySkillId = battler.aaGetDefaultSecondarySkillId();
      if (secondarySkillId > 0) {
        this.setSkillInEmptySlot(secondarySkillId);
      }
      ref = battler.getAASkills();
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        if (s.idA === attackSkillId) {
          continue;
        }
        if (s.idA === secondarySkillId) {
          continue;
        }
        this.setSkillInEmptySlot(s.idA);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  setupActorAttackSkillInPrimarySlot() {
    var attackSkillId, battler;
    battler = $gameParty.leader();
    if (battler == null) {
      return;
    }
    attackSkillId = battler.attackSkillId();
    this.setSymbolForSkill(attackSkillId, AA.Input.primarySkillSymbol(), null);
  }

  // * Возвращает ID всех предметов на панели
  getAllItemsFromPanel() {
    var i, id, items, len, s, symbols;
    items = [];
    symbols = this.allSymbols();
    for (i = 0, len = symbols.length; i < len; i++) {
      s = symbols[i];
      id = this.getSkillForSymbol(s);
      if (AA.Utils.isAAItem(id)) {
        items.push(id);
      }
    }
    return items;
  }

  
    // * Есть ли предмет на панели
  // * Этот метод используется в автоматическом добавлении новых предметов
  // * Чтобы не добавлять один и тот же предмет несколько раз
  isHaveItemOnPanel(id) {
    return this.getAllItemsFromPanel().contains(id);
  }

  // * Переопределяет навык Атаки на панели, если было экипировано оружие
  // * с другим навыком атаки
  refreshAttackSkillBinding() {
    return this.setupActorAttackSkillInPrimarySlot();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AASkillsSet.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AASkillsSet.prototype;
})();

// ■ END AASkillsSet.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит таймеры для набора АБС навыков (и предметов) для Battler

//@[STORABLE]
var AASkillsTimers;

AASkillsTimers = class AASkillsTimers {
  constructor() {
    // * Таймеры для навыков
    this._timers = [];
    // * Для оптимизации, ID навыков для которых запущен таймер храняться отдельно
    this._skills = [];
    return;
  }

  startTimerForSkill(skillId, time) {
    var timer;
    timer = new AATimer();
    timer.skillId = skillId;
    // * Перевод из секунд в кадры
    timer.start(time * 60);
    this._timers.push(timer);
    this._skills.push(skillId);
  }

  isSkillHaveTimer(skillId) {
    return this._skills.contains(skillId);
  }

  isSkillHaveTimerToShow(skillId) {
    return this.isSkillHaveTimer(skillId) && this.getTimerForSkill(skillId).maxValue >= 60;
  }

  // * В секундах
  getRemainTimeForSkill(skillId) {
    if (this.isSkillHaveTimer(skillId)) {
      return this.getTimerForSkill(skillId).getSecondsLeft();
    } else {
      return 0;
    }
  }

  getTimerForSkill(skillId) {
    return this._timers.find(function(t) {
      return t.skillId === skillId;
    });
  }

  update() {
    var e, i, j, len, len1, ref, t, toDelete;
    try {
      ref = this._timers;
      // * Опасно удалять в переборке массива
      for (i = 0, len = ref.length; i < len; i++) {
        t = ref[i];
        if (t == null) {
          continue;
        }
        t.update();
        if (t.isReady()) {
          this._skills.delete(t.skillId);
          if (typeof toDelete === "undefined" || toDelete === null) {
            toDelete = [];
          }
          toDelete.push(t);
        }
      }
      if (toDelete != null) {
        for (j = 0, len1 = toDelete.length; j < len1; j++) {
          t = toDelete[j];
          this._timers.delete(t);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AASkillsTimers.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AASkillsTimers.prototype;
})();

// ■ END AASkillsTimers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Методы для улучшенной совместимости с Extended Loot

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_ExtendedLoot !== true) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Party.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__pelOnSomeItemBeenGained, _;
    
    //@[DEFINES]
    _ = Game_Party.prototype;
    
    //@[ALIAS]
    ALIAS__pelOnSomeItemBeenGained = _.pelOnSomeItemBeenGained;
    _.pelOnSomeItemBeenGained = function() {
      var e;
      try {
        this.pOnItemBeenGainedProcess();
      } catch (error) {
        e = error;
        AA.w(e);
      }
      ALIAS__pelOnSomeItemBeenGained.call(this);
    };
  })();
  return (function() {    // ■ END Game_Party.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Scene_Map.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__createSpriteset, _;
    
    //@[DEFINES]
    _ = Scene_Map.prototype;
    
    //TODO: Временное решение, до обновления Extended Loot 1.2
    //@[ALIAS]
    ALIAS__createSpriteset = _.createSpriteset;
    _.createSpriteset = function() {
      ALIAS__createSpriteset.call(this);
      if (this._pelVisualDropSpriteset == null) {
        this._pelVisualDropSpriteset = new Sprite();
        this.addChild(this._pelVisualDropSpriteset);
      }
    };
  })();
});

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Методы для улучшенной совместимости с MapInventory

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_MapInventory !== true) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PKD_MI.LIBS.MapChestController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onGainItemFinal, _;
    
    //@[DEFINES]
    _ = PKD_MI.LIBS.MapChestController.prototype;
    
    //@[ALIAS]
    ALIAS___onGainItemFinal = _._onGainItemFinal;
    _._onGainItemFinal = function() {
      ALIAS___onGainItemFinal.call(this, ...arguments);
      AA.Utils.callDelayed($gameParty.pOnSomeItemBeenGained.bind($gameParty), 1);
    };
  })();
  (function() {    // ■ END PKD_MI.LIBS.MapChestController.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PKD_MI.LIBS.MapUserChestController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onStoreItemFinal, _;
    
    //@[DEFINES]
    _ = PKD_MI.LIBS.MapUserChestController.prototype;
    
    //@[ALIAS]
    ALIAS___onStoreItemFinal = _._onStoreItemFinal;
    _._onStoreItemFinal = function() {
      ALIAS___onStoreItemFinal.call(this, ...arguments);
      return AA.Utils.callDelayed($gameParty.pOnSomeItemBeenGained.bind($gameParty), 1);
    };
  })();
  return (function() {    // ■ END PKD_MI.LIBS.MapUserChestController.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Spriteset_InvUI.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onReleaseDraggingCell, _;
    
    // * Возможность перетаскивания с инвентаря на панель навыков (только предметы)

    //@[DEFINES]
    _ = Spriteset_InvUI.prototype;
    if (!PKD_MI.isPro()) {
      return;
    }
    //@[ALIAS]
    ALIAS___onReleaseDraggingCell = _._onRelaseDragginCell;
    _._onRelaseDragginCell = function() {
      var symbol;
      symbol = AA.UI.getSkillSymbolUnderMouse();
      if (String.any(symbol)) {
        if (this._aaIsProperItemToPutInSkillPanelSlot(symbol)) {
          uAPI.setItemToPanel(this._dragItem.id, symbol);
        } else {
          SoundManager.playBuzzer();
        }
        return;
      }
      return ALIAS___onReleaseDraggingCell.call(this);
    };
    //?[NEW]
    _._aaIsProperItemToPutInSkillPanelSlot = function(symbol) {
      return DataManager.isItem(this._dragItem) && AA.Utils.isAAObject(this._dragItem) && AA.Input.isEditableSymbol(symbol);
    };
  })();
});

// ■ END Spriteset_InvUI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NETCharacter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
AA.Network.SetupNETCharacter = function() {
  var ALIAS__initMembersAABSZNET, ALIAS__isABS, _;
  //@[DEFINES]
  _ = NETCharacter.prototype;
  //TODO: Синхронизировать Active состояние?

  //@[ALIAS]
  ALIAS__initMembersAABSZNET = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembersAABSZNET.call(this, ...arguments);
    // * Чтобы ID определился (Character_Base вызывает initMembers без ID)
    AA.Utils.callDelayed(this._initMembersABS.bind(this), 100);
  };
  //@[ALIAS]
  ALIAS__isABS = _.isABS;
  _.isABS = function() {
    return ALIAS__isABS.call(this) && (this.playerData() != null) && (this.actor() != null);
  };
  //$[OVER]
  // * Сам ничего не обновляет, принимает команду от сервера (если надо)
  _.aaUpdateABSAnimaXInBattleState = function() {}; // * EMPTY
  _.aaIsSupportMotion = function() {
    return AA.PP.getShowDeadMotionOnDeathType() > 0;
  };
  // * =================================================================
  _._initMembersABS = function() {
    if (this.id == null) {
      return;
    }
    this.aaEntity = new AANetworkCharEntity(this.id);
    this.initABS();
  };
  // * Переопределяем
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    if (this.isABS()) {
      return this.actor().aaGetExtendedHitBoxes();
    } else {
      return null;
    }
  };
};

// ■ END NETCharacter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Правильная обработка Dead состояния игрока

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_AnimaX !== true) {
    return;
  }
  //TODO: Remove this after PKD_AnimaX update 140
  if (PKD_ANIMAX.version <= 131) {
    //$[FIX]
    Game_Character.prototype.resetXAnima = function() {
      if (this.isInAnimXAction()) {
        this.onAnimaXActionEnd();
        if (this.__axShouldResetAnimaXAfterAction === true) {
          this.deleteAnimaX();
          this.__axShouldReloadBitmaps = true;
          this.__axShouldResetAnimaXAfterAction = null;
          return;
        }
      }
      this._xAnimaToIdleTimer = 0;
      this._setAnimaXToMovement();
    };
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ XAnimaSetController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___nextActionFrame, ALIAS___updateAction, _;
    
    //@[DEFINES]
    _ = XAnimaSetController.prototype;
    
    //@[ALIAS]
    ALIAS___updateAction = _._updateAction;
    _._updateAction = function(c) {
      var isInitialFrame;
      isInitialFrame = this._initialFrame === true;
      ALIAS___updateAction.call(this, ...arguments);
      if (this.rootAnimation.aaNoRepeatFlag === true && isInitialFrame === false && c._aaAnimaXDeathPlayedFlag === true) {
        this._initialFrame = false; // * Чтобы метод _setInitialFrame сработал ещё раз
        this._setInitialFrame(this.rootAnimation.frames - 1);
        this._nextActionFrame(c); // * Ставим сразу последний кадр
      }
    };
    
    //@[ALIAS]
    ALIAS___nextActionFrame = _._nextActionFrame;
    _._nextActionFrame = function(c) {
      var isLastFrame;
      isLastFrame = this.cFrame === this.rootAnimation.frames - 1;
      ALIAS___nextActionFrame.call(this, ...arguments);
      if (this.rootAnimation.aaNoRepeatFlag === true && isLastFrame === true) {
        this.cFrame = this.rootAnimation.frames - 1;
        c._aaAnimaXDeathPlayedFlag = true;
        this.requestRefresh();
      }
    };
    //$[OVER]
    _._isNextFrameBitmapIsReady = function() {
      return true;
    };
  })();
});

// ■ END XAnimaSetController.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Исправление Damage PopUp

//@[EXTENSION]
AA.extend(function() {
  if (Imported.VisuMZ_1_BattleCore !== true) {
    return;
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Battler.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__clearDamagePopup, ALIAS__isDamagePopupRequested, ALIAS__startDamagePopup, _;
    
    //@[DEFINES]
    _ = Game_Battler.prototype;
    
    //@[ALIAS]
    ALIAS__startDamagePopup = _.startDamagePopup;
    _.startDamagePopup = function() {
      ALIAS__startDamagePopup.call(this, ...arguments);
      if (AA.isMap()) {
        this._aaDamagePopUpRequested = true;
      }
    };
    //@[ALIAS]
    ALIAS__isDamagePopupRequested = _.isDamagePopupRequested;
    _.isDamagePopupRequested = function() {
      if (this._aaDamagePopUpRequested === true) {
        return true;
      } else {
        return ALIAS__isDamagePopupRequested.call(this, ...arguments);
      }
    };
    
    //@[ALIAS]
    ALIAS__clearDamagePopup = _.clearDamagePopup;
    _.clearDamagePopup = function() {
      ALIAS__clearDamagePopup.call(this, ...arguments);
      this._aaDamagePopUpRequested = null;
    };
  })();
});

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Методы для улучшенной совместимости с MZ3D

//@[EXTENSION]
AA.extend(AA.mz3d_patch);


// Generated by CoffeeScript 2.6.1
//@[EXTENSION]
AA.extend(function() {
  if (Imported.SAN_AnalogMove !== true) {
    return;
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_CharacterBase.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__updateAnalogMove, _;
    
    //@[DEFINES]
    _ = Game_CharacterBase.prototype;
    
    //@[ALIAS]
    ALIAS__updateAnalogMove = _.updateAnalogMove;
    _.updateAnalogMove = function() {
      var e;
      ALIAS__updateAnalogMove.call(this, ...arguments);
      try {
        return this._aaUpdate();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
});

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AA_NUI_Sprite_PlayerCastingProgressBar;

AA_NUI_Sprite_PlayerCastingProgressBar = class AA_NUI_Sprite_PlayerCastingProgressBar extends KDCore.Sprite {
  constructor() {
    super();
    this._progress = 0;
    this._create();
    return;
  }

  static Show() {
    var e, element;
    try {
      AA_NUI_Sprite_PlayerCastingProgressBar.Hide();
      element = new AA_NUI_Sprite_PlayerCastingProgressBar();
      AA.UI.addToUI(element);
      return AA.UI._playerCastingProgressBar = element;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  static Hide() {
    var e, element;
    try {
      element = AA.UI._playerCastingProgressBar;
      if (element != null) {
        element.removeFromParent();
      }
      return AA.UI._playerCastingProgressBar = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  // * Создание спрайта
  _create() {
    this.nuiElement = KDCore.Sprite_NUI.FromScheme($aabsz_NUI_PlayerCastingProgressBar, this, this);
    this.nuiElement.refreshBindings(this);
    this._setPositionFromUIBuilder();
  }

  _setPositionFromUIBuilder() {} //TODO: Set stored pos if user edit in UI Editor

  castingProgressRate() {
    return this._progress;
  }

  skillData() {
    return $gamePlayer._aaCastingNowSkill;
  }

  skillName() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      if (this.skillData() != null) {
        return this.skillData().name();
      }
    }
    return "";
  }

  castingTime() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      return $gamePlayer._aaCastingTimeMax;
    } else {
      return 0;
    }
  }

  castingTimeNow() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      return $gamePlayer._aaCastingTimer;
    } else {
      return 0;
    }
  }

  castingTimeLeft() {
    var timeLeft;
    timeLeft = this.castingTime() - this.castingTimeNow();
    timeLeft /= 60;
    // * Return time in 0.0 format
    return timeLeft.toFixed(1);
  }

  update() {
    super.update();
    return this._updateGaugeProgressValues();
  }

  _updateGaugeProgressValues() {
    var ref;
    if (!$gamePlayer.aaInSkillCastingProcess()) {
      this._progress = 0;
    } else {
      this._progress = this.castingTimeNow() / this.castingTime();
    }
    if ((ref = this.playerCastingProgressBarBase) != null) {
      ref.refreshBindings(this);
    }
  }

};

//TODO: UI EDITOR!


// Generated by CoffeeScript 2.6.1
// * Данный класс используется для AAEntity врагов на карте
var AAAllyEntity;

AAAllyEntity = class AAAllyEntity extends AAEntity {
  constructor(actorId) {
    super();
    this.actorId = actorId;
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
  }

  teamId() {
    return 0;
  }

  character() {
    return $gamePlayer.followers().aaGetFollowerByActorId(this.actorId);
  }

  battler() {
    return $gameActors.actor(this.actorId);
  }

  isAlly() {
    return true;
  }

  logic() {
    return this.aaLogic;
  }

  // * Настройки и параметры
  model() {
    return this.aaModel;
  }

  initABS() {
    if (this.model() == null) {
      super.initABS();
      // * Инициализация системы в первый раз
      this.aaModel = new AAAllyModelData(this.actorId);
      this.aaLogic = new AllyAI_FlowMachine(this.actorId);
    } else {

    }
  }

};

// * Ничего
// * Повторная инициализация (например после выхода из меню) не нужна


// Generated by CoffeeScript 2.6.1
// * Класс, который содержит все настройки и параметры AA сущности союзника на карте

//@[STORABLE]
//@[GLOBAL]
var AAAllyModelData;

AAAllyModelData = (function() {
  class AAAllyModelData {
    constructor(actorId) {
      this.actorId = actorId;
      this._initBaseParameters();
      this._applyParametersFromDB();
      this._convertParameters();
    }

    actor() {
      return $gameActors.actor(this.actorId);
    }

    actorData() {
      return this.actor().actor();
    }

    getBattleStartConditions() {
      return this.activateWhen;
    }

    getBattleStartUserCondition() {
      return this.extraActivateCond;
    }

    getCertainActionId() {
      return this.activateActionId;
    }

    getBestTargetCondition(index) {
      if (index < 4 && index > 0) {
        return this['bestTarget' + index];
      } else {
        return null;
      }
    }

    getBestSupportTargetCondition(index) {
      if (index < 4 && index > 0) {
        return this['bestHelp' + index];
      } else {
        return null;
      }
    }

    getBestTargetGroupCondition() {
      return this.bestTargetGroup;
    }

    getBestTargetUserCondition() {
      return this.extraTargetCond;
    }

    getBestSupportTargetUserCondition() {
      return this.helpCondition;
    }

    gNoMoveInBattle() {
      return AA.Utils.getSafeEValue(this.noMoveInBattle, 0);
    }

    gNoApproach() {
      return AA.Utils.getSafeEValue(this.noApproach, 0);
    }

    isHeavy() {
      return AA.Utils.getSafeEValue(this.heavy, 0) > 0;
    }

    gViewRadius() {
      return AA.Utils.getSafeEValue(this.viewRadius, 5);
    }

    gReturnRadius() {
      return AA.Utils.getSafeEValue(this.returnRadius, 12);
    }

    getRefreshBattleTargetTimeMax() {
      return this.bestTarRefreshTime;
    }

    isHaveSupportSkills() {
      return (this.supportSkills != null) && this.supportSkills.length > 0;
    }

    getSupportSkillsList() {
      if (this.isHaveSupportSkills()) {
        return this.supportSkills;
      } else {
        return [];
      }
    }

    getBattleSkillsPriorityList() {
      if ((this.skillsPriority != null) && this.skillsPriority.length > 0) {
        return this.skillsPriority;
      } else {
        return [];
      }
    }

    isCanSupport() {
      return String.any(this.getBestSupportTargetCondition(1)) && this.isHaveSupportSkills();
    }

    isSupportInPriority() {
      return this.isCanSupport() && this.supportInPriority > 0;
    }

    isHaveOnDeathAction() {
      return AA.SAaction.isProper(this.onDeath);
    }

    isHaveOnDeathVariable() {
      return this.onDeathVar > 0;
    }

  };

  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = AAAllyModelData.prototype;
    
    // * Инициализация базовых настроек
    _._initBaseParameters = function() {
      this._initAI();
      this._initMain();
      this._initMovingSettings();
      this._initOnMapSettings();
      this._initOtherSettings();
      this._initVisualSettings();
      this._initAnimationSettings();
    };
    _._initAI = function() {
      // seeEnemy - увидел врага (враг в области видимости)
      // gotDamage - получил урон
      // playerGotDamage - игрок получил урон
      // playerInDanger - игрок является целью кого-либо
      // playerAttacksSomeone - игрок нанёс урон по врагу
      // playerAction - игрок просто выполнил действие (навык или атака) (без урона даже)
      // condition - условие игрока (script)
      this.activateWhen = 'seeEnemy'; // * можно писать через | или &
      // можно исползовать a. (свой Battler) и b. (Battler игрока)
      this.extraActivateCond = ""; // * Script условие перехода в режим боя
      this.activateActionId = 0; // * Для playerAction -> 0 = любое действие игрока (X - номер навыка)
      
      // any - любой враг (случайный)
      // condition - враг, который попадает под условие (script) игрока
      // damaged - раненный враг
      // full - враг с полным здоровьем
      // playerTarget - враг, которого атаковал игрок
      // playerOpponent - враг, который атакует игрока
      // notMyOpponent - любой, кто не атакует меня
      // myOpponent - любой, кто атакует меня
      // none - не атакует никого
      this.bestTarget1 = "any"; // * можно писать any|nearest|playerTarget (много, через | или &)
      this.bestTarget2 = "";
      this.bestTarget3 = "";
      // nearest - ближний
      // further - дальний
      // weakest - слабый
      // strongest - сильный
      // lowHp - меньше всех здоровья
      // highHp - больше всех здоровья
      // nearestToPlayer - ближайший к игроку
      // furtherFromPlayer - дальше от игрока
      // * Только одно значение может быть
      this.bestTargetGroup = "";
      // можно исползовать a. (свой Battler) и b. (Battler игрока) и t. (Battler цели)
      this.extraTargetCond = ""; // * Script условие выбора цели
      // * Если нет цели, удовлетворяющей условию inBattleBestTarget, атаковать любую?
      this.bestTarRefreshTime = 60; // * Менять цель каждые Х кадров (делать проверку условия)
      this.skillsPriority = []; // * Номера навыков через запятую, от самого лучшего, до самого худшего
      
      // * Если есть лучшая цель для навыков Support, то выбираем её всегда первой
      this.supportInPriority = 0;
      // * Если пусто, то так же не поддерживает суппорт
      this.supportSkills = []; // * номера навыков через запятую
      //TODO: PARTY UPD : healInPriority
      //@healInPriority = true # * Если true, то навык, который лечит - в приоритете
      // none - не поддерживает суппорт
      // any - любой союзник
      // damaged - раненный
      // full - здоровый
      // player - игрок
      // ally - союзник
      // self - я (себя)
      // other - любой, но НЕ я
      // lowHp - мало здоровья
      // partyMember - член партии
      // condition - условие (скрипт) игрока
      // * поддерживают | и &
      this.bestHelp1 = "none";
      this.bestHelp2 = "";
      this.bestHelp3 = "";
      // можно исползовать a. (свой Battler) и b. (Battler игрока) и t. (Battler цели)
      this.helpCondition = "";
    };
    _._initMain = function() {
      this.onDeath = 0; //AScript
      this.viewRadius = 5; //@[EVal]
      // * Как далеко может от игрока отойти
      this.returnRadius = 8; //@[EVal]
      //TODO: PARTY UPD this two not used now (maybe don't need at all)
      this.noPassVisionRegions = [];
      this.noPassVisionTerrains = [];
    };
    _._initMovingSettings = function() {
      //@[EVal]
      this.noMoveInBattle = 0; // * Если 1 - не будет двигаться в бою (вообще)
      //@[EVal]
      this.noApproach = 0; // * Не преследовать цель в бою (своё движение остаётся, например Random или отступать от игрока)
      // Range (when start), Freq, Speed
      this.approachMoveData = [3, 5, 3];
      // Min dist, Freq, Speed, isRandomStep
      this.inBattleMoveData = [1, 3, 3, 0];
    };
    _._initOnMapSettings = function() {
      // * Нельзя сдвинуть импульсом
      this.heavy = 1; //@[EVal]
    };
    _._initVisualSettings = function() {
      //TODO: PARTY UPD : info??? as Enemy Info when under cursor?
      //TODO: PARTY UPD some portrait config?
      this.miniHpGaugeStyle = "";
      this.miniHPGaugeOffset = [0, 0];
    };
    _._initOtherSettings = function() {
      this.onSeeTarget = 0; //AScript
      // * При получении урона (AABS навыка от кого либо)
      this.onHit = 0; //AScript
      // * Переменная для +1 когда этот юнит погибает
      this.onDeathVar = 0;
      // * Даные действия выполняются каждую секунд (каждую секунду в битве)
      this.turnAction = 0; //AScript
      this.turnActionInBattle = 0; //AScript
      // * Когда был отброшен навыком с Impluse
      //TODO:PARTY UPD реализовать выполенние
      this.onKnocked = 0; //AScript
    };
    _._initAnimationSettings = function() {};
    _._applyParametersFromDB = function() {
      var i, len, p, params;
      params = this.actorData().AAAllyChar;
      if (params == null) {
        return;
      }
      for (i = 0, len = params.length; i < len; i++) {
        p = params[i];
        this[p[0]] = p[1];
      }
    };
    // * Преобразует некоторые параметры
    _._convertParameters = function() {
      this.supportSkills = AA.Utils.Parser.convertArrayFromParameter(this.supportSkills);
      this.skillsPriority = AA.Utils.Parser.convertArrayFromParameter(this.skillsPriority);
      this.approachMoveData = AA.Utils.Parser.convertArrayFromParameter(this.approachMoveData);
      this.inBattleMoveData = AA.Utils.Parser.convertArrayFromParameter(this.inBattleMoveData);
    };
  })();

  return AAAllyModelData;

}).call(this);

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для Action для навыков ABS

// * Большинство методов из Game_Action просто не используются
// * Вынесен в отдельный класс чтобы не мешать обычной битве
var AABattleAction;

AABattleAction = class AABattleAction extends Game_Action {
  constructor(subject, aaSkill) {
    super(subject, true);
    this.setAASkill(aaSkill);
    this._direction = subject.direction();
    return;
  }

  setAASkill(aaSkill) {
    if (aaSkill == null) {
      this.clear();
    }
    if (aaSkill.isItem()) {
      this.setItem(aaSkill.databaseId());
    } else {
      this.setSkill(aaSkill.idA);
    }
  }

  
    // * Направление навыка
  direction() {
    return this._direction;
  }

  AASkill() {
    return this.item().AASkill;
  }

  // * Данное действие принадлежит игроку?
  // * Используется чтобы не давать опыт, если врага убил другой АИ или глобал
  isPlayerActionOwner() {
    return this.isValid() && this.subject() === $gameParty.leader();
  }

  isPlayerTeamOwner() {
    return this.isPlayerActionOwner() || this.isAllyActionOwner();
  }

  isAllyActionOwner() {
    return this.isValid() && $gameParty.members().contains(this.subject());
  }

  // * Данное действие используется в PvP режиме, чтобы зарегестрировтать callback
  // * кто кого "убил"
  isNetCharActionOwner() {
    return this.isValid() && this.character() instanceof NETCharacter;
  }

  //$[OVER]
  // * canUse проверяется перед выполнением действия, поэтому тут пропускаем
  isValid() {
    return (this._packedSubject != null) && (this.item() != null) && (this.item().AASkill != null);
  }

  //$[OVER]
  // * Проверки сокращены, так как не используются стандартные настройки
  testApply(target) {
    return true;
  }

  // * Нет смысла, так как testLifeAndDeath == true всегда
  // * А проверки валидности цели идут на фильтре целей
  /*return @testLifeAndDeath() && (
      (@isHpRecover() && target.hp < target.mhp) ||
      (@isMpRecover() && target.mp < target.mmp) ||
      @hasItemAnyValidEffects(target)
  )*/
  //$[OVER]
  // * Нет необходимости в этой проверке
  testLifeAndDeath(target) {
    return true;
  }

  //$[OVER]
  setSubject(subject) {
    if (subject == null) {
      return this._packedSubject = null;
    } else {
      return this._packedSubject = AA.Utils.packAAEntity(subject);
    }
  }

  //$[OVER]
  subject() {
    var char;
    char = this.character();
    if (char != null) {
      return char.AABattler();
    }
    return null;
  }

  character() {
    return AA.Utils.unpackAAEntity(this._packedSubject);
  }

  //$[OVER]
  apply(target) {
    var b;
    b = target.AABattler();
    Game_Action.prototype.apply.call(this, b);
    b.result().setUsedAASkill(this.AASkill());
  }

  //$[OVER]
  updateLastUsed() {} // * EMPTY

  //TODO: Сохранять на Subject полседний использованный AASkill ???
  //Чтобы например он onActionOnMe использовать

    //$[OVER]
  updateLastSubject() {} // * EMPTY

  subjectTeamId() {
    var e, ref;
    try {
      return (ref = this.character()) != null ? ref.AAEntity().teamId() : void 0;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return -1;
    }
  }

};


// Generated by CoffeeScript 2.6.1
// * Класс с методами взаимодействия навыков и Entities (аналог Battle Process)

//$[ENCODE]
window.AABattleActionsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AABattleActionsManager;
  _.startAASkill = function(aaSkill, subject, targetPoint) {
    var e, i, j, ref, repeats, time;
    if (aaSkill == null) {
      return;
    }
    try {
      // * Выполняем SAction onStart
      AA.SAaction.execute(aaSkill.onStart, subject);
      if (aaSkill.isRepeatableOnUse()) {
        time = aaSkill.gRepeatDelay();
        repeats = aaSkill.gRepeatOnUse();
        for (i = j = 0, ref = repeats; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          setTimeout((function() {
            var e;
            try {
              if ((subject != null) && subject.isABS() && subject.AABattler().isAlive()) {
                return this._startAASkillDirect(aaSkill, subject, targetPoint);
              }
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }).bind(this), time * i);
        }
      } else {
        this._startAASkillDirect(...arguments);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  
  // * Старт навыка (без учёта repeatOnUse)
  _._startAASkillDirect = function(aaSkill, subject, targetPoint) {
    var direction, e, i, j, nextPoint, ref, results, target;
    try {
      if (aaSkill == null) {
        return;
      }
      if (aaSkill.isSelfAction()) {
        //"SELF ACTION".p()
        return this.applySkillAction(subject, subject, aaSkill);
      } else if (aaSkill.isInstant()) {
        //"INSTANT ACTION".p()
        // * Надо получить точку по направлению
        if (!aaSkill.isInPoint()) {
          nextPoint = subject;
          direction = subject.direction();
          results = [];
          for (i = j = 1, ref = aaSkill.gRange(); (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
            nextPoint = AA.Utils.Math.getProjectilePointByDirection(nextPoint, direction);
            target = AATargetsManager.getTargetInPoint(subject, aaSkill, nextPoint);
            if (target == null) {
              // * Если цели нет, просто передаём точку на карте (для NoContact навыков)
              target = nextPoint;
            }
            results.push(this.applySkillAction(subject, target, aaSkill));
          }
          return results;
        } else {
          return this.applySkillAction(subject, targetPoint, aaSkill);
        }
      } else {
        // * Projectiles here...
        if (aaSkill.isMultiProjectile()) {
          return this._startMultiProjectileSkill(aaSkill, subject);
        } else {
          return $gameMap.startAASkill(aaSkill, subject, targetPoint);
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._startMultiProjectileSkill = function(aaSkill, subject) {
    var dir, dirSetA, dirSetB, dirSetFinal, e, j, k, len, len1, mode, p, points, results, startPoint;
    try {
      mode = aaSkill.gMultiProjectileMode();
      dirSetA = [2, 4, 6, 8];
      dirSetB = [1, 7, 9, 3];
      dirSetFinal = [];
      if (mode === 1) {
        dirSetFinal = dirSetA;
      } else if (mode === 2) {
        dirSetFinal = dirSetB;
      } else if (mode === 3) {
        dirSetFinal = dirSetA.concat(dirSetB);
      } else if (mode === 4) {
        dirSetFinal = aaSkill.getMultiProjectileModeCustomSet();
      }
      if (aaSkill.isMultiProjectileFixed()) {
        dirSetFinal = AA.Utils.Math.rotateDirsRelativeTo(dirSetFinal, subject.direction());
      }
      startPoint = subject.toPoint();
      points = [];
      for (j = 0, len = dirSetFinal.length; j < len; j++) {
        dir = dirSetFinal[j];
        points.push(AA.Utils.Math.getProjectilePointByDirection(startPoint, dir));
      }
      results = [];
      for (k = 0, len1 = points.length; k < len1; k++) {
        p = points[k];
        results.push($gameMap.startAASkill(aaSkill, subject, p));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Выполнение действия АБС навыка на карте или Entity
  _.applySkillAction = function(subject, target, absSkill) {
    var e, i, j, ref, repeats, time;
    try {
      if (absSkill.isRepeatable()) {
        time = absSkill.gRepeatDelay();
        repeats = absSkill.gRepeat();
        for (i = j = 0, ref = repeats; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          setTimeout((function() {
            var e;
            try {
              return this._applySkillActionDirect(subject, target, absSkill);
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }).bind(this), time * i);
        }
      } else {
        this._applySkillActionDirect(...arguments);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Выполнение навыка (без учёта repeat)
  _._applySkillActionDirect = function(subject, target, absSkill) {
    var animationId, e, targets;
    try {
      animationId = this.getProperAnimationId(subject, absSkill);
      if (target instanceof Game_Character) {
        if (absSkill.animationOnMap === 0 && (target.__aaLastProjectileHitPoint == null)) {
          this.playAnimationOnCharacter(target, animationId);
        } else {
          this.playAnimationOnMapPrec(target, animationId);
        }
      } else {
        // * Если навык требует контакт, то нет никаких эффектов
        if (!absSkill.isNoContact()) {
          return;
        }
        this.playAnimationOnMapPrec(target, animationId);
      }
      if (absSkill.isHaveExtraAnimation()) {
        this.playExtraSkillAnimation(target.x, target.y, absSkill);
      }
      if (absSkill.isTeleport()) {
        this._performTeleport(target, subject, absSkill);
      }
      targets = AATargetsManager.collectTargtesForSkill(subject, absSkill, target);
      // * Фильтр целей по доп. параметрам и условием навыка
      targets = AATargetsManager.applyExtraSkillConditions(subject, targets, absSkill);
      this.performBattleAction(subject, absSkill, targets);
    } catch (error) {
      //TODO: Do Common Action (Выполнение обычных действий на событиях или персонажах)
      e = error;
      AA.w(e);
    }
  };
  //TODO: Добавить параметр Animation Scalling ??? Чтобы скалировать обычную анимацию на карте и не переделывать каждую

  // * Анимация с учётом оружия
  _.getProperAnimationId = function(subject, absSkill) {
    var animationId, e;
    try {
      animationId = absSkill.animationId();
      if (animationId === -1) { // * Normal attack
        return subject.AABattler().attackAnimationId1();
      }
      //TODO: attackAnimationId2 if dual weild
      return animationId;
    } catch (error) {
      e = error;
      AA.w(e);
      return 0;
    }
  };
  //TODO: [Идея] Проигрывание анимации на всём экране или в координатах экрана

  // * Воспроизвести анимацию на персонаже
  _.playAnimationOnCharacter = function(char, animationId) {
    var e;
    try {
      if ((animationId != null) && animationId > 0) {
        AANetworkManager.playAnimationOnCharacter(char, animationId);
        $gameTemp.requestAnimation([char], animationId, false);
      }
    } catch (error) {
      e = error;
      KDCore.warning("playAnimationOnCharacter", e);
    }
  };
  // * Дополнительный метод, чтобы извлеч доп. координаты экрана (для более точной анимации)
  _.playAnimationOnMapPrec = function(target, animationId) {
    var e, sx, sy, x, y;
    try {
      if (target == null) {
        return;
      }
      sx = null;
      sy = null;
      if (target.__aaLastProjectileHitPoint != null) {
        sx = target.__aaLastProjectileHitPoint.x;
        sy = target.__aaLastProjectileHitPoint.y;
      }
      ({x, y} = target);
      this.playAnimationOnMap(x, y, animationId, sx, sy);
      return target.__aaLastProjectileHitPoint = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Воспроизвести анимацию в точке на карте
  _.playAnimationOnMap = function(x, y, animationId, sx, sy) {
    var e;
    if (!KDCore.Utils.isSceneMap()) {
      return;
    }
    try {
      if ((animationId != null) && animationId > 0) {
        AANetworkManager.playAnimationOnMap(x, y, animationId, sx, sy);
        $gameMap.aaRequestMapAnimation(x, y, animationId, sx, sy);
      }
    } catch (error) {
      e = error;
      KDCore.warning("playAnimationOnMap", e);
    }
  };
  // * Воспоизвести доп. анимацию (изображение)
  _.playExtraSkillAnimation = function(x, y, extraAnimationData) {
    var e, extraAnimation, extraAnimationOX, extraAnimationOY, extraAnimationSE;
    try {
      ({extraAnimation, extraAnimationOX, extraAnimationOY, extraAnimationSE} = extraAnimationData);
      uAPI.playExtraAnimation(x, y, extraAnimation, extraAnimationSE, extraAnimationOX, extraAnimationOY);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  // * ======================================================================
  // * BATTLE ACTION LOGIC

  // * subject и target - это characters, не battlers
  _.performBattleAction = function(subject, skill, targets) {
    var action, e;
    //"PERFORM BATTLE ACTION".p()
    //"SUB".p()
    //console.info(subject)
    //"SKILL".p()
    //console.info(skill)
    //"TARG".p()
    //console.info(targets)
    if (subject == null) {
      return;
    }
    if (skill == null) {
      return;
    }
    try {
      action = new AABattleAction(subject, skill);
      if (!action.isValid()) {
        return;
      }
      this._startAction(action, targets);
      this._endAction(action);
      this._onSkillPerformed(skill, subject);
    } catch (error) {
      e = error;
      KDCore.warning("performBattleAction", e);
    }
  };
  _._startAction = function(action, targets) {
    var e, j, len, t;
    try {
      // * Вызов общих событий навыка (предмета)
      //TODO: Вызов общих событий AASkill ???
      action.applyGlobal();
      for (j = 0, len = targets.length; j < len; j++) {
        t = targets[j];
        this._invokeAction(t, action);
      }
    } catch (error) {
      e = error;
      KDCore.warning("_startAction", e);
    }
  };
  _._invokeAction = function(target, action) {
    var e;
    try {
      //TODO: Возможно Drain с текущим алгоритмом работать не будут
      // * Сейчас каждый игрок отправляет свой Observer, т.е. нельзя
      // * изменить значение HP персонажа на другом клиенте, надо
      // * вызывать метод, который меняет на текущем клиенте (собственнике персонажа)
      if (AA.Network.isNetworkGame()) {
        if (target instanceof Game_Event) {
          if (ANGameManager.isMapMaster()) {
            this._applyActionOnTarget(target, action);
          } else {
            AANetworkManager.applyActionOnTarget(target, action);
          }
        } else if (target instanceof NETCharacter) {
          AANetworkManager.applyActionOnTarget(target, action); // * Game_Player (SELF)
        } else {
          this._applyActionOnTarget(target, action);
        }
      } else {
        this._applyActionOnTarget(target, action);
      }
    } catch (error) {
      e = error;
      KDCore.warning("_invokeAction", e);
    }
  };
  _._applyActionOnTarget = function(target, action) {
    var e;
    try {
      if (action == null) {
        return;
      }
      if (target == null) {
        return;
      }
      if (target.aaIsInvincible()) {
        return;
      }
      action.apply(target);
      this._onActionResult(target, action);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._onActionResult = function(target, action) {
    var battler, e, skill;
    try {
      battler = target.AABattler();
      if (!battler.result().used) {
        return;
      }
      this._performActionResultOnTarget(target);
      battler.startDamagePopup();
      action.subject().startDamagePopup();
      target.aaOnActionOnMe(action);
      // * Сохраняем данные для uAPI
      $gameTemp.aaLastUsedAction = action;
      $gameTemp.aaLastUsedActionTarget = target;
      skill = action.AASkill();
      try {
        AA.SAaction.execute(skill.onHit, target);
      } catch (error) {
        e = error;
        KDCore.warning("skill: onHit Script Action issue", e);
      }
      try {
        if (skill.isExplosive()) {
          this._performSkillExplosion(skill, target, action);
        }
        if (skill.isHaveImpulsePower()) {
          this._performSkillImpulse(skill, target, action);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    } catch (error) {
      e = error;
      KDCore.warning("_onActionResult", e);
    }
  };
  _._performSkillExplosion = function(skill, target, action) {
    var candidats, e, explSkillId, r, targets, userTeamId;
    try {
      // Get targets in Raidus
      userTeamId = action.subjectTeamId();
      r = skill.getExplosiveRadius();
      candidats = AATargetsManager.getAAEntitiesSetDependsSkill(userTeamId, skill);
      targets = AATargetsManager.getFilteredInRadius(target, r, candidats);
      // * Remove initial target (it's damaged by skill itself)
      targets.delete(target);
      if (skill.isValidExplosiveSkill()) {
        explSkillId = skill.getExplosiveDmgSkillId();
        //TODO: Diffirent directions 8 projectiles (not need targets)
        if ((targets != null) && targets.length > 0) {
          return this._performMultiDamageAASkillOnTargets(skill, action, target, targets);
        }
      } else {
        // * Get current skill damage, apply koef and damage near targets
        if ((targets != null) && targets.length > 0) {
          return this._performMultiDamageSimpleActionsOnTargets(skill, action, targets);
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._performMultiDamageSimpleActionsOnTargets = function(skill, action, targets = []) {
    var b, damageValue, e, j, len, results, t;
    try {
      if (skill == null) {
        return;
      }
      if (action == null) {
        return;
      }
      results = [];
      for (j = 0, len = targets.length; j < len; j++) {
        t = targets[j];
        b = t.AABattler();
        if (b == null) {
          continue;
        }
        try {
          damageValue = action.makeDamageValue(b, false);
          damageValue *= skill.getExplosiveDmgKoef();
          results.push(b.aaGainHpWithPopUp(damageValue * -1, false));
        } catch (error) {
          e = error;
          results.push(KDCore.warning(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._performMultiDamageAASkillOnTargets = function(skill, action, {x, y}, targets = []) {
    var e, j, len, ownerId, results, skillToPerform, subject, t;
    try {
      if (skill == null) {
        return;
      }
      if (action == null) {
        return;
      }
      skillToPerform = $dataSkills[skill.getExplosiveDmgSkillId()];
      if (skillToPerform == null) {
        return;
      }
      if (skillToPerform.AASkill == null) {
        return;
      }
      ownerId = action.subjectTeamId();
      subject = AA.Utils.createDummyCharacterByParameters(ownerId, ownerId, x, y);
      results = [];
      for (j = 0, len = targets.length; j < len; j++) {
        t = targets[j];
        if (t == null) {
          continue;
        }
        try {
          results.push(AABattleActionsManager.startAASkill(skillToPerform.AASkill, subject, t));
        } catch (error) {
          e = error;
          results.push(KDCore.warning(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._performSkillImpulse = function(skill, target, action) {
    var d, e, impulseVal;
    try {
      impulseVal = skill.getImpulsePower();
      if (impulseVal > 0 && target.aaIsCanMoveByImpulse()) {
        if (skill.isRandomImpulseDirection()) {
          d = 0; // * Random
        } else {
          if (skill.isAroundUser()) {
            d = 100;
            $gameTemp._aaImpuleAwayFrom = action.subject().AACharacter();
          } else {
            d = action.direction();
          }
        }
        target.aaApplyImpulse(impulseVal, d, skill.isJumpImpulseType(), skill.isReversedImpulseType());
        return $gameTemp._aaImpuleAwayFrom = null;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Звуковые и визуальные эффекты после действия (на цели)
  _._performActionResultOnTarget = function(target) {
    var battler, e, result;
    try {
      battler = target.AABattler();
      result = battler.result();
      // * MISS
      if (result.missed) {
        battler.performMiss();
      // * EVADE
      } else if (result.evaded) {
        if (result.physical) {
          battler.performEvasion();
        } else {
          battler.performMagicEvasion(); // * DAMAGE
        }
      } else {
        // * HP
        if (result.hpAffected) {
          if (result.hpDamage > 0 && !result.drain) {
            battler.performDamage();
          }
          if (result.hpDamage < 0) {
            battler.performRecovery();
          }
        }
        // * MP and TP
        if (battler.isAlive() && (result.mpDamage !== 0 || result.tpDamage !== 0)) {
          if (result.mpDamage < 0 || result.tpDamage < 0) {
            battler.performRecovery();
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning("_actionResultOnDamage", e);
    }
  };
  //TODO: Надо каждую секунду вызывать battler.onTurnEnd ???
  _._endAction = function(action) {
    var battler, e;
    try {
      battler = action.subject();
      if (battler != null) {
        battler.onAAActionComplete();
      }
    } catch (error) {
      e = error;
      KDCore.warning("_endAction", e);
    }
  };
  // * Когда навык выполнил своё действие (конец)
  _._onSkillPerformed = function(skill, subject) {
    var dbItem, e, skillId;
    try {
      if (skill == null) {
        return;
      }
      try {
        // * Выполняем SAction onDone
        AA.SAaction.execute(skill.onDone, subject);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      // * (Снимаем Skill Extension, если он был)
      dbItem = skill.dbItem();
      if (dbItem.__aaDefCopy == null) {
        return;
      }
      skillId = skill.databaseId();
      $dataSkills[skillId].AASkill = $dataSkills[skillId].__aaDefCopy;
      return $dataSkills[skillId].__aaDefCopy = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._performTeleport = function(point, char, skill) {
    var e;
    try {
      if (point == null) {
        return;
      }
      if (char == null) {
        return;
      }
      if (skill == null) {
        return;
      }
      return char.aaTeleport(point, skill.teleportInAnim, skill.teleportOutAnim);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// https://github.com/jriecken/sat-js
var AACollider;

AACollider = class AACollider {
  constructor(type, config1) {
    this.type = type;
    this.config = config1;
    this._lastResponse = null;
    this.dx = this.config.dx || 0;
    this.dy = this.config.dy || 0;
    this._create();
    return;
  }

  static DefaultConfig(flag = 'char') {
    return {
      type: 'b',
      flag,
      dx: 0,
      dy: 0,
      width: 48,
      height: 48,
      radius: 0
    };
  }

  static FromConfig(config) {
    var col, e;
    try {
      if (config == null) {
        return null;
      }
      col = new AACollider(config.type, config);
      col.flag = config.flag;
      return col;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  isCircle() {
    return this.type === 'c' || this.type === 'circle';
  }

  isBox() {
    return !this.isCircle();
  }

  isValid() {
    return this.colliderObj != null;
  }

  isHavePoint(x, y) {
    var e;
    try {
      if (!this.isValid()) {
        return false;
      }
      if (this.isCircle()) {
        return SAT.pointInCircle(new SAT.Vector(x, y), this.colliderObj);
      } else {
        return SAT.pointInPolygon(new SAT.Vector(x, y), this.colliderObj);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  }

  isInCollider(collider) {
    var e;
    try {
      this._lastResponse = null;
      if (this.isCollideWith(collider)) {
        if ((this._lastResponse != null) && (this._lastResponse.aInB === true || this._lastResponse.bInA === true)) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  }

  isCollideWith(collider) {
    var e;
    try {
      if (collider == null) {
        return false;
      }
      if (!this.isValid()) {
        return false;
      }
      if (!collider.isValid()) {
        return false;
      }
      if (this.isCircle() && collider.isCircle()) {
        return SAT.testCircleCircle(this.colliderObj, collider.colliderObj, this._lastResponse);
      }
      if (this.isCircle() && collider.isBox()) {
        return SAT.testCirclePolygon(this.colliderObj, collider.colliderObj, this._lastResponse);
      }
      if (this.isBox() && collider.isBox()) {
        return SAT.testPolygonPolygon(this.colliderObj, collider.colliderObj, this._lastResponse);
      }
      if (this.isBox() && collider.isCircle()) {
        return SAT.testPolygonCircle(this.colliderObj, collider.colliderObj, this._lastResponse);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  }

  refreshPositionForChar(char) {
    var e;
    try {
      if (!this.isValid()) {
        return;
      }
      if (char == null) {
        return;
      }
      if (this.isBox()) {
        this.colliderObj.pos.x = char.screenX() - (this.config.width / 2) + this.dx;
        return this.colliderObj.pos.y = char.screenY() - this.config.height + this.dy;
      } else {
        this.colliderObj.pos.x = char.screenX() + this.dx;
        return this.colliderObj.pos.y = char.screenY() + this.dy - ($gameMap.tileHeight() / 2);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  setScreenCharPosition(x = 0, y = 0) {
    var char, e, p, sx, sy;
    try {
      if (!this.isValid()) {
        return;
      }
      p = new KDCore.Point(x, y);
      p = p.convertToScreen();
      sx = p.x;
      sy = p.y;
      char = {
        screenX: function() {
          return sx;
        },
        screenY: function() {
          return sy;
        }
      };
      return this.refreshPositionForChar(char);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  setPositionXY(x, y, isStrict = false) {
    var e;
    try {
      if (!this.isValid()) {
        return;
      }
      if (isStrict === true) {
        this.colliderObj.pos.x = x;
        return this.colliderObj.pos.y = y;
      } else {
        this.colliderObj.pos.x = x + this.dx;
        return this.colliderObj.pos.y = y + this.dy;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  addPositionXY(x, y) {
    var e;
    try {
      this.colliderObj.pos.x += x;
      return this.colliderObj.pos.y += y;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  x() {
    return this.colliderObj.pos.x;
  }

  y() {
    return this.colliderObj.pos.y;
  }

  px() {
    var e, x;
    try {
      if (!this.isValid()) {
        return 0;
      }
      x = this.colliderObj.pos.x;
      if (this.isCircle()) {
        x -= this.config.radius;
      }
      return x;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  py() {
    var e, y;
    try {
      if (!this.isValid()) {
        return 0;
      }
      y = this.colliderObj.pos.y;
      if (this.isCircle()) {
        y -= this.config.radius;
      }
      return y;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  _create() {
    var e, height, radius, width;
    try {
      if (this.isCircle()) {
        ({radius} = this.config);
        this.colliderObj = new SAT.Circle(new SAT.Vector(0, 0), radius);
      } else {
        ({width, height} = this.config);
        this.colliderObj = new SAT.Box(new SAT.Vector(0, 0), width, height).toPolygon();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.colliderObj = null; // * Not valid
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ COMMON.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Utils;
  (function() {    // * Общее
    // -----------------------------------------------------------------------
    //TODO: Кое-что в KDCore перенести (дублировать)
    _.isValidCE = function(commonEventId) {
      return commonEventId > 0 && ($dataCommonEvents[commonEventId] != null);
    };
    _.startCE = function(commonEventId) {
      if (this.isValidCE(commonEventId)) {
        return $gameTemp.reserveCommonEvent(commonEventId);
      }
    };
    _.checkSwitch = function(value) {
      if (isFinite(value)) {
        return false;
      }
      return KDCore.SDK.checkSwitch(value);
    };
    _.isSamePointA = function(point1, point2) {
      return point1[0] === point2[0] && point1[1] === point2[1];
    };
    // * Является ли символ кнопкой панели навыков
    _.isSkillPanelSymbol = function(symbol) {
      var symbols;
      if (!String.any(symbol)) {
        return false;
      }
      symbols = AA.Input.skillPanelSymbols;
      return symbols.contains(symbol);
    };
    // * Получить значение опыта с врага (с учётом специальной переменной для опыта)
    _.getExpFromAAEnemy = function(enemyDbData) {
      var e, expVarId, param;
      try {
        if (enemyDbData == null) {
          return 0;
        }
        if (enemyDbData.AAEnemy != null) {
          param = enemyDbData.AAEnemy.find(function(p) {
            return p[0] === 'expVar';
          });
          if (param != null) {
            expVarId = parseInt(param[1]);
            if ((expVarId != null) && expVarId > 0) {
              return $gameVariables.value(expVarId);
            }
          }
        }
        return enemyDbData.exp;
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    // * Вызвать с задержкой в time миллисекунд
    // * Не забываем про bind
    _.callDelayed = function(method, time = 1) {
      var e;
      try {
        if (method == null) {
          return;
        }
        setTimeout((function() {
          return method();
        }), time);
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    _.isValidGlobalSkillForExecute = function(skillId, type) {
      var aaSkill, e;
      try {
        if (!AA.isABSActive()) {
          return false;
        }
        skillId = KDCore.Utils.getEValue(skillId);
        if ($dataSkills[skillId] == null) {
          AA.w("Global Skill execution: Skill with ID " + skillId + " not found");
          return false;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          AA.w("Global Skill execution: Skill with ID " + skillId + " is not ABS skill");
          return false;
        }
        switch (type) {
          case "OnMap":
            if (aaSkill.isInstant()) {
              return true;
            } else {
              AA.w("uAPI.executeAASkillOnMap: for projectile ABS skills use uAPI.executeAASkillOnMapProjFromPoint");
              return false;
            }
            break;
          case "ByDirection":
            if (!aaSkill.isInstant()) {
              return true;
            } else {
              AA.w("uAPI.executeAASkillOnMapProjFromPoint: for instant ABS skills use uAPI.executeAASkillOnMap");
              return false;
            }
            break;
          default:
            return false;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
    _.createDummyCharacterByParameters = function(ownerId, teamId, x, y, d) {
      var e, subject;
      try {
        ownerId = KDCore.Utils.getEValue(ownerId);
        x = KDCore.Utils.getEValue(x);
        y = KDCore.Utils.getEValue(y);
        if (ownerId > 0) { // * Game Event ID, but we need battler
          try {
            ownerId = $gameMap.event(ownerId).AABattler().enemyId();
          } catch (error) {
            e = error;
            KDCore.warning(e);
            ownerId = 1;
          }
        }
        subject = new AADummyCharacter(ownerId, teamId);
        try {
          if ((x != null) && (y != null)) {
            x = KDCore.Utils.getEValue(x);
            y = KDCore.Utils.getEValue(y);
            subject.setPosition(x, y);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        try {
          if (d != null) {
            d = KDCore.Utils.getEValue(d);
            subject.setDirection(d);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return subject;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    return _.compareArraysForDiff = function(source, reflector) {
      var e, i, item, j, len, len1, result;
      try {
        result = {
          added: [],
          removed: []
        };
        for (i = 0, len = source.length; i < len; i++) {
          item = source[i];
          if (!reflector.contains(item)) {
            result.added.push(item);
          }
        }
        for (j = 0, len1 = reflector.length; j < len1; j++) {
          item = reflector[j];
          if (!source.contains(item)) {
            result.removed.push(item);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return result;
    };
  })();
  (function() {    // * Навыки и предметы
    // -----------------------------------------------------------------------
    // * В ABS Z предметы и навыки имеют свои уникальные ID (поле idA)
    // * Это сделано так как предметы имели одинаковые ID что и навыки и было не удобно их различать
    // * Теперь предметы имеют idA = id + это значение
    _.ItemsIDStart = 9000;
    // * Навык (или предмет) имеют AASkill данные в себе
    _.isAAObject = function(skillIdOrObject) {
      if (skillIdOrObject == null) {
        return false;
      }
      if (isFinite(skillIdOrObject)) {
        if (skillIdOrObject <= 0) {
          return false;
        }
        skillIdOrObject = this.getAASkillObject(skillIdOrObject);
      }
      return skillIdOrObject.AASkill != null;
    };
    _.isAASkill = function(skillId) {
      return skillId <= this.ItemsIDStart;
    };
    _.isAAItem = function(skillId) {
      return skillId > this.ItemsIDStart;
    };
    _.getAASkillObject = function(skillId) {
      if (skillId <= 0) {
        return null;
      }
      if (this.isAAItem(skillId)) {
        return $dataItems[skillId - this.ItemsIDStart];
      } else {
        return $dataSkills[skillId];
      }
    };
    _.isAAState = function(stateIdOrObject) {
      var obj;
      if (stateIdOrObject == null) {
        return false;
      }
      if (isFinite(stateIdOrObject)) {
        obj = this.getAAStateObject(stateIdOrObject);
      } else {
        obj = stateIdOrObject;
      }
      if (obj != null) {
        return obj.AAState != null;
      } else {
        return false;
      }
    };
    _.getAAStateObject = function(stateId) {
      if (stateId <= 0) {
        return null;
      }
      return $dataStates[stateId];
    };
    // * Получить иконку оружия навыка атаки (или иконку навыка атаки, если нет оружия)
    _.getAttackSkillWeaponIconIndex = function(skill, battler) {
      var e, weapon;
      try {
        weapon = battler.weapons()[0];
        if ((weapon != null) && weapon.iconIndex > 0) {
          return this.getSkillSlotImgOrIcon(weapon); //.iconIndex
        } else {
          return this.getSkillSlotImgOrIcon(skill); //.iconIndex
        }
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    // * Получить иконку или картинку для слота навыка
    // * Возвращает либо имя картинки, либо номер иконки
    _.getSkillSlotImgOrIcon = function(dataItem) {
      var e;
      try {
        if (dataItem == null) {
          return 0;
        }
        if (this.isAAObject(dataItem) && String.any(dataItem.AASkill.ssImg)) {
          return dataItem.AASkill.ssImg;
        } else if ((dataItem.meta != null) && String.any(dataItem.meta.ssImg)) {
          return dataItem.meta.ssImg;
        }
        return dataItem.iconIndex;
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    // * Расчитать EVal для АБС параметра (безопасно,  в  случае чего возвращает стандартное  знчение)
    _.getSafeEValue = function(paramValue, defValue = 0) {
      var e, value;
      try {
        value = KDCore.Utils.getEValue(paramValue);
        if (value == null) {
          // * Не может быть null, а если может, указать через def
          value = defValue;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        value = defValue;
      }
      return value;
    };
    return _.isAnyItemHaveNotetag = function(items, notetag) {
      var e, i, item, len;
      try {
        if (items == null) {
          return false;
        }
        if (items.length === 0) {
          return false;
        }
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          if (item == null) {
            continue;
          }
          if (item.meta == null) {
            continue;
          }
          if (item.meta[notetag] != null) {
            return true;
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
  })();
  (function() {    // * Методы распаковки и запаковки данных для хранения и сохранения игры
    // -----------------------------------------------------------------------
    _.unpackAASkill = function(idA) {
      var object;
      object = this.getAASkillObject(idA);
      if (object != null) {
        return object.AASkill;
      } else {
        return null;
      }
    };
    _.packAAPoint = function(point) {
      var x, y;
      if (point instanceof Game_Character) {
        return this.packAAEntity(point);
      } else {
        x = point.x;
        y = point.y;
        return {x, y};
      }
    };
    _.unpackAAPoint = function(data) {
      if (data.x != null) {
        return new KDCore.Point(data.x, data.y);
      } else {
        return this.unpackAAEntity(data);
      }
    };
    _.packAAEntity = function(entity) {
      if (entity == null) {
        return null;
      }
      if (entity instanceof AADummyCharacter) {
        return {
          type: 1000,
          id: entity.uId
        };
      }
      // * Для сетевой игры отдельный метод с учётом NetCharacter
      if (AA.Network.isNetworkGame()) {
        return AA.Network.packMapChar(entity);
      } else {
        if (entity === $gamePlayer) {
          return {
            type: 0
          };
        } else if (entity instanceof Game_Event) {
          return {
            type: 1,
            id: entity.eventId(),
            mapId: $gameMap.mapId()
          };
        // * PARTY MEMBER
        } else if (entity instanceof Game_Follower) {
          return {
            type: 2,
            id: entity.actorId()
          };
        }
      }
      return null;
    };
    return _.unpackAAEntity = function(data) {
      if (data == null) {
        return null;
      }
      if (data.type === 1000) {
        return $gameMap.aaGetGlobalSkill(data.id);
      }
      // * Для сетевой игры отдельный метод с учётом NetCharacter
      if (AA.Network.isNetworkGame()) {
        return AA.Network.unpackMapChar(data);
      } else {
        switch (data.type) {
          case 0:
            return $gamePlayer;
          case 1:
            if ($gameMap.mapId() === data.mapId) {
              return $gameMap.event(data.id);
            } else {
              return null;
            }
            break;
          case 2:
            return $gamePlayer.followers().aaGetFollowerByActorId(data.id);
        }
      }
      return null;
    };
  })();
  (function() {    // * Работа с изображениями (кастомными анимациями)
    // -----------------------------------------------------------------------
    return _.getFramesAndSpeed = function(imageName) {
      var e, items, result;
      result = {
        f: 1,
        s: 1
      };
      if (!String.any(imageName)) {
        return result;
      }
      try {
        items = imageName.match(/\((.*)\)/i);
        if (items != null) {
          items = items[1].split(',');
          result.f = Number(items[0]);
          result.s = Number(items[1]);
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return result;
    };
  })();
  (function() {    // * Конвертирование направлений
    // -----------------------------------------------------------------------
    _.get8Dir = function(d) {
      switch (d) {
        case 1:
          return [4, 2];
        case 3:
          return [6, 2];
        case 7:
          return [4, 8];
        case 9:
          return [6, 8];
        default:
          return [0, 0];
      }
    };
    return _.get4Dir = function(horz, vert) {
      if (horz === 4 && vert === 2) {
        return 1;
      }
      if (horz === 6 && vert === 2) {
        return 3;
      }
      if (horz === 4 && vert === 8) {
        return 7;
      }
      if (horz === 6 && vert === 8) {
        return 9;
      }
      return 0;
    };
  })();
  (function() {    // * Обработка коллизий
    // -----------------------------------------------------------------------
    //aCollider:c,0,0,30
    //aCollider:b,0,0,42,42
    return _.parseColliderConfig = function(config, flag = 'char') {
      var e, parameters, type;
      try {
        if (config.contains('aCollider:')) {
          config = config.split(":")[1];
        }
        parameters = config.split(',');
        type = parameters[0];
        if (!['c', 'b'].contains(type)) {
          return null;
        }
        config = {
          type,
          flag,
          dx: Number(parameters[1] || "0"),
          dy: Number(parameters[2] || "0")
        };
        if (type === 'c') {
          config.radius = Number(parameters[3] || "20");
        } else if (type === 'b') {
          config.width = Number(parameters[3] || "48");
          config.height = Number(parameters[4] || "48");
        }
        return config;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
  })();
})();

// ■ END COMMON.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AACustomGauge;

AACustomGauge = class AACustomGauge {
  constructor(varId, gaugeParams) {
    this.varId = varId;
    this.gaugeParams = gaugeParams;
    this.id = "gauge_" + this.varId + "_" + KDCore.makeid(6);
    this.bindedTo = -1;
    this.x = 0;
    this.y = 0;
    this.mapId = $gameMap.mapId();
    this._isDisposed = false;
    return;
  }

  setGlobal() {
    return this.mapId = 0;
  }

  setEnemyEventId(enemyEvId) {
    this.enemyEvId = enemyEvId;
  }

  isEnemyHpGauge() {
    return this.enemyEvId > 0;
  }

  isDisposed() {
    return this._isDisposed === true;
  }

  disposeGauge() {
    return this._isDisposed = true;
  }

  isEnemyValid() {
    var e, event;
    try {
      if (!this.isEnemyHpGauge()) {
        return false;
      }
      event = $gameMap.event(this.enemyEvId);
      if (event == null) {
        return false;
      }
      if (!event.isABS()) {
        return false;
      }
      if (event.AABattler() == null) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
    return true;
  }

  getCurrentRate() {
    var e, event;
    try {
      if (this.isEnemyHpGauge()) {
        event = $gameMap.event(this.enemyEvId);
        if (event == null) {
          return 0;
        }
        if (!event.isABS()) {
          return 0;
        }
        if (event.AABattler() == null) {
          return 0;
        }
        return event.AABattler().hpRate();
      } else {
        return $gameVariables.value(this.varId) / 100.0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  getCurrentValue() {
    var e;
    try {
      if (this.isEnemyHpGauge()) {
        if (this.isEnemyValid()) {
          return $gameMap.event(this.enemyEvId).AABattler().hp;
        } else {
          return 0;
        }
      } else {
        return $gameVariables.value(this.varId);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  getMaxValue() {
    var e;
    try {
      if (this.isEnemyHpGauge()) {
        if (this.isEnemyValid()) {
          return $gameMap.event(this.enemyEvId).AABattler().mhp;
        } else {
          return 0;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 100; // * If variable, always 100 is max
  }

  bindedEvent() {
    if (this.bindedTo > 0) {
      return $gameMap.event(this.bindedTo);
    } else if (this.bindedTo === 0) {
      return $gamePlayer;
    } else {
      return null;
    }
  }

  bindToEvent(bindedTo) {
    this.bindedTo = bindedTo;
  }

  bindToPlayer() {
    return this.bindedEvent(0);
  }

  getScreenPos() {
    var bindedEvent;
    bindedEvent = this.bindedEvent();
    if (bindedEvent != null) {
      return {
        x: bindedEvent.screenX() + this.x,
        y: bindedEvent.screenY() + this.y
      };
    } else {
      return {
        x: this.x,
        y: this.y
      };
    }
  }

};


// Generated by CoffeeScript 2.6.1
var AACustomGaugesSystem;

AACustomGaugesSystem = class AACustomGaugesSystem {
  constructor() {
    this.gauges = [];
    $gameTemp._aaGaugeSprites = [];
    return;
  }

  static Instance() {
    return $gameSystem.aaGetCustomGaugesSystem();
  }

  getGaugeDataById(gaugeId) {
    return this.gauges.find(function(g) {
      return g.id === gaugeId;
    });
  }

  getGaugeDataByVarId(varId) {
    return this.gauges.find(function(g) {
      return g.varId === varId;
    });
  }

  getGaugeDataByEnemyId(enemyEvId) {
    return this.gauges.find(function(g) {
      return g.enemyEvId = enemyEvId;
    });
  }

  getGlobalGauges() {
    return this.gauges.filter(function(g) {
      return g.mapId === 0;
    });
  }

  getCurrentMapGauges() {
    return this.gauges.filter(function(g) {
      return g.mapId === $gameMap.mapId();
    });
  }

  isExistsGaugeForVariable(varId) {
    return this.getGaugeDataByVarId(varId) != null;
  }

  static test() {
    return AACustomGaugesSystem.Instance().addGauge(1, AA.PP.getCustomGauges()[0], 0, 0, 15, 0, false);
  }

  addGauge(variableId, parameters, x, y, bindedEventId, bindedEnemy, isGlobal) {
    var e, gauge;
    try {
      gauge = new AACustomGauge(variableId, parameters);
      gauge.x = x;
      gauge.y = y;
      if (bindedEnemy != null) {
        gauge.setEnemyEventId(bindedEnemy);
      }
      if (bindedEventId != null) {
        gauge.bindToEvent(bindedEventId);
      }
      if (isGlobal) {
        gauge.setGlobal();
      }
      this.gauges.push(gauge);
      return this._addGaugeToScene(gauge.id);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGauge(gaugeId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataById(gaugeId);
      if (gauge == null) {
        return;
      }
      gauge.disposeGauge();
      return this.gauges.delete(gauge);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGaugeByVarId(variableId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataByVarId(variableId);
      if (gauge != null) {
        return this.removeGauge(gauge.id);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGaugeByEnemyId(enemyId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataByEnemyId(enemyId);
      if (gauge != null) {
        return this.removeGauge(gauge.id);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  onMapLoaded() {
    var e, gauge, i, j, len, len1, ref, ref1, results;
    try {
      $gameTemp._aaGaugeSprites = [];
      ref = this.getGlobalGauges();
      for (i = 0, len = ref.length; i < len; i++) {
        gauge = ref[i];
        this._addGaugeToScene(gauge.id);
      }
      ref1 = this.getCurrentMapGauges();
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        gauge = ref1[j];
        results.push(this._addGaugeToScene(gauge.id));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  onBeforeMapStopped() {
    var e, i, len, ref, results, spr;
    try {
      if ($gameTemp._aaGaugeSprites == null) {
        return;
      }
      ref = $gameTemp._aaGaugeSprites;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        spr = ref[i];
        if (spr != null) {
          results.push(spr.visible = false);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _addGaugeToScene(gaugeId) {
    var e, gauge, gaugeSpr;
    try {
      gauge = this.getGaugeDataById(gaugeId);
      if (gauge == null) {
        return;
      }
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      gaugeSpr = new Sprite_AACustomGauge(gaugeId);
      SceneManager._scene.addChild(gaugeSpr);
      return $gameTemp._aaGaugeSprites.push(gaugeSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
// * Методы формирования Damage PopUp на персонаже
var AADamagePopUpFactory;

AADamagePopUpFactory = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AADamagePopUpFactory;
  _.createExpPopUpData = function(value, charToShowAbove) {
    var e, settings, valueText;
    try {
      valueText = AA.PP.getExpPopUpSettings().textFormat.replace("%1", value);
      settings = AA.PP.getExpPopUpSettings().styleId;
      return this._createFromSettings(settings, valueText);
    } catch (error) {
      e = error;
      AA.w(e);
      return null;
    }
  };
  _.createGoldPopUpData = function(value, charToShowAbove) {
    var e, settings, sign, textFormat, valueText;
    try {
      textFormat = AA.PP.getGoldPopUpSettings().textFormat;
      valueText = textFormat.replace("%1", value);
      if (value >= 0) {
        sign = "+";
      } else {
        sign = "-";
        // * Отрицательное число уже несёт в себе знак -, мы его удаляем
        valueText = valueText.replace("-", "");
      }
      valueText = valueText.replace("%2", sign);
      settings = "gold"; // * Зарезервированный стиль
      return this._createFromSettings(settings, valueText);
    } catch (error) {
      e = error;
      AA.w(e);
      return null;
    }
  };
  _.createDamagePopUpData = function(battler) {
    var result;
    if (!AA.PP.isPopUpIsActive()) {
      // * Если отключены, то ничего не возвращяем
      return null;
    }
    result = battler.result();
    if (result.missed || result.evaded) {
      return this._createMiss();
    } else if (result.hpAffected) {
      return this._createHpDamage(result, battler.isEnemy());
    } else if (battler.isAlive() && result.mpDamage !== 0) {
      return this._createMpDamage(result);
    }
    return null; // * Нет ничего
  };
  _._createMiss = function() {
    return this._createFromSettings("Miss_For_All", AA.PP.getTextForPopUpMiss());
  };
  _._createFromSettings = function(styleId, value) {
    return {
      settings: AA.PP.getPopUpDamageSettings(styleId),
      value: value
    };
  };
  _._createHpDamage = function(result, isEnemy) {
    var isHeal, styleId, value;
    isHeal = result.hpDamage < 0;
    value = this._convertValue(result.hpDamage);
    if (this._isHaveSpecialStyle(result)) {
      return this._createFromSettings(result.getUsedAASkill().popUpStyleId, value);
    } else {
      if (isHeal === true) {
        return this._createFromSettings("Heal_For_All", value);
      } else {
        if (isEnemy) {
          styleId = "Damage_HP_For_Enemy";
        } else {
          styleId = "Damage_HP_For_Player";
        }
        if (result.critical) {
          styleId += "_Critical";
        }
        return this._createFromSettings(styleId, value);
      }
    }
  };
  _._createMpDamage = function(result) {
    var isHeal, value;
    isHeal = result.mpDamage < 0;
    value = this._convertValue(result.mpDamage);
    if (this._isHaveSpecialStyle(result)) {
      return this._createFromSettings(result.getUsedAASkill().popUpStyleId, value);
    } else {
      return this._createFromSettings("Damage_Other_For_All", value);
    }
  };
  // * Чтобы лечение было с +
  _._convertValue = function(value) {
    if (value >= 0) {
      return value;
    }
    value *= -1;
    return "+" + value;
  };
  // * Есть ли у навыка специальный пользовательский стиль урона?
  _._isHaveSpecialStyle = function(result) {
    var aaSkill;
    aaSkill = result.getUsedAASkill();
    return (aaSkill != null) && String.any(aaSkill.popUpStyleId);
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Данный класс используется для глобального вызова навыков на карте
var AADummyEntity;

AADummyEntity = class AADummyEntity extends AAEntity {
  constructor(ownerId, _teamId, _uId) {
    super();
    this.ownerId = ownerId;
    this._teamId = _teamId;
    this._uId = _uId;
    this.initABS(); // * Сразу
  }

  teamId() {
    return this._teamId;
  }

  character() {
    return $gameMap.aaGetGlobalSkill(this._uId);
  }

  battler() {
    if (this.ownerId <= 0) {
      return $gameParty.leader();
    } else {
      return this.aaBattler;
    }
  }

  initABS() {
    if (this.battler() == null) {
      super.initABS();
      // * Инициализация системы в первый раз
      this.aaBattler = new Game_Enemy(this.ownerId, 0, 0);
    } else {

    }
  }

};

// * Ничего
// * Повторная инициализация (например после выхода из меню) не нужна


// Generated by CoffeeScript 2.6.1
// * Данный класс используется для AAEntity врагов на карте
var AAEnemyEntity;

AAEnemyEntity = class AAEnemyEntity extends AAEntity {
  constructor(eventId) {
    super();
    this.eventId = eventId;
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
  }

  // * Группа у них 1, как и у стандартных врагов, чтобы враги их игнорировали
  teamId() {
    return this.model().gTeamId();
  }

  character() {
    return $gameMap.event(this.eventId);
  }

  battler() {
    return this.aaBattler;
  }

  isEnemy() {
    return true;
  }

  logic() {
    return this.aaLogic;
  }

  // * Настройки и параметры
  model() {
    return this.aaModel;
  }

  initABS() {
    if (this.model() == null) {
      super.initABS();
      // * Инициализация системы в первый раз
      this.aaModel = new AAEnemyModelData(this.eventId);
      this.aaBattler = new AAEnemyBattler(this.aaModel.enemyId, this.eventId);
      this.aaLogic = new EnemyAI_FlowMachine(this.eventId);
    } else {

    }
  }

};

// * Ничего
// * Повторная инициализация (например после выхода из меню) не нужна


// Generated by CoffeeScript 2.6.1
// * Класс, который содержит все настройки и параметры AA сущности врага на карте
// * Аналог AIBehavModel из ABS MV

//@[STORABLE]
//@[GLOBAL]
var AAEnemyModelData;

AAEnemyModelData = (function() {
  class AAEnemyModelData {
    constructor(eventId) {
      this.eventId = eventId;
      this.enemyId = this.eventSettings().getEnemyId();
      this._initBaseParameters();
      this._applyParametersFromDB();
      this._applyParametersFromEvent();
      this._convertParameters();
    }

    //TODO: Делать редактор или нет?

      //TODO: Игрок должен иметь возмможность менять значения во время игры
    //TODO: basik shake effect strength when hitted
    enemy() {
      return $dataEnemies[this.enemyId];
    }

    eventSettings() {
      return $gameMap.event(this.eventId).aaEventSettings;
    }

    isHaveDeadSwitch() {
      return AA.Utils.checkSwitch(this.deadSwitch);
    }

    isHaveOnDeathAction() {
      return AA.SAaction.isProper(this.onDeath);
    }

    isHaveOnSeeTargetAction() {
      return AA.SAaction.isProper(this.onSeeTarget);
    }

    isHaveSpecialExpValue() {
      return this.expVar > 0;
    }

    isHaveOnDeathVariable() {
      return this.onDeathVar > 0;
    }

    isHeavy() {
      return AA.Utils.getSafeEValue(this.heavy, 0) > 0;
    }

    isNotAgressive() {
      return AA.Utils.getSafeEValue(this.notAgressive, 0) > 0;
    }

    gReturnRadius() {
      return AA.Utils.getSafeEValue(this.returnRadius, 12);
    }

    gViewRadius() {
      return AA.Utils.getSafeEValue(this.viewRadius, 5);
    }

    gTVisor() {
      return this.tVisor; //AA.Utils.getSafeEValue(@tVisor, 0)
    }

    gTeamId() {
      return AA.Utils.getSafeEValue(this.teamId, 1);
    }

    gNoMoveInBattle() {
      return AA.Utils.getSafeEValue(this.noMoveInBattle, 0);
    }

    gNoApproach() {
      return AA.Utils.getSafeEValue(this.noApproach, 0);
    }

    isTVision() {
      return this.tVisor > 0; //@gTVisor() > 0
    }

    isCanTeleportIn() {
      return this.gTeleportDistIn() > 0;
    }

    isCanTeleportOut() {
      return this.gTeleportDistOut() > 0;
    }

    gTeleportDistIn() {
      return AA.Utils.getSafeEValue(this.teleportDistIn, 0);
    }

    gTeleportDistOut() {
      return AA.Utils.getSafeEValue(this.teleportDistOut, 0);
    }

    gTeleportDelay() {
      return AA.Utils.getSafeEValue(this.teleportDelay, 3);
    }

    gTeleportRate() {
      return AA.Utils.getSafeEValue(this.teleportRate, 1);
    }

    isHaveAfterDeathBonus() {
      return (this.bonusOnDeadIds != null) && this.bonusOnDeadIds.length > 0;
    }

  };

  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = AAEnemyModelData.prototype;
    
    // * Инициализация базовых настроек
    _._initBaseParameters = function() {
      this._initMain();
      this._initOnMapSettings();
      this._initOtherSettings();
      this._initVisualSettings();
      this._initAnimationSettings();
      this._initMovingSettings();
    };
    _._initMain = function() {
      this.onDeath = 0; //AScript
      this.returnRadius = 12; //@[EVal]
      this.viewRadius = 5; //@[EVal]
      this.noPassVisionRegions = [];
      this.noPassVisionTerrains = [];
      this.tVisor = 0; // From 1 to X (Длина основания треугольника (fov))
      this.sideVisor = 0; // Сколько клеток по сторонам (слева и справа)
      this.notAgressive = 0;
      this.activeOutOfScreen = 0;
    };
    _._initOnMapSettings = function() {
      this.shatterEffect = 1;
      this.deadSwitch = 0; //Switch (A, B, C, D)
      this.eraseOnDead = 1;
      // * Тип атаки Motion, если у навыка есть isHaveWeaponMotion
      this.weaponMotionType = 0;
      // * Работает только с Extended Loot и Visual Drop ON
      this.lootDropOnDeath = 1;
      // * Врага нельзя сдвинуть импульсом
      this.heavy = 0; //@[EVal]
      // * Система "летающих" бонусов
      this.bonusOnDeadIds = [];
    };
    _._initVisualSettings = function() {
      this.faceName = ""; // имя файла в папке faces
      this.faceIndex = 0;
      this.UIInfo = 1; // * Если 1 - показывать Target UI при наведени курсора
      this.miniHpGaugeStyle = "";
      this.miniHPGaugeOffset = [0, 0];
      return this.damagePopUpYOffset = 0;
    };
    _._initOtherSettings = function() {
      this.onSeeTarget = 0; //AScript
      // * Переменная для опыта (отдельное значение, а не из БД)
      this.expVar = 0;
      // * За данного врага опыт даётся автоматически ( если 1)
      this.autoExp = 1;
      // * При получении урона (AABS навыка от кого либо)
      this.onHit = 0; //AScript
      // * Номер команды (по умолчанию у всех врагов 1)
      this.teamId = 1; //@[EVal]
      // * Переменная для +1 когда этот враг погибает
      this.onDeathVar = 0;
      // * Метка, для uAPI
      this.label = "";
      // * Даные действия выполняются каждую секунд (каждую секунду в битве)
      this.turnAction = 0; //AScript
      this.turnActionInBattle = 0; //AScript
      // * Когда враг был отброшен навыком с Impluse
      //TODO: реализовать выполенние
      this.onKnocked = 0; //AScript
      this.saveHp = 0;
    };
    _._initAnimationSettings = function() {
      this.hitAnimationId = 1; // ID анимации
    };
    _._initMovingSettings = function() {
      //@[EVal]
      this.noMoveInBattle = 0; // * Если 1 - враг не будет двигаться в бою (вообще)
      //@[EVal]
      this.noApproach = 0; // * Не преследовать цель в бою (своё движение остаётся, например Random или отступать от игрока)
      // Range (when start), Freq, Speed
      this.approachMoveData = [3, 5, 4];
      // Min dist, Freq, Speed, isRandomStep
      this.inBattleMoveData = [1, 3, 3, 0];
      //TODO: returnMoveData
      //@[EVal]
      this.teleportDistIn = 0;
      //@[EVal]
      this.teleportDistOut = 0;
      //@[EVal]
      this.teleportRate = 1;
      //@[EVal]
      this.teleportDelay = 3;
      this.teleportStartAnim = 0;
      this.teleportEndAnim = 0;
      this.smartPathRefreshTime = 20;
    };
    _._applyParametersFromDB = function() {
      var i, len, p, params;
      params = this.enemy().AAEnemy;
      if (params == null) {
        return;
      }
      for (i = 0, len = params.length; i < len; i++) {
        p = params[i];
        this[p[0]] = p[1];
      }
    };
    // * Применяем параметры из страницы события
    _._applyParametersFromEvent = function() {
      var i, len, param, ref, settings;
      settings = this.eventSettings();
      if (!settings.isHaveExtraParameters()) {
        return;
      }
      ref = settings.getParameters();
      for (i = 0, len = ref.length; i < len; i++) {
        param = ref[i];
        this[param[0]] = param[1];
      }
    };
    // * Преобразует некоторые параметры
    _._convertParameters = function() {
      if (this.miniHpGaugeStyle === 0) {
        this.miniHpGaugeStyle = "";
      }
      this.miniHPGaugeOffset = AA.Utils.Parser.convertArrayFromParameter(this.miniHPGaugeOffset);
      this.approachMoveData = AA.Utils.Parser.convertArrayFromParameter(this.approachMoveData);
      this.inBattleMoveData = AA.Utils.Parser.convertArrayFromParameter(this.inBattleMoveData);
      this.noPassVisionRegions = AA.Utils.Parser.convertArrayFromParameter(this.noPassVisionRegions);
      this.noPassVisionTerrains = AA.Utils.Parser.convertArrayFromParameter(this.noPassVisionTerrains);
      this.bonusOnDeadIds = AA.Utils.Parser.convertArrayFromParameter(this.bonusOnDeadIds);
    };
  })();

  return AAEnemyModelData;

}).call(this);

// ■ END PRIVATE
//---------------------------------------------------------------------------
// * Не используются (для Selection circle)
//@selectionVisible = true
//@selectionColor = "#FF00FF"
//@selectionOffset = [0, -10]
//@selectionImage = "targetSelectedDottedSquare"


// Generated by CoffeeScript 2.6.1
var AAEventLocatorController;

AAEventLocatorController = class AAEventLocatorController {
  constructor() {
    this.locatorCheckThread = new KDCore.TimedUpdate(60, this.refreshLocators.bind(this));
  }

  isActive() {
    return AA.isABSMap();
  }

  locators() {
    return $gameMap.eventsWithLocators();
  }

  refreshLocators() {
    var e, ev, i, len, ref, results;
    if (!this.isActive()) {
      return;
    }
    try {
      ref = this.locators();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        ev = ref[i];
        results.push(this._refreshLocator(ev));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  update() {
    if (!$gameTemp.aaLocatorEventExistsOnMap) {
      return;
    }
    return this.locatorCheckThread.update();
  }

  //%[I] Определять остальные виды событий, не только АБС
  //TODO: Это надо будет потом сделать (см. Game_Event_ExtraAAParams -> _aaExtractLocator комменатрий)
  _refreshLocator(ev) {
    var commonEvent, e, isSearchComplete, loopMode, radius, searchType, settings, teamId;
    settings = ev._aaLocatorConfig;
    if (settings == null) {
      return;
    }
    commonEvent = settings[2];
    if (!(commonEvent > 0)) {
      // * Нет смысла, если нет общего события на запуск
      ev._aaLocatorConfig = null;
      return;
    }
    radius = settings[0] || 1;
    searchType = settings[1] || 0;
    if (settings[3] != null) {
      loopMode = settings[3];
    } else {
      loopMode = 1; // * 1 - once, by default
    }
    isSearchComplete = false;
    if (searchType >= -1) {
      // * -1 Мой TeamId
      if (searchType === -1) {
        if (ev.isABS()) {
          teamId = ev.AAEntity().teamId();
        } else {
          teamId = 0; // * Если простое событие, то сбрасываем на 0
        }
      } else {
        teamId = searchType;
      }
      isSearchComplete = this._checkLocatorForAAEvents(ev, radius, teamId);
    } else {

    }
    //TODO: simple events searach

    // * Не нашли никого, пропуск
    if (!isSearchComplete) {
      return;
    }
    try {
      // * Запускаем общее событие relative
      ev.aaStartCommonEvent(commonEvent);
      $gameTemp.aaLastActivatedLocator = ev;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    if (loopMode > 0) {
      // * Отключаем локатор
      ev._aaLocatorConfig = null;
    }
  }

  _checkLocatorForAAEvents(ev, radius, teamId) {
    var candidates;
    // * Только AA события (и игрок)
    candidates = AATargetsManager.collectAllABSEntitiesOnMap();
    // * Тут равно, потому что мы ищем этот teamId
    candidates = candidates.filter(function(c) {
      return c.AAEntity().teamId() === teamId;
    });
    // * Фильтруем по радиусу
    candidates = AATargetsManager.getFilteredInRadius(ev, radius, candidates);
    if (candidates.length > 0) {
      $gameTemp.aaLastLocatorTarget = candidates[0];
      return true;
    } else {
      return false;
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEventSettingsParser.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var AAEventSettingsParser;
  AAEventSettingsParser = class AAEventSettingsParser {
    constructor(list) {
      this.list = []; // * Список всех комментариев
      this.absParameters = []; // * ABS параметры
      this.param = null; // * Параметр плагина (MZ)
      this.mainLine = ""; // * <ABS:X>
      this.parsedParams = []; // * Финальные значения параметров на замену
      this._pasreEventList(list);
      this._parseABSParamsBase();
      this._parseABSParamsSequence();
      this._parseParams();
      this._parsePluginCommand();
      return;
    }

    isHaveExtraParameters() {
      return this.parsedParams.length > 0;
    }

    getParameters() {
      return this.parsedParams;
    }

    // * Получить значение переменной опыта
    // * Данный метод используется чтобы получить опыт с уже мёртвого врага (т.е. NOT ACTIVE ABS)
    // * (нету модели и Entity, только остались эти данные)
    // * (используется если коммент был задан на событии, а в БД нету)
    getExpVarId() {
      var param;
      param = this.getParameters().find(function(p) {
        return p[0] === 'expVar';
      });
      if (param == null) {
        return 0;
      }
      return parseInt(param[1]);
    }

    getEnemyId() {
      var param;
      param = AA.Utils.Parser.extractABSParameter(this.mainLine);
      if (param == null) {
        return 0;
      }
      return param[1];
    }

    
      // * Извлечает из списка команд только комменатрии или определённую команду плагина
    _pasreEventList(list) {
      var j, len, line, ref;
      for (j = 0, len = list.length; j < len; j++) {
        line = list[j];
        if (line == null) {
          continue;
        }
        if (line.code === 108 || line.code === 408) {
          this.list.push(line.parameters[0]);
        } else if (line.code === 357 && ((ref = line.parameters) != null ? ref[1] : void 0) === "ABSEventSettings") {
          this.param = line;
        }
      }
    }

    // * Собирает параметры в базовом представлении < > (как в оригинале)
    _parseABSParamsBase() {
      var j, l, len, param, ref;
      ref = this.list;
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        if (l == null) {
          continue;
        }
        param = AA.Utils.Parser.extractABSParameter(l);
        if (param == null) {
          continue;
        }
        if (param[0] === 'ABS') {
          // * Не добавляем ABS, он идёт отдельно
          continue;
        }
        this.parsedParams.push(param);
      }
    }

    // * Собирает все строки с АБС параметрами от <ABS> до </ABS>
    _parseABSParamsSequence() {
      var endElement, i, j, ref, ref1, startIndex;
      this.mainLine = this.list.find(function(l) {
        return l.contains('<ABS');
      });
      endElement = this.list.find(function(l) {
        return l.contains('</ABS>');
      });
      if (endElement == null) {
        return;
      }
      startIndex = this.list.indexOf(this.mainLine);
      if (startIndex < 0) {
        return;
      }
      for (i = j = ref = startIndex + 1, ref1 = this.list.length; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
        if (this.list[i] === endElement) {
          break;
        }
        this.absParameters.push(this.list[i]);
      }
    }

    // * Парсинг всех параметров из строк в структуру (имя: значение)
    _parseParams() {
      var j, len, pair, param, ref;
      if (this.absParameters.length === 0) {
        return;
      }
      ref = this.absParameters;
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        pair = AA.Utils.Parser.extractABSParameter(param);
        if (pair == null) {
          continue;
        }
        // * Пропускаем ещё один ABS параметр, если был добавлен
        //TODO: Можно делать проверку при передаче данных на Model
        if (pair[0] === 'ABS') {
          continue;
        } else {
          this.parsedParams.push(pair);
        }
      }
    }

    //TODO: Доработать: исключить группы, правильный конвентор

      //TODO: deadSwitch
    // * Извлекает параметры из команды плагина
    _parsePluginCommand() {
      var k, p, params, v;
      if (this.param == null) {
        return;
      }
      if (!KDCore.isMZ()) {
        return;
      }
      params = this.param.parameters[3];
      if (params == null) {
        return;
      }
      for (k in params) {
        v = params[k];
        if (k.contains("Group")) {
          // * Пропускаем заголовки групп
          continue;
        }
        p = [k, AA.Utils.Parser.convertParameterValue(v)];
        this.parsedParams.push(p);
      }
    }

  };
  AA.link(AAEventSettingsParser);
})();

// ■ END AAEventSettingsParser.coffee
//---------------------------------------------------------------------------
window.AAEventSettingsParser = AA.AAEventSettingsParser;


// Generated by CoffeeScript 2.6.1
// * Данный класс хранит информацию и состояния всех ABS объектов на карте

//@[STORABLE]
//@[GLOBAL]
var AAMapEntitiesSet;

AAMapEntitiesSet = class AAMapEntitiesSet {
  constructor(mapId) {
    this.mapId = mapId;
  }

};


// Generated by CoffeeScript 2.6.1
var AAMapFlyBonusInstance;

AAMapFlyBonusInstance = class AAMapFlyBonusInstance {
  constructor(mapX, mapY, settings) {
    var anyPointWithOffset, point, r;
    this.settings = settings;
    this.x = this._convertPointValue(mapX);
    this.y = this._convertPointValue(mapY);
    r = this.settings.startOffsetRadiusInPx;
    if (r > 1) {
      anyPointWithOffset = AA.Utils.Math.getPointsInRadius(this.x, this.y, r);
      point = anyPointWithOffset.sample();
      if (point != null) {
        this.x = point.x;
        this.y = point.y;
      }
    }
    return;
  }

  isPhantom() {
    return false; //TODO: NETZ
  }

  image() {
    return this.settings.image;
  }

  speed() {
    return this.settings.flySpeed;
  }

  delay() {
    return this.settings.stayFrames;
  }

  onHit() {
    var e, value;
    try {
      //"BONUS POINT REACH".p()
      KDCore.Utils.playSE(this.settings.actionSE);
      if (String.any(this.settings.actionSA)) {
        uAPI.scriptAction(this.settings.actionSA, $gamePlayer);
      }
      value = AA.Utils.getSafeEValue(this.settings.hpGainE, 0);
      if ((value != null) && value !== 0) {
        this._gainHp(value);
      }
      value = AA.Utils.getSafeEValue(this.settings.mpGainE, 0);
      if ((value != null) && value !== 0) {
        this._gainMp(value);
      }
      value = AA.Utils.getSafeEValue(this.settings.expGainE, 0);
      if ((value != null) && value > 0) {
        this._gainExp(value);
      }
      value = AA.Utils.getSafeEValue(this.settings.goldGainE, 0);
      if ((value != null) && value !== 0) {
        this._gainGold(value);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  _gainHp(value) {
    return uAPI.gainHpForBattler(0, value, false);
  }

  _gainMp(value) {
    return uAPI.gainMpForBattler(0, value, false);
  }

  _gainExp(value) {
    return uAPI.gainExpForParty(value);
  }

  _gainGold(value) {
    return uAPI.gainGoldForParty(value);
  }

  getTargetPoint() {
    return {
      x: this._convertPointValue($gamePlayer.x),
      y: this._convertPointValue($gamePlayer.y)
    };
  }

  _convertPointValue(value) {
    var tw;
    tw = $gameMap.tileWidth();
    return Number(value * tw + tw / 2);
  }

};


// Generated by CoffeeScript 2.6.1
var AANetworkCharEntity;

AANetworkCharEntity = class AANetworkCharEntity extends AAEntity {
  constructor(netId) {
    super();
    this.netId = netId;
    return;
  }

  // * Номер команды игрока (и группы) всегда 0
  teamId() {
    if (this.isHaveTeamId()) {
      return this.battler().aaNetGetTeamId();
    } else {
      if (AA.Network.isNetworkPvPGame()) {
        return 100;
      } else {
        return 0;
      }
    }
  }

  isNetChar() {
    return true;
  }

  isAlly() {
    if (this.isHaveTeamId()) {
      return this.teamId() === $gamePlayer.AAEntity().teamId();
    } else {
      return !AA.Network.isNetworkPvPGame();
    }
  }

  character() {
    return $gameMap.networkCharacterById(this.netId);
  }

  battler() {
    var ref;
    return (ref = this.character()) != null ? ref.actor() : void 0;
  }

  // * Network character определяется на карте почти как событие
  // * Сейчас используется для показа UIEnemyTargetInfo
  //TODO: Временное решение
  model() {
    return this.aaModel;
  }

  initABS() {
    super.initABS();
    this.aaModel = {
      faceName: this.battler().faceName(),
      faceIndex: this.battler().faceIndex()
    };
  }

};


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер обработки (отправки) сетевых запросов
var AANetworkManager;

AANetworkManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AANetworkManager;
  (function() {    // * Методы (запросы - отправка на сервер, requests)
    // * ======================================================================
    // -----------------------------------------------------------------------
    // * В этих методах всегда много проверок, чтобы не загружать лишний раз севрер
    _.sendDummyCharacterData = function(ownerId, teamId, uId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("sendDummyCharacterData", {ownerId, teamId, uId});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDisposeDummyCharacter = function(uId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("sendDisposeDummyCharacter", uId);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.refreshPvPGameModeState = function() {
      var e, newState;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        newState = $gameSystem.aaIsPvPActive;
        return this.sendToServer("refreshPvPGameModeState", newState);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.setActorNetworkTeamId = function(actorId, teamId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("setActorNetworkTeamId", {actorId, teamId});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: В MV другой метод немного
    _.playAnimationOnCharacter = function(character, animationId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (animationId <= 0) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("playAnimationOnCharacter", {character, animationId});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.playAnimationOnMap = function(x, y, animationId, sx, sy) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (animationId <= 0) {
          return;
        }
        return this.sendToServer("playAnimationOnMap", {x, y, animationId, sx, sy});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.showDamagePopUpOnCharacter = function(character, data) {
      var e, styleId, value;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (data == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        styleId = data.settings.id;
        value = data.value;
        return this.sendToServer("showDamagePopUpOnCharacter", {character, styleId, value});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShakeEffect = function(character, time) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterShakeEffect", {character, time});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShatterEffect = function(character, dx, dy) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterShatterEffect", {character, dx, dy});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestWeaponAnimation = function(battler, weaponImageId) {
      var character, e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = battler.AACharacter();
        if (character == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestWeaponAnimation", {character, weaponImageId});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterMotion = function(character, motionType) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterMotion", {character, motionType});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Смена состояния AnimaX (боевая стойка, кастинг, смерть и т.д.)
    // * Свой метод (у AnimaX 1.2 и ниже нету автосинхронизации на этот метод)
    _.animaXChangeState = function(newState, character) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (!String.any(newState)) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("animaXChangeState", {newState, character});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.executeSA = function(action, character) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("executeSA", {action, character});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Враги с eraseOnDead = 1 синхронизируются автоматически
    _.executeEraseOnDeadAAEvent = function(eventId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("executeEraseOnDeadAAEvent", eventId);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEntityObserver = function(character, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("syncAAEntityObserver", {character, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAIFlowMachineObserver = function(eventId, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("syncAIFlowMachineObserver", {eventId, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEnemyBattlerObserver = function(character, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("syncAAEnemyBattlerObserver", {character, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.sendTurnTowardCharacter = function(character, point) {
      var e, x, y;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        ({x, y} = point);
        return this.sendToServer("sendTurnTowardCharacter", {character, x, y});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.applyActionOnTarget = function(target, action) {
      var e, skill, subject;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (target == null) {
          return;
        }
        if (action == null) {
          return;
        }
        target = AA.Network.packMapChar(target);
        subject = action._packedSubject;
        skill = action.AASkill().idA;
        return this.sendToServer("applyActionOnTarget", {subject, skill, target});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Добавить MapSkill на карту (визуально, расчёт на мастере карты)
    _.startAASkillOnMap = function(skill, subject, targetPoint, uniqueId) {
      var diagonalDir, direction, e, x, y;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (subject == null) {
          return;
        }
        if (skill == null) {
          return;
        }
        if (targetPoint == null) {
          return;
        }
        direction = subject.direction;
        diagonalDir = subject._diagonalDir;
        subject = AA.Network.packMapChar(subject);
        skill = skill.idA;
        ({x, y} = targetPoint);
        return this.sendToServer("startAASkillOnMap", {
          subject,
          skill,
          targetPoint: {x, y},
          uniqueId,
          direction,
          diagonalDir
        });
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Удалить MapSkill (чисто визуально)
    _.endAASkillOnMap = function(uniqueId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("endAASkillOnMap", uniqueId);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Когда идёт спавн монстра
    _.spawnEnemy = function(id, x, y) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        // * Спавн точно произошёл?
        if (uAPI.isEnemyBeenSpawned()) {
          return this.sendToServer("spawnEnemy", {id, x, y});
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.gainExpFor = function(char, value, isVisible) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (value <= 0) {
          return;
        }
        if (char == null) {
          return;
        }
        char = AA.Network.packMapChar(char);
        return this.sendToServer("gainExpFor", {char, value, isVisible});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Обработка методов ОТ сервера (responses)
    // * ======================================================================
    // -----------------------------------------------------------------------
    _.playAnimationOnCharacter_RESP = function(response) {
      var animationId, character, e;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, animationId} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return AABattleActionsManager.playAnimationOnCharacter(character, animationId);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.playAnimationOnMap_RESP = function(response) {
      var animationId, e, sx, sy, x, y;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({x, y, animationId, sx, sy} = response.content);
        return AABattleActionsManager.playAnimationOnMap(x, y, animationId, sx, sy);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.showDamagePopUpOnCharacter_RESP = function(response) {
      var character, data, e, ref, styleId, value;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, styleId, value} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character !== $gamePlayer) {
          styleId = "Damage_HP_For_Enemy";
        }
        data = AADamagePopUpFactory._createFromSettings(styleId, value);
        if (data == null) {
          return;
        }
        Sprite_AADamagePopUpItem.CreateOnCharacterBinded(character, data.settings, data.value);
        // * Чтобы HP минибар обновился
        return (ref = character.AASprite()) != null ? ref._aaRefreshExtraInfoOnDamage() : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShakeEffect_RESP = function(response) {
      var character, e, time;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, time} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character.aaIsShakeRequested()) {
          return;
        }
        if ((time != null) && time > 0) {
          return character != null ? character.aaRequestShakeEffect(time) : void 0;
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShatterEffect_RESP = function(response) {
      var character, dx, dy, e;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, dx, dy} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character.aaIsShatterRequested()) {
          return;
        }
        return character.aaRequestShatterEffect(dx, dy);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestWeaponAnimation_RESP = function(response) {
      var character, e, ref, weaponImageId;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, weaponImageId} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AABattler()) != null ? ref.startWeaponAnimation(weaponImageId) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterMotion_RESP = function(response) {
      var character, e, motionType;
      try {
        //TODO: Есть проблема создания множества DeadMotion
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, motionType} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (motionType != null) {
          if (!character.aaIsMotionRequested()) {
            return character.aaRequestMotion(motionType);
          }
        } else {
          return character.aaClearMotion();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.executeSA_RESP = function(response) {
      var action, character, cmd, e, mapId, unpackedCharacter;
      try {
        ({mapId} = response);
        ({action, character} = response.content);
        cmd = action.split("_")[0];
        // * Self.Switch - своя обработка
        if (cmd === "ss") {
          // * Тут используется  запакованный персонаж (чтобы передать EVENT ID другой карты)
          return AA.SAaction.executeSelfSwitchActionFromNetwork(action, character, mapId);
        } else {
          // * Проверки определённых действий (только на карте и на сцене)
          if (["an", "ef", "ba", "se", "ev", "ce"].contains(cmd)) {
            if (!AA.Network.isAvailableForVisual(response)) {
              return;
            }
          }
          unpackedCharacter = AA.Network.unpackMapChar(character);
          return AA.SAaction.execute(action, unpackedCharacter);
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.executeEraseOnDeadAAEvent_RESP = function(response) {
      var e, event, eventId;
      try {
        // * Тут сцена не важна
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        eventId = response.content;
        if (eventId <= 0) {
          return;
        }
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        //TODO: Может проверку что это ABS событие?
        return event.erase();
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEntityObserver_RESP = function(response) {
      var character, e, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, observerData} = response.content);
        if (observerData == null) {
          return;
        }
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AAEntity()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAIFlowMachineObserver_RESP = function(response) {
      var e, event, eventId, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({eventId, observerData} = response.content);
        if (eventId <= 0) {
          return;
        }
        if (observerData == null) {
          return;
        }
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        if (event.isABS() == null) {
          return;
        }
        return (ref = event.AALogic()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEnemyBattlerObserver_RESP = function(response) {
      var character, e, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, observerData} = response.content);
        if (observerData == null) {
          return;
        }
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AABattler()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.animaXChangeState_RESP = function(response) {
      var character, e, newState;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, newState} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (String.any(newState) == null) {
          return;
        }
        if (!character.isAnimX()) {
          return;
        }
        if (newState === 'base') {
          return character.resetXAnimaState();
        } else {
          return character.switchToXAnimaState(newState);
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.sendTurnTowardCharacter_RESP = function(response) {
      var character, e, x, y;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, x, y} = response.content);
        character = AA.Network.unpackMapChar(character);
        return character != null ? character.turnTowardCharacter({x, y}) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.applyActionOnTarget_RESP = function(response) {
      var action, e, skill, subject, target;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({subject, skill, target} = response.content);
        // * Мы брали запакованный Subject из Game_Action напрямую,
        // а там он так упакован (через AA.Utils)
        subject = AA.Utils.unpackAAEntity(subject);
        if (subject == null) {
          return;
        }
        skill = AA.Utils.unpackAASkill(skill);
        if (skill == null) {
          return;
        }
        action = new AABattleAction(subject, skill);
        target = AA.Network.unpackMapChar(target);
        if (target == null) {
          return;
        }
        return AABattleActionsManager._applyActionOnTarget(target, action);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.startAASkillOnMap_RESP = function(response) {
      var diagonalDir, direction, e, skill, subject, targetPoint, uniqueId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({subject, skill, targetPoint, uniqueId, direction, diagonalDir} = response.content);
        subject = AA.Network.unpackMapChar(subject);
        if (subject == null) {
          return;
        }
        subject.setDirection(direction);
        subject._diagonalDir = diagonalDir;
        skill = AA.Utils.unpackAASkill(skill);
        if (skill == null) {
          return;
        }
        $gameMap.startAASkill(skill, subject, targetPoint);
        // * Метод на gameMap () сохраняет последний созданный
        // * навык в $gameTemp.__lastAAMapSkill, чтобы можно
        // * было установить ID из сети (по индексу нельзя)
        if ($gameTemp.__lastAAMapSkill != null) {
          $gameTemp.__lastAAMapSkill.setUniqueId(uniqueId);
          return $gameTemp.__lastAAMapSkill = null;
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.endAASkillOnMap_RESP = function(response) {
      var e, skill, uniqueId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        uniqueId = response.content;
        skill = $gameMap.aaMapSkills().find(function(s) {
          return (s != null) && s.uniqueId === uniqueId;
        });
        if (skill == null) {
          return;
        }
        // * Намеренно устанавливаем время в 0, чтобы удалился
        skill.totalFlyTime = 0;
        return skill.forceEndFromNetwork = true;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.spawnEnemy_RESP = function(response) {
      var e, id, x, y;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({id, x, y} = response.content);
        return uAPI.spawnEnemyForced(id, x, y);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.refreshPvPGameModeState_RESP = function(response) {
      var e, newState;
      try {
        newState = response.content;
        // * Not using uAPI for not send to server again
        if (newState === true) {
          return AA.Network.setPvPMode();
        } else {
          return AA.Network.setPvEMode();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setActorNetworkTeamId_RESP = function(response) {
      var actorId, e, teamId;
      try {
        ({actorId, teamId} = response.content);
        return uAPI.setTeamIdFor("actorId", actorId, teamId, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDummyCharacterData_RESP = function(response) {
      var dummyChar, e, ownerId, teamId, uId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({ownerId, teamId, uId} = response.content);
        return dummyChar = new AADummyCharacter(ownerId, teamId, uId);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDisposeDummyCharacter_RESP = function(response) {
      var e, uId;
      try {
        uId = response.content;
        if (uId != null) {
          return $gameMap.aaDisposeGlobalSkill(uId);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.gainExpFor_RESP = function(responce) {
      var char, e, isVisible, value;
      try {
        if (responce == null) {
          return;
        }
        ({char, value, isVisible} = responce.content);
        char = AA.Network.unpackMapChar(char);
        if (char === $gamePlayer) {
          $gameParty.leader().gainExp(value);
          if (isVisible === true) {
            return $gameParty._aaShowExpPopUpVisually([char], value);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  return (function() {    // * Общие методы отправки и приёма команд
    // * ======================================================================
    // -----------------------------------------------------------------------
    // * Обработка ответа (команды) от сервера (общий метод)
    _.onServerCommand = function(cmd, response) {
      var e, method;
      try {
        //return if SceneManager.isSceneChanging()
        if (AA.Network.isShouldIgnoreServerCommand(response)) {
          return;
        }
        // * Получить только имя команды (без префикса)
        //cmd = cmd.replace(AA.Network.NETCmdPrefix, "")
        method = this[cmd + "_RESP"];
        if (method != null) {
          $gameTemp.aaIsLocalOnly = true;
          try {
            method(response);
          } catch (error) {
            e = error;
            AA.w(cmd, e);
          }
          return $gameTemp.aaIsLocalOnly = false;
        } else {
          return AA.w('Network: Handler for ' + cmd + ' not found');
        }
      } catch (error) {
        e = error;
        return AA.w(e, "onServerCommand");
      }
    };
    // * Отправка команды на сервер (общий метод)
    return _.sendToServer = function(cmd, content) {
      var data, e;
      try {
        if ($gameTemp.aaIsLocalOnly === true) {
          return;
        }
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (SceneManager.isSceneChanging()) {
          return;
        }
        // * Все команды только с карыт можно отправлять
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        // * Это старый способ (через nAPI)
        /*nAPI.sendCustomCommand(
            AA.Network.NETCmdPrefix + cmd,
            AA.Network.createServCommand(content)
        )*/
        data = AA.Network.createServCommand(content);
        return ANNetwork.send(NMS.ABSZ(cmd, data));
      } catch (error) {
        e = error;
        return AA.w(e, "sendToServer");
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AAPlayerEntity;

AAPlayerEntity = class AAPlayerEntity extends AAEntity {
  constructor() {
    super();
  }

  // * Номер команды игрока (и группы) всегда 0
  teamId() {
    if (AA.Network.isNetworkGame() && this.isHaveTeamId()) {
      return this.battler().aaNetGetTeamId();
    } else {
      return 0;
    }
  }

  isPlayer() {
    return true;
  }

  character() {
    return $gamePlayer;
  }

  battler() {
    return $gameParty.leader();
  }

  setTarget(target) {
    super.setTarget(target);
    AA.EV.call("PlayerTarget");
  }

};


// Generated by CoffeeScript 2.6.1
// * Это класс определяет настройки Extension у оружия

//@[STORABLE]
var AASkillExtensionDefinition;

AASkillExtensionDefinition = class AASkillExtensionDefinition {
  constructor(id) {
    this.id = id;
    this._initBase();
  }

  databaseId() {
    return this.id;
  }

  dbItem() {
    return $dataWeapons[this.id];
  }

  isValidDefinition() {
    return (this.extensions != null) && this.extensions.length > 0;
  }

  isRequireExtensionItem() {
    return this.extensionRequire > 0;
  }

  isConsumeExtensionItem() {
    return this.extensionConsume > 0;
  }

  // * Установить набор параметров из Note (принимает массив пар: имя - значение)
  setNoteParameters(params) {
    var i, len, p;
    for (i = 0, len = params.length; i < len; i++) {
      p = params[i];
      this[p[0]] = p[1];
    }
    this._convertParameters();
  }

  _initBase() {
    this.extensions = [];
    this.extensionRequire = 0;
    return this.extensionConsume = 0;
  }

  // * Преобразует некоторые параметры
  _convertParameters() {
    return this.extensions = AA.Utils.Parser.convertArrayFromParameter(this.extensions);
  }

};


// Generated by CoffeeScript 2.6.1
// * Этот класс хранит свойства Extension предмета

//@[STORABLE]
var AASkillExtensionItem;

AASkillExtensionItem = class AASkillExtensionItem {
  constructor(id) {
    this.id = id;
    this._params = {};
  }

  databaseId() {
    return this.id;
  }

  dbItem() {
    return $dataItems[this.id];
  }

  getParameters() {
    return this._params;
  }

  // * Установить набор параметров из Note (принимает массив пар: имя - значение)
  setNoteParameters(_params) {
    this._params = _params;
  }

};


// Generated by CoffeeScript 2.6.1
// * Класс отвечает за спавн монстров из точек спавна на АБС карте

// * Данный класс создаётся на сцене карты и он сам проверяет все события со спавном
// * и спавнит монстров, если это необходимо (таймеры храняться на событиях)

//TODO: В демке сделать кристал, который можно настраивать сколько врагов одновременно хочешь?
//TODO: Сколько врагов максимум хочешь?
//TODO: Работа в сетевом режиме! (Это надо методы uAPI доделывать, чтобы они сами определелия и делали force у НЕ мап мастеров)
var AASpawnPointsController;

AASpawnPointsController = class AASpawnPointsController {
  constructor() {
    this.spawnCheckThread = new KDCore.TimedUpdate(60, this.refreshSpawn.bind(this));
  }

  isActive() {
    return AA.isABSMap();
  }

  spawnPoints() {
    return $gameMap.eventsWithSpawnPoints();
  }

  refreshSpawn() {
    var e, i, len, ref, results, sp;
    if (!this.isActive()) {
      return;
    }
    try {
      ref = this.spawnPoints();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sp = ref[i];
        results.push(this._refreshSpawnForSP(sp));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  update() {
    if (!$gameTemp.aaSpawnPointExistsOnMap) {
      return;
    }
    return this.spawnCheckThread.update();
  }

  _refreshSpawnForSP(sp) {
    var e, settings;
    settings = AA.PP.getSpawnPointSettings(sp._aaSpawnPointId);
    if (settings == null) {
      sp._aaSpawnPointId = null;
      return; // * Не должно быть, но на всякий случай
    }
    // * Увеличиваем таймер спавна у каждого события
    sp._aaSpawnPointStep++;
    try {
      this._workWithSpawnPoint(settings, sp);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  _workWithSpawnPoint(settings, event) {
    // * Проверка условия - свитча
    if (!this._isSpawnPointActive(settings.conditionSwitch)) {
      return;
    }
    // * Проверка тайминга
    if (!this._isProperSpawnRate(settings.spawnRate, event._aaSpawnPointStep)) {
      return;
    }
    // * Провера видимости (если в кругу видимости должен быть)
    if (!this._isInVisorRadius(settings.visorRadius, event)) {
      return;
    }
    // * Проверка макс. кол-ва (или кол-ва живих)
    if (!this._isCanSpawnNow(settings, event)) {
      return;
    }
    // * Все условия пройдены, можно делать спавн
    this._executeSpawnPoint(settings, event);
  }

  _isSpawnPointActive(conditionSwitch) {
    if (conditionSwitch > 0) {
      return $gameSwitches.value(conditionSwitch) === true;
    } else {
      return true;
    }
  }

  _isInVisorRadius(visorRadius, event) {
    if (visorRadius <= 0) {
      return true;
    }
    return AA.Utils.Math.getDistanceMapPlayerPoint(event) <= visorRadius;
  }

  _isProperSpawnRate(spawnRate, eventSpawnStep) {
    spawnRate = KDCore.Utils.getEValue(spawnRate);
    return eventSpawnStep >= spawnRate;
  }

  _isCanSpawnNow({spawnMax, spawnAliveMax, endCommonEvent}, event) {
    var e, spawnAliveMaxX, spawnMaxX, spawnedAlive;
    try {
      spawnMaxX = KDCore.Utils.getEValue(spawnMax);
      if (spawnMaxX > 0) {
        if (event._aaSpawnPointSpawnedCount >= spawnMaxX) {
          // * Отключаем событие!
          event._aaSpawnPointId = null;
          // * Общее событие когда конец спавна!
          AA.Utils.startCE(endCommonEvent);
          return false;
        }
      }
      spawnAliveMaxX = KDCore.Utils.getEValue(spawnAliveMax);
      if (spawnAliveMaxX > 0) {
        spawnedAlive = uAPI.getSpawnPointSpawnedAlive(event.eventId());
        if (spawnedAlive >= spawnAliveMaxX) {
          event._aaSpawnPointStep = 0;
          return false;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
    return true;
  }

  _executeSpawnPoint({spawnPointType, spawnRadius, spawnEnemiesId}, event) {
    var spawned;
    event._aaSpawnPointStep = 0; // * Зануляем таймер всегда, даже если нет спавна
    spawnRadius = KDCore.Utils.getEValue(spawnRadius);
    if (spawnPointType === 'region') {
      this._spawnEnemyInRegion(spawnEnemiesId, spawnRadius);
    } else if (spawnPointType === 'player') {
      this._spawnEnemyAroundPlayer(spawnEnemiesId, spawnRadius);
    } else {
      this._spawnEnemyAroundSpawnPoint(spawnEnemiesId, spawnRadius, event);
    }
    spawned = uAPI.getLastSpawnedEnemy();
    if (spawned == null) {
      return;
    }
    // * Увеличиваем общее количество (на событии)
    event._aaSpawnPointSpawnedCount += 1;
    // * Присваиваем ID новому монстру для подсчёта Alive для этого события
    spawned._aaSpawnPointRelativeId = event.eventId();
  }

  _spawnEnemyInRegion(spawnEnemiesId, regionId) {
    if (regionId == null) {
      return;
    }
    if (regionId <= 0) {
      return;
    }
    uAPI.spawnEnemy(spawnEnemiesId, regionId);
  }

  _spawnEnemyAroundPlayer(spawnEnemiesId, radius) {
    if (radius == null) {
      radius = 1;
    }
    if (radius <= 0) {
      radius = 1;
    }
    uAPI.spawnEnemyNearPlayer(spawnEnemiesId, radius);
  }

  _spawnEnemyAroundSpawnPoint(spawnEnemiesId, radius, {x, y}) {
    if (radius == null) {
      radius = 1;
    }
    if (radius <= 0) {
      radius = 1;
    }
    uAPI.spawnEnemyAround(spawnEnemiesId, x, y, radius);
  }

};


// Generated by CoffeeScript 2.6.1
// * Менеджер по работе с целями (поиск целей, определение)

//$[ENCODE]
window.AATargetsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AATargetsManager;
  // * Используется для определения цели для Instant NoProjectile Direction навыков
  // * Проверка точки на наличие целей для навыка
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.getTargetInPoint = function(subject, aaSkill, point) {
    var events, targets;
    events = this._collectAllAAEntitiesInPoints([point]);
    if (events.isEmpty()) {
      return null;
    }
    // * В зависимости от Subject и в зависимости от действия навыка
    targets = this.filteredTargetsForSubject(subject, aaSkill, events);
    if ((targets != null) && targets.length > 0) {
      return targets[0];
    } else {
      return null;
    }
  };
  // * Отфильтровать цели (из найденных в точках) для Subject (навыка)
  _.filteredTargetsForSubject = function(subject, aaSkill, targets) {
    var candidates, e, entity, k, l, len, len1, t;
    try {
      entity = subject.AAEntity();
      if (entity == null) {
        return [];
      }
      candidates = [];
      if (aaSkill.isForEnemies()) {
        for (k = 0, len = targets.length; k < len; k++) {
          t = targets[k];
          if (entity == null) {
            continue;
          }
          if (entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      if (aaSkill.isForFriends()) {
        for (l = 0, len1 = targets.length; l < len1; l++) {
          t = targets[l];
          if (!entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      return candidates;
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Собрать цели для навыка (Projectile)
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.collectTargtesForSkill = function(subject, absSkill, point) {
    var chance, extraTargets, k, len, t, targets;
    targets = [];
    // * Точные цели селектора, если мнгновенный навык (только для игрока)
    if (absSkill.isInstant() && subject === $gamePlayer && ($gameTemp._aaSkillSelectorTargets != null)) {
      targets = $gameTemp._aaSkillSelectorTargets;
    } else {
      targets = this.collectTargetsForSkillInMapPoint(absSkill, point);
    }
    if (absSkill.isSwing() && (subject.direction != null)) {
      chance = absSkill.getSwingKoef();
      extraTargets = this.collectTargetsForSwingAction(subject.direction(), point);
      for (k = 0, len = extraTargets.length; k < len; k++) {
        t = extraTargets[k];
        if (KDCore.Utils.isChanceIsGood(chance)) {
          targets.push(t);
        }
      }
    }
    // * Убираем НЕ АБС события
    targets = targets.filter(function(t) {
      return t.isActive();
    });
    targets = this.filteredTargetsForSubject(subject, absSkill, targets);
    // * Сбрасываем цели селектора
    $gameTemp._aaSkillSelectorTargets = null;
    return targets;
  };
  // * Собирает все возможные цели для навыка в точке карты
  // * (Лучше использовать этот метод для определения целей)
  _.collectTargetsForSkillInMapPoint = function(aaSkill, point) {
    var kdPoint, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    if (point instanceof Game_Character && aaSkill.isSingleTargetArea() && !(point instanceof AADummyCharacter)) {
      targets = [point];
    } else {
      if (aaSkill.isSingleTargetArea()) {
        targets = this._collectAllAAEntitiesInPoints([point]);
      } else {
        kdPoint = new KDCore.Point(point.x, point.y);
        targets = this.collectTargetsForSkillInScreenPoint(aaSkill, kdPoint.convertToScreen());
      }
    }
    return targets;
  };
  // * Собрать цели для навыка с эффектом "взмаха"
  _.collectTargetsForSwingAction = function(direction, point) {
    var e, neibPoints;
    try {
      if (point == null) {
        return [];
      }
      if (direction == null) {
        return [];
      }
      neibPoints = AA.Utils.Math.getNeibPoints(point.x, point.y, direction);
      return this._collectAllAAEntitiesInPoints(neibPoints);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return [];
  };
  // * Собирает все возможные цели для навыка в точке экрана
  // * (Используется для сбора событий в радиусе)
  _.collectTargetsForSkillInScreenPoint = function(aaSkill, point) {
    var searchMapPoints, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    // * Сформировать квадрат выбора
    searchMapPoints = this._createSquarePoints(aaSkill.gRadius(), point);
    targets = this._collectAllAAEntitiesInPoints(searchMapPoints);
    return targets;
  };
  _.collectTargetsForPlayerSelector = function(aaSkill) {
    var e, targets;
    try {
      // * Проверка range, если выходит за range, то не будут цели выделяться
      if (AA.Utils.Math.getDistanceMapPlayerPoint(TouchInput.toMapPoint()) <= aaSkill.gRange()) {
        targets = this.collectTargetsForSkillInScreenPoint(aaSkill, TouchInput);
      } else {
        targets = [];
      }
      // * Фильтр целей сразу
      return this.filteredTargetsForSubject($gamePlayer, aaSkill, targets);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Создаём точки карты в квадратной области навыка (пиксели)
  _._createSquarePoints = function(radius, point) {
    var cellSize, cellSize2, ex, ey, i, j, k, l, points, pxRadius, ref, ref1, ref2, ref3, ref4, ref5, sx, sy;
    cellSize = $gameMap.tileWidth();
    cellSize2 = cellSize / 2;
    points = [];
    pxRadius = radius * cellSize / 2;
    sx = point.x - pxRadius;
    sy = point.y - pxRadius;
    ex = point.x + pxRadius;
    ey = point.y + pxRadius;
    for (i = k = ref = sx, ref1 = ex, ref2 = cellSize; ref2 !== 0 && (ref2 > 0 ? k < ref1 : k > ref1); i = k += ref2) {
      for (j = l = ref3 = sy, ref4 = ey, ref5 = cellSize; ref5 !== 0 && (ref5 > 0 ? l < ref4 : l > ref4); j = l += ref5) {
        points.push(new KDCore.Point(i + cellSize2 / 2, j + cellSize2).convertToMap());
      }
    }
    return points;
  };
  // * Собирает все АБС сущности (события + игрок + партия)
  _._collectAllAAEntitiesInPoints = function(points) {
    var aaEntities;
    aaEntities = [];
    aaEntities.push(...this._collectAAEventsInPoints(points));
    aaEntities.push(...this._collectPartyMembersInPoints(points));
    if (AA.Network.isNetworkGame()) {
      aaEntities.push(...this._collectNetworkCharsInPoints(points));
    }
    //TODO: collect network characters as well
    return aaEntities;
  };
  // * Собирает все АБС события (Активные) в точках карты
  _._collectAAEventsInPoints = function(points) {
    var e, events, k, len, p;
    events = [];
    try {
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        events.push(...$gameMap.eventsXyAAExt(p.x, p.y));
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return events;
  };
  _._collectPartyMembersInPoints = function(points) {
    var char, e, k, l, len, len1, members, p, partyMembers;
    members = [];
    try {
      partyMembers = $gamePlayer.aaGetABSFollowers();
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gamePlayer.posExt(p.x, p.y)) {
          members.push($gamePlayer);
        }
        for (l = 0, len1 = partyMembers.length; l < len1; l++) {
          char = partyMembers[l];
          if (char.posExt(p.x, p.y)) {
            members.push(char);
          }
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  _._collectNetworkCharsInPoints = function(points) {
    var e, k, len, members, p;
    members = [];
    try {
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        members.push(...$gameMap.netChars().filter(function(c) {
          return c.posExt(p.x, p.y);
        }));
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  _.collectAllABSEntitiesOnMap = function() {
    var aaEntities;
    aaEntities = [$gamePlayer];
    aaEntities.push(...$gameMap.eventsAA());
    aaEntities.push(...$gamePlayer.aaGetABSFollowers());
    if (AA.Network.isNetworkGame()) {
      aaEntities.push(...$gameMap.netChars());
    }
    return aaEntities.filter(this.isValidTarget);
  };
  // * Быстрый метод проверки, находится ли игрок в определённом радиусе
  _.isPlayerInRadius = function(point, radius) {
    var e;
    try {
      return this.isCharExtInRadius(point, radius, $gamePlayer);
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableTargetsInTriangle = function(forWho, radius, tVisorSize, tSideSize) {
    var _all, candidates, d, e, entity, k, len, p1, p2, p3, points, x, y;
    try {
      points = [];
      candidates = [];
      ({x, y} = forWho);
      d = forWho.direction();
      if (tSideSize > 0) {
        points.push(...AA.Utils.Math.getLeftAndRightPoints(x, y, d));
        candidates = this._collectAllAAEntitiesInPoints(points);
      }
      // * Получаем вершины треугольника
      [p1, p2, p3] = AA.Utils.Math.getTriangleVertixes(x, y, d, radius, tVisorSize);
      // * Проверяем на вхождение
      _all = this.getAvailableTargetsInRadius(forWho, radius);
      for (k = 0, len = _all.length; k < len; k++) {
        entity = _all[k];
        if (AA.Utils.Math.isPointInsideTriangle(p1, p2, p3, entity)) {
          candidates.push(entity);
        }
      }
      return candidates.filter(function(t) {
        return forWho.isMyEnemy(t);
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableTargetsInRadius = function(forWho, radius) {
    var candidates, e;
    try {
      // * forWho идёт как Point тоже
      candidates = this.collectAllABSEntitiesOnMap();
      candidates = candidates.filter(function(t) {
        return (t != null) && forWho.isMyEnemy(t);
      });
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableAlliesInRadius = function(forWho, radius) {
    var candidates, e;
    try {
      // * forWho идёт как Point тоже
      candidates = this.collectAllABSEntitiesOnMap();
      candidates = candidates.filter(function(t) {
        return !forWho.isMyEnemy(t);
      });
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  //? point - просто { x, y }
  // exceptTeamId - будут АА события с НЕ равыным данному teamId
  _.getAvailableAAEntitiesInRadius = function(point, radius, exceptTeamId) {
    var candidates, e;
    try {
      candidates = this.collectAllABSEntitiesOnMap();
      if ((exceptTeamId != null) && exceptTeamId !== -1) {
        candidates = candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() !== exceptTeamId;
        });
      }
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Вернёт набор возможных AA событий, которые подходят под эффект навыка
  // * ( с учётом кто его запускает userTeamId )
  _.getAAEntitiesSetDependsSkill = function(userTeamId, aaSkill) {
    var candidates, e;
    try {
      candidates = this.collectAllABSEntitiesOnMap();
      if (userTeamId === -1) { // * Все в таком случае
        return candidates;
      }
      if (aaSkill.isForEnemiesOnly()) {
        return candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() !== userTeamId;
        });
      } else if (aaSkill.isForFriendsOnly()) {
        return candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() === userTeamId;
        });
      } else {
        return candidates; // * Все в таком случае
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Получить сущности в радиусе (из набора сущностей)
  _.getFilteredInRadius = function(point, radius, candidates) {
    var c, e, k, len, members;
    members = [];
    try {
      for (k = 0, len = candidates.length; k < len; k++) {
        c = candidates[k];
        if (this.isCharExtInRadius(point, radius, c)) {
          members.push(c);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  // * Находится ли персонаж (точка) в радиусе (с учётом расширенных HitBox)
  _.isCharExtInRadius = function(point, radius, char) {
    var e, k, len, p, points;
    try {
      points = $gameMap.aaGetExtendedPointsFor(char);
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gameMap.distance(point.x, point.y, p.x, p.y) <= radius) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Получить дистанцию между персонажем и точкой (на экране)
  // * Учитываются расширенные HitBox
  _.getScreenExtDistance = function(char, offsetY, x2, y2) {
    var dist, e, k, l, len, len1, screenXs, screenYs, x, y;
    try {
      if (char == null) {
        return 1000;
      }
      if (char.aaIsHaveExtendedHitBoxes()) {
        screenXs = char.screenXExt();
        screenYs = char.screenYExt();
        dist = [];
        for (k = 0, len = screenXs.length; k < len; k++) {
          x = screenXs[k];
          for (l = 0, len1 = screenYs.length; l < len1; l++) {
            y = screenYs[l];
            dist.push(AA.Utils.Math.getXYDistance(x, y - offsetY, x2, y2));
          }
        }
        return dist.min();
      } else {
        return AA.Utils.Math.getXYDistance(char.screenX(), char.screenY() - offsetY, x2, y2);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return 1000;
    }
  };
  // * Цель подходящая (проверки, см. BattleManagerABS.isValidTarget)
  //TODO: isValidTarget
  _.isValidTarget = function(targetChar) {
    return (targetChar != null) && targetChar.isActive() && targetChar.AABattler().isAlive();
  };
  // * Находится ли точка (цель) в области дейтсвия навыка (range)
  _.isInSkillRange = function(char, skillId, targetPoint) {
    var dataObj, dist, e, skill;
    try {
      //TODO: ПОка просто
      dist = char.distToCol(targetPoint);
      dataObj = AA.Utils.getAASkillObject(skillId);
      skill = dataObj.AASkill;
      //console.log("D " + dist)
      //console.log("R " + skill.range)
      return dist <= skill.gRange();
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  // * Получить всех ботов, которые имеют игрока своей целью
  //TODO: TeamID учёт
  // * На данный момент не проверяется кто именно цель, так как нету сопартийцев и teamId
  _.getAllWhoHavePlayerAsTarget = function() {
    return $gameMap.eventsAA().filter(function(e) {
      return e.AAEntity().isHasTarget();
    });
  };
  // * Получить всех "врагов", которые имеют целью игрока с учётом радиуса
  _.getAllWhoHavePlayerAsTargetInRange = function(range) {
    var candidates;
    candidates = this.getAllWhoHavePlayerAsTarget();
    if (candidates.length > 0) {
      candidates = AATargetsManager.getFilteredInRadius($gamePlayer, range, candidates);
    }
    return candidates;
  };
  // * Применение доп. проверок и условий навыка на целях (например параметр usableIfTargetState)
  //? Вызывается на AABattleActionsManager в конце
  _.applyExtraSkillConditions = function(char, targets, absSkill) {
    var e;
    try {
      if (absSkill.isHaveTargetLimit() && targets.length > 1) {
        targets = this.applySkillTargetsLimit(subject, targets, absSkill);
      }
      if (absSkill.isRequireStateOnTarget()) {
        targets = targets.filter(function(t) {
          return (t != null) && t.AABattler().isStateAffected(absSkill.gUsableIfTargetState());
        });
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return targets;
  };
  // * Применить параметры targetLimit и targetLimitType для навыка
  //? Вызывается на AABattleActionsManager в конце
  _.applySkillTargetsLimit = function(char, targets, absSkill) {
    var e, targetLimit, targetType;
    try {
      targetLimit = absSkill.gTargetLimit();
      if (targetLimit <= 0) {
        // * Если нет лимита, то все цели и возвращаем
        return targets;
      }
      targetType = absSkill.getETargetLimitType();
      if (targetType > 0 && (char != null) && (char.x != null) && (char.y != null)) {
        // * Сортировка по возрастанию расстояния
        targets.sort(function(a, b) {
          var distA, distB, x, y;
          ({x, y} = char);
          distA = AA.Utils.Math.getXYDistance(a.x, a.y, x, y);
          distB = AA.Utils.Math.getXYDistance(b.x, b.y, x, y);
          //distA = $gameMap.distance(a.x, a.y, x, y)
          //distB = $gameMap.distance(b.x, b.y, x, y)
          return distA - distB;
        });
        // * Если надо дальнюю, то перевернём массив, так как выбираются первые цели
        if (targetType > 1) { // * far
          targets = targets.reverse();
        }
      } else {
        targets.shuffle();
      }
      return targets.slice(0, targetLimit);
    } catch (error) {
      e = error;
      AA.w(e);
      return [targets[0]];
    }
  };
  // * Найти ближайшую цель для homing projectile снаряда
  _.findCandidateForHomingProjectile = function(char, aaSkill, point) {
    var candidates, e, userTeamId, whoSuitsSkill;
    try {
      //"TRY SERACH FOR TARGETS".p()
      userTeamId = char.AAEntity().teamId();
      whoSuitsSkill = this.getAAEntitiesSetDependsSkill(userTeamId, aaSkill);
      if ((whoSuitsSkill != null) && whoSuitsSkill.length > 0) {
        candidates = this.getFilteredInRadius(point, 2, whoSuitsSkill);
        candidates.delete(char);
        if (candidates.length > 0) {
          return candidates.sample();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Основной класс менеджер интерфейса (API)
AA.UI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AA.UI.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UI;
  // * Методы пред подготовки (возможно uiSet ещё даже не задан)
  _.init = function() {
    return this._subscribeForEvents();
  };
  _.setUI = function(uiSet) {
    this.uiSet = uiSet;
  };
  _.isValid = function() {
    return this.uiSet != null;
  };
  // * Когда появляется окно с сообщением
  _.onGameMessageStart = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.onGameMessageStart() : void 0;
  };
  //TODO: Опция, чтобы автоматически закрывать окно выбора навыков, когда появляется сообщение

  // * Когда заканчивается окно с сообщением
  _.onGameMessageEnd = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.onGameMessageEnd() : void 0;
  };
  // * Когда было нажатие мышки на какой-либо UI элемент
  _.isUITouched = function() {
    return false;
  };
  // * Вызывается когда сцена карты заканчивается
  _.terminate = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.terminate() : void 0;
  };
  (function() {    // * Основной интерфейс Spriteset_UI
    // -----------------------------------------------------------------------
    _.refresh = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.refresh() : void 0;
    };
    _.refreshElement = function(tag) {
      var ref, ref1;
      if ((ref = this.uiSet) != null) {
        ref.refreshElement(tag);
      }
      if ((ref1 = this.uiSet) != null) {
        ref1.refreshController(tag);
      }
    };
    /*_.refreshAllElements = () ->
    return unless @uiSet?
    try
        user = $gameSystem.aaGetUserUISettings()
        for e in @uiSet.elements
            if e? and String.any(e.tag) and user.isHaveFor(e.tag)
                @refreshElement(e.tag)
    catch e
        AA.w e
    return*/
    _.hide = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.hide() : void 0;
    };
    _.show = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.show() : void 0;
    };
    // * Если какой-либо UI элемент обрабатывает нажатие курсора, то true
    _.isAnyUIElementTouchProcess = function() {
      // * Обработка окна выбора навыков
      if (this._isSkillSelectorProcessHandler()) {
        return true;
      } else {
        return false;
      }
    };
    return _.addToUI = function(element) {
      if (this.uiSet == null) {
        return;
      }
      if (element == null) {
        return;
      }
      return this.uiSet.addChild(element);
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Набор навыков
    // -----------------------------------------------------------------------
    // * Открыть окно выбора навыка для слота (символа)
    _.openSkillSelectorFor = function(symbol) {
      var cntrl, e, item;
      if (!this.isValid()) {
        return;
      }
      try {
        if (symbol == null) {
          return this.closeSkillSelector();
        } else {
          cntrl = this.uiSet.getController("skills");
          item = cntrl._getItemForSymbol(symbol);
          if (item != null) {
            return this.uiSet.fwSkillsSelector.prepareAndOpenForSlot(item);
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Открыто ли окно выбора навыка
    _.isSkillSelectorOpen = function() {
      var e;
      if (!this.isValid()) {
        return;
      }
      try {
        return this.uiSet.fwSkillsSelector.isOpen();
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return false;
    };
    _.closeSkillSelector = function() {
      var e;
      if (!this.isValid()) {
        return;
      }
      try {
        this.uiSet._terminateSkillSelectorWindow();
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    // * Когда игрок нажал на кнопку какого-либо навыка на панели навыков
    _.skillPerformResult = function(skillId, result) {
      var cntrl, e;
      try {
        if (!this.isValid()) {
          return;
        }
        cntrl = this.uiSet.getController("skills");
        return cntrl != null ? cntrl.onSkillPerformResult(skillId, result) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Если открыто окно выбора навыка для слота, то оно закрывается сперва
    // * Если правой кнопкой по навыку, то открывается окно
    _._isSkillSelectorProcessHandler = function() {
      var e, ref;
      if (!this.isValid()) {
        return false;
      }
      try {
        return (ref = this.uiSet.getController("skills")) != null ? ref.handleSkillSelectorProcess() : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Символ элемента панели навыков под курсором
    // * Используется для перетаскивания предметов из инвентаря на панель навыков
    return _.getSkillSymbolUnderMouse = function() {
      var e, item, ref;
      try {
        item = (ref = this.uiSet.getController("skills")) != null ? ref.getItemUnderMouse() : void 0;
        if (item != null) {
          return item.symbol;
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Выбор зоны применения навыка на карте
    // -----------------------------------------------------------------------
    // * Установить спрайт зоны поражаения навыка
    _.setSkillImpactSelector = function(skillSelector) {
      this.skillSelector = skillSelector;
    };
    // * Активировать зону поражения (показать спрайт)
    _.activateSkillImpactSelector = function(aaSkill) {
      var ref;
      return (ref = this.skillSelector) != null ? ref.activate(aaSkill) : void 0;
    };
    // * Эффект тряски (когда нажатие за зону поражения)
    _.shakeSkillImpactSelector = function() {
      var ref;
      return (ref = this.skillSelector) != null ? ref.shake() : void 0;
    };
    return _.resetSkillImpactSelector = function() {
      var ref;
      return (ref = this.skillSelector) != null ? ref.deactivate() : void 0;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Обработка АБС событий
    // -----------------------------------------------------------------------
    _._subscribeForEvents = function() {
      return AA.EV.subscribeFor("PlayerSkillSelector", this.gev_onPlayerSkillSelector);
    };
    _.gev_onPlayerSkillSelector = function() {
      if ($gamePlayer.isInSkillTargetingState()) {
        return AA.UI.activateSkillImpactSelector($gamePlayer.activeAASkill());
      } else {
        return AA.UI.resetSkillImpactSelector();
      }
    };
  })();
})();

// ■ END AA.UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Менеджер по работе с визорами АИ
var AAVisionManager;

AAVisionManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AAVisionManager;
  // * Проверка видимости между визором (событием) и точкой (TRUE - видно точку)
  _.isVisionLineIsFree = function(visor, endPoint) {
    var allPoints, betweenPoints, dist, e, eP, j, l, len, len1, p, sP;
    try {
      dist = $gameMap.distance(visor.x, visor.y, endPoint.x, endPoint.y);
      if (dist <= 1) {
        // * Если дистанция 1 (рядом), то значит на линии видимости не может быть помех
        return true;
      }
      // * Количество точек проверок на линии
      // * Хватит точности 1 к 1, поэтому количество точек = дистанции
      allPoints = this.getLineBetweenTwoPoints(visor, endPoint, dist);
      betweenPoints = [];
      // * Убираем End и Start точки с результата
      // * Нам важно проверить путь между начальной и конечной точкой
      sP = [visor.x, visor.y];
      eP = [endPoint.x, endPoint.y];
      for (j = 0, len = allPoints.length; j < len; j++) {
        p = allPoints[j];
        if (!AA.Utils.isSamePointA(p, sP) && !AA.Utils.isSamePointA(p, eP)) {
          betweenPoints.push(p);
        }
      }
      if (betweenPoints.length === 0) {
        
        // * Если между нет точек, то значит на линии видимости
        return true;
      }

      //console.log(betweenPoints)
      for (l = 0, len1 = betweenPoints.length; l < len1; l++) {
        p = betweenPoints[l];
        // * Если в точке находится объект (зона), что мешает зрению, значит false
        if (this.isPointIsColiderForVision(visor, p[0], p[1])) {
          return false;
        }
      }
      return true;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Возвращает линию из точек между начальной и конечной точкой (включая начальную и конечную)
  _.getLineBetweenTwoPoints = function(startPoint, endPoint, precission) {
    var cpx, cpy, e, eX, eY, i, j, k, points, px, py, ref, sX, sY, tw;
    try {
      tw = $gameMap.tileWidth();
      sX = Number(startPoint.x * tw + tw / 2);
      sY = Number(startPoint.y * tw + tw / 2);
      eX = Number(endPoint.x * tw + tw / 2);
      eY = Number(endPoint.y * tw + tw / 2);
      points = [];
      for (i = j = 1, ref = precission; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
        k = i / precission;
        px = k * (eX - sX) + sX;
        py = k * (eY - sY) + sY;
        cpx = Math.floor(px / $gameMap.tileWidth());
        cpy = Math.floor(py / $gameMap.tileHeight());
        points.push([cpx, cpy]);
      }
      return points;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return [];
  };
  // * Находится ли в данной точке карты что-либо, что мешает видимости
  // * TRUE - нельзя "видеть" через эту точку
  _.isPointIsColiderForVision = function(visor, x, y) {
    var e, events, model, noVisionRegions, noVisionTerrains;
    try {
      model = visor.AAModel();
      noVisionRegions = AA.PP.getVisionRestrictedRegions().concat(model.noPassVisionRegions);
      noVisionTerrains = AA.PP.getVisionRestrictedTerrains().concat(model.noPassVisionTerrains);
      if (noVisionRegions.contains($gameMap.regionId(x, y))) {
        return true;
      }
      if (noVisionTerrains.contains($gameMap.terrainTag(x, y))) {
        return true;
      }
      // * События с расширенными HitBox участвуют в области видимости
      events = $gameMap.eventsXyExt(x, y);
      if (events.isEmpty()) {
        return false;
      }
      // * Если хоть один блокирует, то значит заблокирована видимость
      return events.some(function(e) {
        return e.aaIsBlockVision();
      });
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return true;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Состояние АИ
var AIFlow;

AIFlow = class AIFlow extends AIFlowMachine {
  constructor() {
    super(...arguments);
    // * Состояние в режиме ожидания
    this.paused = false;
    this.translatedFrom = -1;
    return;
  }

  update() {
    super.update();
    return this._updateFlow();
  }

  prepare(inputData) { // * EMPTY
    this.inputData = inputData;
  }

  onStateStart() {} // * EMPTY

  onStateEnd() {} // * EMPTY

  
    // * При "переходе" в это состояние
  // * Поддерживает инициацию, если не было паузы
  // * Запоминает номер состояния после которого был запущен
  onStateResume(translatedFrom) { // * EMPTY
    this.translatedFrom = translatedFrom;
  }

  
    // * При "переходе" в другое состояние
  onStatePause() {} // * EMPTY

};

(function() {  
  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AIFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AIFlow.prototype;
  _._updateFlow = function() {};
})();

// ■ END AIFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Состояние боя для АИ союзника
var AllyAI_BattleFlow;

AllyAI_BattleFlow = class AllyAI_BattleFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  char() {
    return AllyAI_FlowMachine.prototype.char.call(this);
  }

  target() {
    return this.entity().getTarget();
  }

  moveType() {
    return this.model().getInBattleMoveType();
  }

  isCantMove() {
    return this.moveType() === 'stay';
  }

  isSupportMode() {
    return this._isBattleMode === false;
  }

  onStateStart() {
    "START BATTLE STATE".p();
    this.char().aaStoreHomePoint();
    // * Таймер новой проверки цели (Best)
    this._refreshTargetCheckThread = 0;
    this._canFightNow = true;
    this._isBattleMode = true;
    if (!this.char().isMyEnemy(this.target())) {
      this._isBattleMode = false;
    }
    // * Таймер следующей выборки действия
    // * Когда действие было выбранно, идёт небольшая пауза
    // * перед следующей выборкой действия
    this._nextActionCheck = 0;
    // * Сколько раз АИ не смог найти нужное действие
    this._actionMakeAttempts = 0;
    if (this.model().gNoMoveInBattle() === 1) {
      this.char().aaSetMoveTypeStayStill();
    }
    console.log(this.target());
  }

  onStateEnd() {
    this.char().aaResetHomePoint();
    this.entity().resetBattle();
  }

  exitAILogic() {
    this.onStateEnd();
    this.logic().getStateFlow(0).exitAILogic();
  }

  // * Получить "другую" лучшую цель
  tryGetAnotherBestTarget() {
    return this.logic().switchToFreeState();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AllyAI_BattleFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AllyAI_BattleFlow.prototype;
  _._updateFlow = function() {
    if (this._canFightNow === true) {
      this._updateOutOfHomeFlow();
      if (this._isBattleMode === true) {
        this._updateMainBattleFlow();
      } else {
        this._updateMainSupportFlow();
      }
      this._updateRefreshTargetThread();
    } else {
      this._updateReturnToPlayerFlow();
    }
  };
  _._setCurrentAction = function(_currentAction) {
    this._currentAction = _currentAction;
    this._resetNextActionCheck();
  };
  _._resetCurrentAction = function() {
    this._currentAction = null;
    this._resetNextActionCheck();
  };
  _._isActionIsExists = function() {
    return this._currentAction != null;
  };
  // * Находится ли цель на расстроянии применения действия
  // TODO: Это бы учитывать ещё при выборе действия
  _._isActionInDistance = function() {
    return EnemyAI_BattleFlow.prototype._isActionInDistance.call(this);
  };
  _._executeAction = function() {
    return EnemyAI_BattleFlow.prototype._executeAction.call(this);
  };
  _._isProperRangeForCloseAction = function() {
    return EnemyAI_BattleFlow.prototype._isProperRangeForCloseAction.call(this, ...arguments);
  };
  _._resetNextActionCheck = function() {
    return this._nextActionCheck = 10;
  };
  // * MOVING ======================================================================
  _._movingCloserToTarget = function() {
    this._resetNextActionCheck();
    if (!this.isSupportMode()) {
      if (this.model().gNoApproach() === 1) {
        return;
      }
    }
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    this.char().aaSetMoveTypeApproachTarget();
  };
  _._waitForAction = function() {
    if (!this.isSupportMode()) {
      if (!this.model().gNoMoveInBattle()) {
        this.char().aaSetMoveTypeKeepBattleDistance();
      }
    }
    this._actionMakeAttempts++;
    if (this._actionMakeAttempts > 60) {
      this.tryGetAnotherBestTarget();
    }
  };
  // * Если отошёл слишком далеко от "дома", надо вернуться
  _._updateOutOfHomeFlow = function() {
    if (this._isTooFarFromHomePoint()) {
      return this._canFightNow = false;
    }
  };
  _._isTooFarFromHomePoint = function() {
    var e;
    try {
      if (typeof $gamePlayer === "undefined" || $gamePlayer === null) {
        return false;
      }
      return this.char().distTo($gamePlayer) > (this.model().gReturnRadius());
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._updateReturnToPlayerFlow = function() {
    if (this.char().distTo($gamePlayer) <= (this.model().gViewRadius() - 1)) {
      this._canFightNow = true;
      this._nextActionCheck = 120;
    } else {
      this.char().aaSetMoveTypeReturnToHomePoint();
    }
  };
  _._updateRefreshTargetThread = function() {
    this._refreshTargetCheckThread++;
    if (this._refreshTargetCheckThread >= this.model().getRefreshBattleTargetTimeMax()) {
      this._refreshTargetCheckThread = 0;
      this.tryGetAnotherBestTarget();
    }
  };
  // * BATTLE FLOW ==============================================================
  _._updateMainBattleFlow = function() {
    if (this._isTargetValid()) {
      if (this.isSupportMode()) {
        this._selectSupportActionToUse();
      } else {
        this._selectBattleActionToUse();
      }
      if (this._isActionIsExists()) {
        this._actionMakeAttempts = 0;
        if (this._isActionInDistance()) {
          this._executeAction();
          if (this.isSupportMode()) {
            // * В режиме поддержки, после выполнения действия, надо сразу делать поиск другой цели
            return this.tryGetAnotherBestTarget();
          }
        } else {
          return this._movingCloserToTarget();
        }
      } else {
        return this._waitForAction();
      }
    } else {
      return this.tryGetAnotherBestTarget();
    }
  };
  _._isTargetValid = function() {
    return this._isTargetInViewRadius() && AATargetsManager.isValidTarget(this.target());
  };
  _._isTargetInViewRadius = function() {
    return this.char().distTo(this.target()) <= (this.model().gViewRadius() + 1);
  };
  _._selectBattleActionToUse = function() {
    var bestAction, skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    skills = this._filterBattleSkills(this.battler().getUsableAASkills());
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        bestAction = this._selectBetterBattleActionForNow(skills);
        this._setCurrentAction(bestAction);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._filterBattleSkills = function(skills) {
    var supportSkills;
    supportSkills = this.model().getSupportSkillsList();
    skills = skills.filter(function(skill) {
      return skill.AASkill.isForEnemiesOnly();
    });
    if (supportSkills.length > 0) {
      skills = skills.filter(function(skill) {
        return !supportSkills.contains(skill.id);
      });
    }
    //TODO: PARTY UPD Навык, который атакует вокруг, надо доп. проверку делать
    return skills;
  };
  _._selectBetterBattleActionForNow = function(skills) {
    var method, priorityList;
    // * Пока что смотрим только по списку приоритетов
    priorityList = this.model().getBattleSkillsPriorityList();
    if (priorityList.length > 0) {
      method = function(a, b) {
        var indexOfSkillA, indexOfSkillB;
        indexOfSkillA = priorityList.indexOf(a.id);
        indexOfSkillB = priorityList.indexOf(b.id);
        // * Если индекса нет, то 100000 (т.е. в самый конец)
        if (indexOfSkillA < 0) {
          indexOfSkillA = 100000;
        }
        if (indexOfSkillB < 0) {
          indexOfSkillB = 100000;
        }
        return indexOfSkillA - indexOfSkillB;
      };
      skills.sort(method);
      return skills[0];
    } else {
      //TODO: PARTY UPD Более умный алгоритм?
      return skills.sample();
    }
  };
  // * SUPPORT FLOW ==============================================================
  _._updateMainSupportFlow = function() {
    return this._updateMainBattleFlow();
  };
  _._selectSupportActionToUse = function() {
    var bestAction, skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    skills = this._filterSupportSkills(this.battler().getUsableAASkills());
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        bestAction = this._selectBetterSupportActionForNow(skills);
        this._setCurrentAction(bestAction);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._filterSupportSkills = function(skills) {
    var supportSkills;
    supportSkills = this.model().getSupportSkillsList();
    skills = skills.filter(function(skill) {
      return skill.AASkill.isForFriends();
    });
    if (supportSkills.length > 0) {
      skills = skills.filter(function(skill) {
        return supportSkills.contains(skill.id);
      });
    }
    //TODO: Навык, который лечет вокруг, надо доп. проверку делать
    return skills;
  };
  _._selectBetterSupportActionForNow = function(skills) {
    var method, priorityList;
    // * Пока что смотрим только по списку приоритетов
    priorityList = this.model().getSupportSkillsList();
    if (priorityList.length > 0) {
      method = function(a, b) {
        var indexOfSkillA, indexOfSkillB;
        indexOfSkillA = priorityList.indexOf(a.id);
        indexOfSkillB = priorityList.indexOf(b.id);
        // * Если индекса нет, то 100000 (т.е. в самый конец)
        if (indexOfSkillA < 0) {
          indexOfSkillA = 100000;
        }
        if (indexOfSkillB < 0) {
          indexOfSkillB = 100000;
        }
        return indexOfSkillA - indexOfSkillB;
      };
      skills.sort(method);
      return skills[0];
    } else {
      //TODO: PARTY UPD Более умный алгоритм? Надо учитывать параметр модели: healInPriority
      return skills.sample();
    }
  };
})();

// ■ END AllyAI_BattleFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ союзников на карте
var AllyAI_FlowMachine;

AllyAI_FlowMachine = class AllyAI_FlowMachine extends AIFlowMachine {
  constructor() {
    super(...arguments);
    this.registerFlowForState(0, new AllyAI_FreeFlow(this.id));
    this.registerFlowForState(1, new AllyAI_BattleFlow(this.id));
    // * Начальное состояние - свободное
    this.switchToFreeState();
    return;
  }

  switchToFreeState() {
    return this.setState(0);
  }

  switchToBattleState() {
    return this.setState(1);
  }

  isFreeState() {
    return this.state === 0;
  }

  isBattleState() {
    return this.state === 1;
  }

  char() {
    return $gamePlayer.followers().aaGetFollowerByActorId(this.id);
  }

};


// Generated by CoffeeScript 2.6.1
// * Свободное состояние для АИ союзника
// * В данном состоянии АИ определяет цель (ищет её)
var AllyAI_FreeFlow;

AllyAI_FreeFlow = class AllyAI_FreeFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  char() {
    return AllyAI_FlowMachine.prototype.char.call(this);
  }

  // * Выполняется каждый раз при переходе в это состояние
  onStateStart() {
    "START FREE STATE".p();
    this._currentBestTarget = null;
    this._currentBestTargetSP = null; // * support
    this._currentTargetTypeToFind = 0; // * 0 - battle, 1 - support
    // * Общее время на поиск лучшей цели
    // * Если цель не найдена, выходим из АИ логики
    this._freeFlowCommonTimer = 0;
    this._targetSearchTimer = 0;
  }

  // * Выполняется каждый раз при выходе из этого состояния
  onStateEnd() {
    this._freeFlowCommonTimer = 0;
    return this._targetSearchTimer = 0;
  }

  isHaveBestBattleTarget() {
    return this._currentBestTarget != null;
  }

  isHaveBestSupportTarget() {
    return this._currentBestTargetSP != null;
  }

  exitAILogic() {
    this.onStateEnd();
    this.char().aaForceResetAILogicState();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AllyAI_FreeFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  // * Выполняется один раз при создании объекта (в конструкторе)
  _._setup = function() {};
  //TODO: Выбор двух целей (support и battle и уже выбор одной потом)
  _._updateFlow = function() {
    if (this._targetSearchTimer === 0) {
      this._updateTargetSearchFlow();
    }
    this._targetSearchTimer++;
    if (this._freeFlowCommonTimer >= 5) {
      this._targetSearchTimer = 0;
    }
    this._freeFlowCommonTimer++;
    if (this._freeFlowCommonTimer >= 11) {
      this._freeFlowCommonTimer = 0;
      this.exitAILogic();
    }
  };
  _._updateTargetSearchFlow = function() {
    if (this._currentTargetTypeToFind === 0) {
      this._updateBattleTargetSearch();
    } else {
      this._updateSupportTargetSearch();
    }
  };
  _._onBattleTargetFound = function(t) {
    // * Если поддержка не в приоритете и есть цель для боя, сразу её выбираем
    if ((t != null) && !this.model().isSupportInPriority()) {
      this._onFinalTargetFound(t);
      return;
    }
    if (this.model().isCanSupport()) {
      // * Теперь смотрим цель для support действия
      this._currentTargetTypeToFind = 1;
    } else {
      if (t != null) {
        // * Не поддерживает поддержку, т.е.сразу одна цель (бой)
        this._onFinalTargetFound(t);
      }
    }
  };
  _._onSupportTargetFound = function(t) {
    // * Если Support в приоритете и есть цель, то Support цель
    if ((t != null) && this.model().isSupportInPriority()) {
      this._onFinalTargetFound(t);
      return;
    }
    // * Если есть боевая цель, то сразу её
    if (this.isHaveBestBattleTarget()) {
      this._onFinalTargetFound(this._currentBestTarget);
      return;
    }
    // * Если есть цель Support, то её
    if (t != null) {
      this._onFinalTargetFound(t);
      return;
    }
    // * Иначе повторный поиск
    this._currentTargetTypeToFind = 0;
  };
  _._onFinalTargetFound = function(t) {
    this.entity().setTarget(t);
    this.logic().switchToBattleState();
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  _._updateSupportTargetSearch = function() {
    if (this.isHaveBestSupportTarget()) {
      return this._onSupportTargetFound(this._currentBestTargetSP);
    } else {
      this._currentBestTargetSP = this._trySelectBestSupportTarget();
      if (!this.isHaveBestSupportTarget()) {
        // * Не может быть любой цели для поддержки (только по критериям!)
        "SELECT NO ANY SUPPORT TARGET (null)".p();
        this._onSupportTargetFound(null);
      } else {
        "BEST SUPPORT TARGET FOUND".p();
      }
    }
  };
  _._trySelectBestSupportTarget = function() {
    var e, target;
    try {
      target = this._trySelectBestSPTargetByCondition(1);
      if (target == null) {
        target = this._trySelectBestSPTargetByCondition(2);
      }
      if (target == null) {
        target = this._trySelectBestSPTargetByCondition(3);
      }
      return target;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _._trySelectBestSPTargetByCondition = function(index) {
    var condition, e;
    try {
      condition = this.model().getBestSupportTargetCondition(index);
      if (String.any(condition)) {
        return this._tryFindSupportTargetByCondition(condition);
      } else {
        return null;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _._tryFindSupportTargetByCondition = function(conditionString) {
    var candidates, e, filterResultString, i, len, target, targetsAround;
    console.log("CONDITION STRING RAW: " + conditionString);
    if (conditionString === "any" || !String.any(conditionString)) {
      return this._trySelectAnySupportTarget();
    } else if (conditionString === "none") {
      return null;
    } else {
      targetsAround = this._getAllTargetsForSupportAround();
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      candidates = [];
      for (i = 0, len = targetsAround.length; i < len; i++) {
        target = targetsAround[i];
        filterResultString = this._applyFiltersToSupportTargetCandidate(target, conditionString);
        try {
          if (eval(filterResultString)) {
            candidates.push(target);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      if (candidates.length > 0) {
        return this._tryFilterSupportTargetByGroupCondition(candidates);
      }
    }
    return null;
  };
  _._trySelectAnySupportTarget = function() {
    var availabledTargets;
    availabledTargets = this._getAllTargetsForSupportAround();
    if (availabledTargets.length > 0) {
      return this._tryFilterSupportTargetByGroupCondition(availabledTargets);
    }
    return null;
  };
  _._getAllTargetsForSupportAround = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableAlliesInRadius(this.char(), this.model().gViewRadius());
      //  * Пропустим линию видимости пока что (не особо важно)
      //targetsAround = targetsAround.filter (t) => AAVisionManager.isVisionLineIsFree(@char(), t)
      console.log(targetsAround);
      return targetsAround;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _._applyFiltersToSupportTargetCandidate = function(target, conditionString) {
    var e, i, item, len, method, ref;
    try {
      ref = ['none', 'any', 'damaged', 'full', 'player', 'ally', 'self', 'other', 'lowHp', 'partyMember', 'condition'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAIConditionForSupport_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this, target).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  // * Нет групповых фильтров
  _._tryFilterSupportTargetByGroupCondition = function(targets) {
    return targets.sample();
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  // * TARGET (SINGLE) CONDITIONS ================================================
  _._aaAICondition_any = function(t) {
    return true;
  };
  _._aaAICondition_none = function(t) {
    return false;
  };
  _._aaAICondition_condition = function(t) {
    var condition, e;
    try {
      condition = this.model().getBestTargetUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.battler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        condition = condition.replaceAll("t.", "t.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_full = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() === 1;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_damaged = function(t) {
    return !this._aaAICondition_full(t);
  };
  _._aaAICondition_playerTarget = function(t) {
    var e;
    try {
      if ((t != null) && $gameTemp._aaPartyAI_flag_playerAttackSomeone > 0) {
        return (t.eventId != null) && t.eventId() === $gameTemp._aaPartyAI_flag_playerAttackSomeone;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_playerOpponent = function(t) {
    var e;
    try {
      return (t != null) && t.AAEntity().getTarget() === $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_notMyOpponent = function(t) {
    var e;
    try {
      return !this._aaAICondition_myOpponent(t);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_myOpponent = function(t) {
    var e;
    try {
      return (t != null) && t.AAEntity().getTarget() === this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  // * GROUP CONDITIONS ===========================================================
  // * Данные методы возвращают объект target, а не Bool!
  // * Подразумевается что массив targets уже прошёл проверку на null, 0 и 1 (count)
  _._aaAIConditionGroup_nearest = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = this.char());
      method = function(a, b) {
        var distToA, distToB;
        distToA = AA.Utils.Math.getXYDistance(x, y, a.x, a.y);
        distToB = AA.Utils.Math.getXYDistance(x, y, b.x, b.y);
        return distToA - distToB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_further = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = this.char());
      method = function(a, b) {
        var distToA, distToB;
        distToA = AA.Utils.Math.getXYDistance(x, y, a.x, a.y);
        distToB = AA.Utils.Math.getXYDistance(x, y, b.x, b.y);
        return distToB - distToA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_weakest = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var valA, valB;
        valA = a.AABattler().atk;
        valB = b.AABattler().atk;
        return valA - valB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_strongest = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var valA, valB;
        valA = a.AABattler().atk;
        valB = b.AABattler().atk;
        return valB - valA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_lowHp = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var hpA, hpB;
        hpA = a.AABattler().hp;
        hpB = b.AABattler().hp;
        return hpA - hpB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_highHp = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var hpA, hpB;
        hpA = a.AABattler().hp;
        hpB = b.AABattler().hp;
        return hpB - hpA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_nearestToPlayer = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = $gamePlayer);
      method = function(a, b) {
        var distToA, distToB;
        distToA = AA.Utils.Math.getXYDistance(x, y, a.x, a.y);
        distToB = AA.Utils.Math.getXYDistance(x, y, b.x, b.y);
        return distToA - distToB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_furtherFromPlayer = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = $gamePlayer);
      method = function(a, b) {
        var distToA, distToB;
        distToA = AA.Utils.Math.getXYDistance(x, y, a.x, a.y);
        distToB = AA.Utils.Math.getXYDistance(x, y, b.x, b.y);
        return distToB - distToA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  
  // * TARGET (SINGLE, SUPPORT) CONDITIONS ================================================
  _._aaAIConditionForSupport_none = function(t) {
    return false;
  };
  _._aaAIConditionForSupport_any = function(t) {
    return true;
  };
  _._aaAIConditionForSupport_damaged = function(t) {
    return !this._aaAIConditionForSupport_full(t);
  };
  _._aaAIConditionForSupport_full = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() === 1;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAIConditionForSupport_player = function(t) {
    var e;
    try {
      return t === $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_ally = function(t) {
    var e;
    try {
      return t !== $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_self = function(t) {
    var e;
    try {
      return t === this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_other = function(t) {
    var e;
    try {
      return t !== this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_lowHp = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() < 0.2;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_partyMember = function(t) {
    var e;
    try {
      return $gamePlayer.aaGetABSFollowers().contains(t);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_condition = function(t) {
    var condition, e;
    try {
      condition = this.model().getBestSupportTargetUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.battler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        condition = condition.replaceAll("t.", "t.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  _._updateBattleTargetSearch = function() {
    if (this.isHaveBestBattleTarget()) {
      return this._onBattleTargetFound(this._currentBestTarget);
    } else {
      this._currentBestTarget = this._trySelectBestTarget();
      if (!this.isHaveBestBattleTarget()) {
        this._onBattleTargetFound(null);
      } else {
        "BEST TARGET FOUND".p();
      }
    }
  };
  
  // * Смотрим три условия
  _._trySelectBestTarget = function() {
    var target;
    target = this._trySelectBestTargetByCondition(1);
    if (target == null) {
      target = this._trySelectBestTargetByCondition(2);
    }
    if (target == null) {
      target = this._trySelectBestTargetByCondition(3);
    }
    return target;
  };
  _._trySelectBestTargetByCondition = function(index) {
    var condition;
    condition = this.model().getBestTargetCondition(index);
    if (String.any(condition)) {
      return this._tryFindTargetByCondition(condition);
    } else {
      return null;
    }
  };
  _._tryFindTargetByCondition = function(conditionString) {
    var candidates, e, filterResultString, i, len, target, targetsAround;
    console.log("CONDITION STRING RAW: " + conditionString);
    if (conditionString === "any" || !String.any(conditionString)) {
      return this._trySelectAnyTarget();
    } else if (conditionString === "none") {
      return null;
    } else {
      targetsAround = this._getAllTargetsAround();
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      candidates = [];
      for (i = 0, len = targetsAround.length; i < len; i++) {
        target = targetsAround[i];
        filterResultString = this._applyFiltersToTargetCandidate(target, conditionString);
        try {
          if (eval(filterResultString)) {
            candidates.push(target);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      if (candidates.length > 0) {
        return this._tryFilterTargetByGroupCondition(candidates);
      }
    }
    return null;
  };
  _._applyFiltersToTargetCandidate = function(target, conditionString) {
    var e, i, item, len, method, ref;
    try {
      ref = ['any', 'none', 'condition', 'damaged', 'full', 'playerTarget', 'playerOpponent', 'notMyOpponent', 'myOpponent'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAICondition_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this, target).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  _._tryFilterTargetByGroupCondition = function(targets) {
    var condition, e;
    try {
      condition = this.model().getBestTargetGroupCondition();
      if (targets.length === 1 || !String.any(condition)) {
        return targets.sample();
      }
      return this._applyTargetsGroupFilters(targets, condition);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._applyTargetsGroupFilters = function(targets, conditionString) {
    var available, bestInGroup, e, method;
    try {
      bestInGroup = null;
      available = ['nearest', 'further', 'weakest', 'strongest', 'lowHp', 'highHp', 'nearestToPlayer', 'furtherFromPlayer'];
      if (available.contains(conditionString)) {
        method = this['_aaAIConditionGroup_' + conditionString];
        if (method != null) {
          bestInGroup = method.call(this, targets);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
    return bestInGroup;
  };
  _._trySelectAnyTarget = function() {
    var availabledTargets;
    availabledTargets = this._getAllTargetsAround();
    if (availabledTargets.length > 0) {
      return this._tryFilterTargetByGroupCondition(availabledTargets);
    }
    return null;
  };
  _._getAllTargetsAround = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      // * Для улучшения производительности, пропустим проверку линии обзора
      //targetsAround = targetsAround.filter (t) => AAVisionManager.isVisionLineIsFree(@char(), t)
      return targetsAround;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__playBgm, _;
  //@[DEFINES]
  _ = AudioManager;
  //@[ALIAS]
  ALIAS__playBgm = _.playBgm;
  _.playBgm = function(bgm, pos) {
    var e, storedOne;
    $gameSystem.aaBattleBgmStarted = false;
    storedOne = $gameSystem.aaLoadBgmState(bgm.name);
    if ((storedOne != null) && storedOne > 0 && $gameTemp.__lastSavedBgmStateName !== bgm.name) {
      pos = storedOne;
    }
    try {
      ALIAS__playBgm.call(this, bgm, pos);
    } catch (error) {
      e = error;
      AA.w(e);
      ALIAS__playBgm.call(this, bgm, 0);
      return;
    }
    if (pos > 0) {
      this._bgmBuffer.fadeIn(0.5);
    }
  };
})();

// ■ END AudioManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AudioManager;
  _.aaSaveBgmState = function() {
    var data;
    data = AudioManager.saveBgm();
    if ((data != null) && data.name !== '' && (typeof $gameSystem !== "undefined" && $gameSystem !== null)) {
      $gameSystem.aaSaveBgmState(data.name, data.pos);
    }
  };
  _.aaPlayBattleBgm = function(name, delay = 0) {
    var bgm, e;
    try {
      console.log("Start Battle BGM");
      AudioManager.aaSaveBgmState();
      $gameSystem.aaStoreSuspendedMapBgm();
      bgm = {
        name: name,
        pan: 0,
        pitch: 100,
        volume: 90
      };
      if (delay > 0) {
        AudioManager.fadeOutBgm(delay / 60);
        return setTimeout((function() {
          AudioManager.playBgm(bgm);
          return $gameSystem.aaBattleBgmStarted = true;
        }), delay * 10);
      } else {
        AudioManager.stopBgs();
        AudioManager.stopBgm();
        AudioManager.playBgm(bgm);
        return $gameSystem.aaBattleBgmStarted = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaStopBattleBgm = function(delay = 0) {
    var e;
    try {
      console.log("Stop Battle BGM");
      if (!$gameSystem.aaBattleBgmStarted) {
        return;
      }
      $gameSystem.aaBattleBgmStarted = null;
      if (delay > 0) {
        AudioManager.fadeOutBgm(delay / 60);
        return setTimeout((function() {
          $gameSystem.aaRestoreSuspendedMapBgm();
          return AudioManager.fadeInBgm(delay / 60);
        }), delay * 10);
      } else {
        return $gameSystem.aaRestoreSuspendedMapBgm();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END AudioManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var BuffIconsController;
  // * Общий контроллер для отрисовки бафов персонажа (игрока)
  //?rev 17.10.20
  BuffIconsController = class BuffIconsController extends AA.UIElementController {
    // * buffSprites - Sprite_ActorStateIcon (массив)
    constructor(buffSprites) {
      super();
      this.buffSprites = buffSprites;
      this.maxCount = Math.min(this.buffSprites.length, 8);
    }

    // * Собирает индексы существующих баффов
    collectBuffs() {
      var buffs, i, j, k;
      buffs = [];
      for (i = j = 0; j < 8; i = ++j) {
        if (this.source._buffs[i] !== 0) {
          buffs.push(i);
        }
      }
      // * Если в режиме редактора, то добавляем ещё (недостающие) как Dummy
      // * Чтобы можно было видеть
      if (AA.System.isUIEditor()) {
        for (i = k = 0; k < 8; i = ++k) {
          buffs.push(1);
        }
      }
      return buffs;
    }

    
      // * Собирает все иконки бафов
    collectIcons() {
      var i, icons, j;
      icons = this.source.buffIcons();
      if (AA.System.isUIEditor()) {
        for (i = j = 0; j < 8; i = ++j) {
          icons.push(16);
        }
      }
      return icons;
    }

    // * Получает количество ходов (секунд) баффа
    collectBuffTurn(buffIndex) {
      return this.source._buffTurns[buffIndex];
    }

  };
  AA.link(BuffIconsController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.BuffIconsController.prototype;
  //$[OVER]
  _._setupThread = function() {
    return this.createThread(20, 4);
  };
  //$[OVER]
  _._refresh = function() {
    var buffs, i, icon, icons, j, ref, ref1, turns;
    buffs = this.collectBuffs();
    icons = this.collectIcons();
    for (i = j = 0, ref = this.maxCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      icon = icons[i];
      turns = this.collectBuffTurn(buffs[i]);
      if ((ref1 = this.buffSprites[i]) != null) {
        ref1.drawBuffInfo(icon, turns);
      }
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ConfigManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__applyData, ALIAS__makeData, _;
  //@[DEFINES]
  _ = ConfigManager;
  //@[ALIAS]
  ALIAS__makeData = _.makeData;
  _.makeData = function() {
    var config;
    config = ALIAS__makeData.call(this);
    config.aaUserUISettings = this.aaUserUISettings;
    return config;
  };
  
  //@[ALIAS]
  ALIAS__applyData = _.applyData;
  _.applyData = function(config) {
    ALIAS__applyData.call(this, config);
    this.aaUserUISettings = config.aaUserUISettings || {};
  };
})();

// ■ END ConfigManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__loadDataFile, ALIAS__loadDatabase, _;
  //@[DEFINES]
  _ = DataManager;
  DataManager._databaseFiles.push({
    name: "$aabsz_WeaponSkillExtensionSlot",
    src: "AABSZ/WeaponSkillExtensionSlot.json"
  });
  DataManager._databaseFiles.push({
    name: "$aabsz_SkillItemSelectorWindowSettings",
    src: "AABSZ/SkillItemSelectorWindowSettings.json"
  });
  // * Чтобы тест битвы из редактора работал
  //@[ALIAS]
  ALIAS__loadDataFile = _.loadDataFile;
  _.loadDataFile = function(name, src) {
    if (src.contains("AABSZ")) {
      src = src.replace("Test_", "");
    }
    return ALIAS__loadDataFile.call(this, name, src);
  };
  //@[ALIAS]
  ALIAS__loadDatabase = _.loadDatabase;
  _.loadDatabase = function() {
    ALIAS__loadDatabase.call(this);
    return this.aaLoadSpawnMap();
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  _.aaIsSpawnMapValid = function() {
    return typeof $dataAASpawnMap !== "undefined" && $dataAASpawnMap !== null;
  };
  _.aaLoadSpawnMap = function() {
    var filename, mapId;
    window.$dataAASpawnMap = null;
    mapId = AA.PP.getSpawnMapId();
    if (!(mapId > 0)) {
      return;
    }
    filename = 'Map%1.json'.format(mapId.padZero(3));
    this.loadDataFile('$dataAASpawnMap', filename);
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------
//"SPAWN MAP LOADED".p(mapId)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  DataManager._databaseFiles.push({
    name: "$aabsz_NUI_PlayerCastingProgressBar",
    src: "AABSZ/NUI_PlayerCastingProgressBar.json"
  });
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Состояние (машина) для врага в битве
var EnemyAI_BattleFlow;

EnemyAI_BattleFlow = class EnemyAI_BattleFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  target() {
    return this.entity().getTarget();
  }

  onStateStart() {
    //"IN BATTLE STATE".p()
    // * Таймер следующей выборки действия
    // * Когда действие было выбранно, идёт небольшая пауза
    // * перед следующей выборкой действия
    this._nextActionCheck = 0;
    // *
    this._canFightNow = true;
    // * Бот отступает из боя
    this._fleeFromBattle = false;
    if (this.model().gNoMoveInBattle() === 1) {
      this.char().aaSetMoveTypeStayStill();
    }
  }

  //TODO: change move type
  //TEMP: остановлю ботика
  //@char()._moveType = 0
  //@char().aaSetMoveTypeKeepBattleDistance()
  //TODO: filter skills
  onStateEnd() {
    //on char сделать метод основной
    this.entity().resetBattle();
    return this.char().aaOnTargetChanged();
  }

};

(function() {  //TODO: clear target and other stuff (onBattleEnd for battle etc)
  //"BATTLE END".p()

  // * onStateEnd нету, так как Free состояние базовое

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_BattleFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_BattleFlow.prototype;
  _._setup = function() {};
  
  //TODO: ЕСТЬ БАГ, если убить одного врага, другие не хотят сражаться, остаюстя в keep
  _._updateFlow = function() {
    if (this._canFightNow === true) {
      this._updateOutOfHomeFlow();
      return this._updateBattleFlow();
    } else {
      return this._updateFleeFlow();
    }
  };
  // * Если отошёл слишком далеко от "дома", надо вернуться
  _._updateOutOfHomeFlow = function() {
    if (this._isTooFarFromHomePoint()) {
      return this._canFightNow = false;
    }
  };
  _._isTooFarFromHomePoint = function() {
    var homePoint;
    homePoint = this.char().homePoint;
    if (homePoint == null) {
      return false;
    }
    return this.char().distTo(homePoint) > (this.model().gReturnRadius());
  };
  _._updateBattleFlow = function() {
    if (this._isInCastingProcess()) {
      this._updateInCastingProcess();
      return;
    }
    if (this._isTargetValid()) {
      this._selectActionToUse();
      if (this._isActionIsExists()) {
        if (this._isActionInDistance()) {
          return this._executeAction();
        } else {
          return this._movingCloserToTarget();
        }
      } else {
        return this._waitForAction();
      }
    } else {
      return this.logic().switchToFreeState();
    }
  };
  _._isTargetValid = function() {
    return this._isTargetInViewRadius() && AATargetsManager.isValidTarget(this.target());
  };
  //TODO: Сделать параметр SeekTime - когда цель вне видимости, какой-то время (в сек) всё равно преследовать
  // * или следовать в точку где последний раз видел
  // * Можно отдельное состояние (поиск по маршруту или случайно)
  // * Объеденить с системой слышымости (по сути это и есть - движение к источнику звука и патруль)
  _._isTargetInViewRadius = function() {
    return this.char().distTo(this.target()) <= (this.model().gViewRadius() + 1);
  };
  _._selectActionToUse = function() {
    var skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    //TODO: алгоритм выбора действия для использования сейчас
    skills = this.battler().getUsableAASkills();
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        this._selectBetterActionForNow(skills);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._setCurrentAction = function(_currentAction) {
    this._currentAction = _currentAction;
    //TODO: Надо это или нет?
    return this._nextActionCheck = 20;
  };
  _._selectBetterActionForNow = function(skills) {
    //TODO: Все навыки применить testApply и выбрать лучший + тот который
    // можно использовать без подхода к цели
    //TODO: пока просто первый возвращаем
    this._setCurrentAction(skills.first());
  };
  _._resetCurrentAction = function() {
    this._currentAction = null;
    this._nextActionCheck = 0;
  };
  _._isActionIsExists = function() {
    return this._currentAction != null;
  };
  // * Находится ли цель на расстроянии применения действия
  _._isActionInDistance = function() {
    var aaSkill, range;
    aaSkill = this._currentAction.AASkill;
    if (aaSkill.isSelfAction()) {
      // * Если для врагов, то проверим, что враг в области radius действия навыка
      if (aaSkill.isForEnemies()) {
        return AATargetsManager.isCharExtInRadius(this.char(), aaSkill.gRadius(), this.target());
      } else {
        return true;
      }
    } else {
      range = aaSkill.gRange();
      if (aaSkill.isInPoint() || this._isProperRangeForCloseAction(range)) {
        return AATargetsManager.isCharExtInRadius(this.char(), range, this.target());
      } else {
        // * Пока просто проверка расстояния
        //TODO: * Цель должна быть передо мной (на прямом направлении)
        // (см. inDirectionHard в Alpha ABS)
        return AATargetsManager.isCharExtInRadius(this.char(), range, this.target());
      }
    }
  };
  _._isProperRangeForCloseAction = function(range) {
    var e;
    try {
      if (AA.Input.IsDiagonalForAI === true) {
        // * range <= 1 тут используется, чтобы монстр мог ударить диагонально, но не больше 1 клетки
        return range <= 1;
      } else {
        return range < 1;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._executeAction = function() {
    var char, e;
    try {
      //TODO: Custom Attack Move Route
      //"EXECUTE".p()
      //TODO: EXECUTE ACITON !!!
      // * Дополнительная проверка ещё раз перед выполнением действия
      // * Это нужно, потому что АИ выбирает очередное действие после выбора через время
      // * см. @_nextActionCheck
      if (!this.battler().canUse(this._currentAction)) {
        return this._resetCurrentAction();
      } else {
        //"EEXECUTGE".p()
        char = this.char();
        char.setActiveAASkill(this._currentAction.idA);
        return char.startPerformAASkill(this.target());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._movingCloserToTarget = function() {
    if (this.model().gNoApproach() === 1) {
      return;
    }
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    //"APPROACH".p()
    return this.char().aaSetMoveTypeApproachTarget();
  };
  _._waitForAction = function() {
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    //"KEEP ".p()
    this.char().aaSetMoveTypeKeepBattleDistance();
  };
  // * Враг возвращается (отступает) к точке дом
  // * Пока не увидит дом (в View Radius)
  // * В отличии от Free State, точка дома не меняется, поэтому враг получается
  // * всегда будет держаться своего "дома" и сражаться в определённом радиусе
  //TODO: Custom Move Route?
  // * Задать параметр, чтобы АИ выполнял в бою customMoveRoute если нет навыков
  _._updateFleeFlow = function() {
    if (this.char().distTo(this.char().homePoint) <= (this.model().gViewRadius() - 1)) {
      this._canFightNow = true;
    } else {
      this.char().aaSetMoveTypeReturnToHomePoint();
    }
  };
  _._isInCastingProcess = function() {
    return this.char().aaInSkillCastingProcess();
  };
  _._updateInCastingProcess = function() {
    var e;
    try {
      if (!this._isActionInDistance()) {
        console.log("Casting Aborted by Action Distance");
        this.char().aaAbortSkillCastingProcess();
        return;
      }
      if (!this._isTargetInViewRadius()) {
        console.log("Casting Aborted by ViewRadius");
        this.char().aaAbortSkillCastingProcess();
        return;
      }
      //console.log("casting")
      return this.char()._aaUpdateCastingProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END EnemyAI_BattleFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ врагов на карте
var EnemyAI_FlowMachine;

EnemyAI_FlowMachine = class EnemyAI_FlowMachine extends AIFlowMachine {
  constructor() {
    super(...arguments);
    this.registerFlowForState(0, new EnemyAI_FreeFlow(this.id));
    this.registerFlowForState(1, new EnemyAI_BattleFlow(this.id));
    // * Начальное состояние - свободное
    this.switchToFreeState();
    return;
  }

  switchToFreeState() {
    return this.setState(0);
  }

  switchToBattleState() {
    return this.setState(1);
  }

  isFreeState() {
    return this.state === 0;
  }

  isBattleState() {
    return this.state === 1;
  }

};

(function() {  //TODO: search, return???
  //TODO: move

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_FlowMachine.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_FlowMachine.prototype;
})();

// ■ END EnemyAI_FlowMachine.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Свободное состояние для АИ враг
var EnemyAI_FreeFlow;

EnemyAI_FreeFlow = class EnemyAI_FreeFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  isCanUpdateVision() {
    if (this.model().activeOutOfScreen > 0) {
      return true;
    } else {
      return !this.char().aaIsOutOfScreen();
    }
  }

  onStateStart() {
    //"IN FREE STATE".p()
    this._restoreMoveData();
    this._isTargetInViewRadius = false;
  }

  onStateEnd() {
    //"FREE END".p()
    this._storeHomePoint();
  }

  tryStartFightWithTarget(target) {
    var e, targetsAround;
    try {
      if (target == null) {
        return;
      }
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      if (targetsAround.contains(target)) {
        return this._startFightWithTarget(target);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_FreeFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_FreeFlow.prototype;
  _._setup = function() {
    this._checkVisionTimer = 0;
    this._checkTargetInRangeTimer = 0;
  };
  _._updateFlow = function() {
    this._updateReturnToHome();
    //TODO: Временно отключим Visor для врагов, у которых нет АБС навыков вообще
    if (!this.battler().isHaveAnyAASkill()) {
      return;
    }
    return this._updateVision();
  };
  _._updateReturnToHome = function() {
    var char, e, homePoint;
    char = this.char();
    if (char == null) {
      return;
    }
    homePoint = char.homePoint;
    if (homePoint == null) {
      return;
    }
    try {
      if (char.aaIsNearThePoint(homePoint, 1)) {
        char.aaResetHomePoint(); // * Сброс точки "дома"
        this._restoreMoveData(); // * Выход из режима движения
      } else {
        char.aaSetMoveTypeReturnToHomePoint();
      }
    } catch (error) {
      e = error;
      this._restoreMoveData();
      AA.w(e);
    }
  };
  // * Используется двойная проверка. Сперва простая проверка, что цель в радиусе видимости
  // * Уже затем, если цель в радиусе, проверяется линия видимости
  _._updateVision = function() {
    if (!this.isCanUpdateVision()) {
      return;
    }
    //console.log("UPDA")
    // * Если цель в радиусе видимости
    if (this._isTargetInViewRadius === true) {
      // * То проверяем чтобы цель была в линии видиомости (нет препятствий)
      this._updateVisionLine();
    }
    // * В любом случае, проверяем снова, что цель в радиусе видимости
    return this._updateVisionRadius();
  };
  _._updateVisionRadius = function() {
    var targetsAround;
    this._checkVisionTimer++;
    if (this._checkVisionTimer >= AA.PP.getAIVisionUpdateIntervalFR()) {
      this._checkVisionTimer = 0;
      if (this.model().isTVision()) {
        targetsAround = AATargetsManager.getAvailableTargetsInTriangle(this.char(), this.model().gViewRadius(), this.model().gTVisor(), this.model().sideVisor);
      } else {
        targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      }
      this._isTargetInViewRadius = (targetsAround != null) && targetsAround.length > 0;
    }
  };
  //"TARGET IN RADIUS".p() if @_isTargetInViewRadius is true
  _._updateVisionLine = function() {
    var targetsAround;
    if (this._isTargetInViewRadius === false) {
      return;
    }
    this._checkTargetInRangeTimer++;
    if (this._checkTargetInRangeTimer >= 2) {
      this._checkTargetInRangeTimer = 0;
      // * Довольно сложный методы, можно вынести отедльно
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      if (targetsAround.length > 0) {
        targetsAround = targetsAround.filter((t) => {
          return AAVisionManager.isVisionLineIsFree(this.char(), t);
        });
        if (targetsAround.length > 0) {
          this._onSeeTarget(targetsAround.sample());
        }
      }
    }
  };
  _._onSeeTarget = function(target) {
    //"SEE TARGET IN LINE".p()
    //TODO: if enemy have actions, then switch to battle state
    if (this.battler().isHaveAnyAASkill() && !this.model().isNotAgressive()) {
      this._startFightWithTarget(target);
    } else {

    }
  };
  //TODO: if can't fight?
  //TODO: escapeFromBattle like (Типо отходить от игрока)
  // * Тоже самое поведение, что и если не может драться (noFight)
  //TODO: noFight - такого параметра не будет, хотите чтобы не дрался, не давайте действий
  _._startFightWithTarget = function(target) {
    var e;
    try {
      this.entity().setTarget(target);
      this.char().aaOnTargetChanged();
      if (this.model().isHaveOnSeeTargetAction()) {
        AA.SAaction.execute(this.model().onSeeTarget, this.char());
      }
      return this.logic().switchToBattleState();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Восстановить настройки движения, если они были сохраненны
  _._restoreMoveData = function() {
    var e, ref;
    try {
      //"RESTORE MOVE DATA".p()
      if ((ref = this.char()) != null) {
        ref.aaRestoreMoveData();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Сохранить позицию перед выходом из состояния
  _._storeHomePoint = function() {
    var ref;
    if ((ref = this.char()) != null) {
      ref.aaStoreHomePoint();
    }
  };
})();

// ■ END EnemyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var FWindow_SkillSelect;

FWindow_SkillSelect = class FWindow_SkillSelect extends KDCore.FloatingWindow {
  constructor() {
    super(...arguments);
  }

  getSettings() {
    return $aabsz_SkillItemSelectorWindowSettings;
  }

  // * Сдвинуть позицию окна с учётом позиции элемента Skills Panel
  moveRelativeSlotPosition(x, y) {
    var h2, m, sector, w2;
    // Screen sectors
    // 1 | 2
    // 3 | 4
    // ==============
    m = this.getSettings().windowFromEdgesMargin;
    sector = 1;
    w2 = Graphics.width / 2;
    h2 = Graphics.height / 2;
    
    // * Определяем сектор экрана, на котромнаходится элемент
    if (x < w2) {
      if (y < h2) {
        sector = 1;
      } else {
        sector = 3;
      }
    } else {
      if (y < h2) {
        sector = 2;
      } else {
        sector = 4;
      }
    }
    
    // * Настраиваем позиции в зависимости от секторов
    if (sector === 3 || sector === 1) {
      this.x = x;
    }
    if (sector === 2 || sector === 4) {
      this.x = x - this.width + m;
    }
    if (sector >= 3) {
      this.y = y - this.height;
    } else {
      this.y = y + m + 2;
    }
  }

  
    // * Подготовить окно и октрыть для элемента Skills Panel
  // * slotItem = Sprite_SKillPanelItem
  prepareAndOpenForSlot(slotItem) {
    var symbol, x, y;
    ({x, y, symbol} = slotItem);
    this.moveRelativeSlotPosition(x, y);
    // * Тут всегда категория 0 по умолчанию
    this.refreshSkillList(0, symbol);
    this.open();
  }

  // * Создание списка навыков для группы
  // * Этот метод вызывается когда окно открывается для слота
  refreshSkillList(category, symbol) {
    if (this.skillsList == null) {
      return;
    }
    // * Запоминаем символ, чтобы установить навык при выборе
    this.skillsList.setSymbol(symbol);
    // * При смене категории список формируется (т.е. refresh)
    this.changeCategory(0);
  }

  changeCategory(category) {
    var e;
    try {
      this._refreshCategoryButtons(category);
      this._refreshHeader(category);
      return this.skillsList.setCategory(category);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  // * Данное окно (выбор навыков и вещей) нельзя двигать
  //$[OVER]
  //isDraggable: -> false
  //TODO: или можно?
  update() {
    super.update();
    return this._updateSkillSelectClick();
  }

  _afterClose() {
    this.buttonCat0.visible = false;
    return this.buttonCat1.visible = false;
  }

  _afterOpen() {
    this.buttonCat0.visible = true;
    return this.buttonCat1.visible = true;
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ FWindow_SkillSelect.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = FWindow_SkillSelect.prototype;
  //$[OVER]
  _._createCustomElements = function() {
    this._createCategoriesButtons();
    this._createCategoriesHeader();
    this._refreshCategoryButtons(0);
    this._createSkillsList();
  };
  _._createCategoriesButtons = function() {
    var s, x, y;
    s = this.getSettings();
    ({x, y} = s.skillsCategoryButtonPosition);
    this.buttonCat0 = new KDCore.ButtonM("Button_SkSSkillsGroup", true, "Alpha");
    this.buttonCat0.addClickHandler(() => {
      return this.changeCategory(0);
    });
    this.buttonCat0.move(x, y);
    this.buttonCat0.visible = false;
    this.addContent(this.buttonCat0);
    ({x, y} = s.itemsCategoryButtonPosition);
    this.buttonCat1 = new KDCore.ButtonM("Button_SkSItemsGroup", true, "Alpha");
    this.buttonCat1.addClickHandler(() => {
      return this.changeCategory(1);
    });
    this.buttonCat1.move(x, y);
    this.buttonCat1.visible = false;
    this.addContent(this.buttonCat1);
  };
  _._createCategoriesHeader = function() {
    var p;
    p = this.getSettings().windowHeaderTextSettings;
    this.headerText = new KDCore.UI.Sprite_UIText(p);
    // * Добавляем на Header (поверх всего)
    this.addChild(this.headerText);
  };
  _._createSkillsList = function() {
    var height, p, position, r, size, width, x, y;
    p = this.getSettings();
    ({size, position} = p.itemsSkillsListWindow);
    ({x, y} = position);
    ({width, height} = size);
    r = new Rectangle(x, y, width, height);
    this.skillsList = new Window_SkillSelectorList(r);
    return this.addContent(this.skillsList);
  };
  _._updateSkillSelectClick = function() {
    var ref;
    if (!this.isOpen()) {
      return;
    }
    if (TouchInput.isTriggered() && this.isMouseIn()) {
      if ((ref = this.skillsList) != null) {
        ref.onClick();
      }
    }
  };
  _._refreshCategoryButtons = function(newCategory) {
    this.buttonCat0.disable();
    this.buttonCat1.disable();
    if (newCategory === 0) {
      this.buttonCat1.enable();
    } else {
      this.buttonCat0.enable();
    }
  };
  _._refreshHeader = function(category) {
    if (category === 0) {
      this.headerText.draw(this.getSettings().skillHeaderText);
    } else {
      this.headerText.draw(this.getSettings().itemsHeaderText);
    }
  };
})();

// ■ END FWindow_SkillSelect.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this._lastAASkill = null;
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  // * Запоминаем АБС навык, который был использован
  _.setUsedAASkill = function(aaSkill) {
    return this._lastAASkill = aaSkill.idA;
  };
  _.getUsedAASkill = function() {
    if (this._lastAASkill != null) {
      return AA.Utils.unpackAASkill(this._lastAASkill);
    } else {
      return null;
    }
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__attackSkillId, ALIAS__changeEquip, ALIAS__displayLevelUp, ALIAS__forceChangeEquip, ALIAS__forgetSkill, ALIAS__learnSkill, ALIAS__performDamage, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    ALIAS__setup.call(this, ...arguments);
    return this.aaCheckAndParseExtendedHitBoxes();
  };
  //@[ALIAS]
  ALIAS__performDamage = _.performDamage;
  _.performDamage = function() {
    if (AA.isABSMap()) {
      if (this.isPlayer() && AA.PP.isShakeScreenWhenPlayerGetDamage()) {
        // * Стандартный метод (тряска экрана и звук)
        return ALIAS__performDamage.call(this);
      } else {
        // * Если не игрок, то нет тряски и звука
        return Game_Battler.prototype.performDamage.call(this);
      }
    } else {
      return ALIAS__performDamage.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__learnSkill = _.learnSkill;
  _.learnSkill = function(skillId) {
    var shouldAddNewSkillToPanel;
    // * Сперва флаг - что не надо добавлять
    shouldAddNewSkillToPanel = false;
    if (!this.isLearnedSkill(skillId) && AA.PP.isAddNewSkillsOnPanelOnLearning()) {
      shouldAddNewSkillToPanel = true;
    }
    ALIAS__learnSkill.call(this, skillId);
    // * Добавляем после, чтобы навык уже был у игрока
    // * Дополнительно проверяем, выучен ли он и надо ли его добавлять
    if (this.isLearnedSkill(skillId) && shouldAddNewSkillToPanel === true) {
      //#TODO: Учитывать членов группы, но пока только игрок
      // * Чтобы добавить на панель члена партии, надо ActorID менять у SkillSet
      // * И потом опять его возвращать
      if (this.isPlayer() && AA.Utils.isAAObject(skillId)) {
        uAPI.setSkillToPanel(skillId);
      }
    }
  };
  //@[ALIAS]
  ALIAS__forgetSkill = _.forgetSkill;
  _.forgetSkill = function(skillId) {
    var e, symbol;
    ALIAS__forgetSkill.call(this, skillId);
    if (!this.isLearnedSkill(skillId) && AA.PP.isAddNewSkillsOnPanelOnLearning()) {
      //TODO: Учитывать членов группы, но пока только игрок
      if (this.isPlayer() && AA.Utils.isAAObject(skillId)) {
        try {
          symbol = this.AACharacter().aaSkillsSet.getSymbolForSkill(skillId);
          if (symbol != null) {
            uAPI.setSkillToPanel(0, symbol);
          }
        } catch (error) {
          e = error;
          AA.w(e);
        }
      }
    }
  };
  
  //@[ALIAS]
  ALIAS__changeEquip = _.changeEquip;
  _.changeEquip = function() {
    ALIAS__changeEquip.call(this, ...arguments);
    this.aaOnEquipChanged();
  };
  //@[ALIAS]
  ALIAS__forceChangeEquip = _.forceChangeEquip;
  _.forceChangeEquip = function() {
    ALIAS__forceChangeEquip.call(this, ...arguments);
    this.aaOnEquipChanged();
  };
  //@[ALIAS]
  ALIAS__attackSkillId = _.attackSkillId;
  _.attackSkillId = function() {
    var e, id;
    try {
      id = this.aaGetWeaponAttackSkillId();
      if (id > 0 && ($dataSkills[id] != null)) {
        return id;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return ALIAS__attackSkillId.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__displayLevelUp = _.displayLevelUp;
  _.displayLevelUp = function() {
    var e;
    if (AA.PP.isUseCustomLevelUp()) {
      try {
        return this.aaDisplayCustomLevelUp();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    } else {
      return ALIAS__displayLevelUp.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  // * Поддерживает ли данный персонаж управление АИ
  _.isSupportAIControl = function() {
    if (AA.Network.isNetworkGame()) {
      return false;
    } else {
      return KDCore.Utils.getValueFromMeta('ABS', this.actor()) != null;
    }
  };
  _.AACharacter = function() {
    var e, id, playerData;
    try {
      if (this.isPlayer()) {
        return $gamePlayer;
      } else {
        if (AA.Network.isNetworkGame()) {
          playerData = ANGameManager.getPlayerDataByActorId(this.actorId());
          if (playerData != null) {
            ({id} = playerData);
            return $gameMap.networkCharacterById(id);
          }
        } else {
          id = this.actorId();
          return $gamePlayer.followers().aaGetFollowerByActorId(id);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaNetSetupTeamId = function(teamId) {
    var e;
    try {
      if (!AA.Network.isNetworkGame()) {
        return;
      }
      this._aaNetTeamId = teamId;
      if (this.netDataObserver._fields["_aaNetTeamId"] == null) {
        return this.netDataObserver.addFields(this, "_aaNetTeamId");
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaNetGetTeamId = function() {
    return this._aaNetTeamId;
  };
  //$[OVER]
  _.isPlayer = function() {
    return AA.System.isABSActive() && this === $gameParty.leader();
  };
  //$[OVER]
  _.getAASkills = function() {
    var attackSkillId, list;
    // * Включает атаку и защиту (базовые 1 и 2)
    //TODO: навык защиты надо тоже под АБС автоматически дорабатывать при загрузке
    attackSkillId = this.attackSkillId();
    list = this.skills().concat([$dataSkills[attackSkillId]]);
    // * Включает АБС предметы (так как они по сути тоже навыки)
    // * Используется метод $gameParty.items() для быстродействия, чтобы 2 раза не проверять
    list = list.concat($gameParty.items());
    return list.filter(function(skill) {
      return skill.AASkill != null;
    });
  };
  //$[OVER]
  _.getAAItems = function() {
    return $gameParty.items().filter(function(item) {
      return AA.Utils.isAAObject(item);
    });
  };
  
  //$[OVER]
  // * По умолчанию (если тип weaponMotionType не указан анимации, то по типу оружия в руках)
  _.getDefaultWeaponMotionAnimationWeaponId = function() {
    var attackMotion, e, weapons, wtypeId;
    try {
      weapons = this.weapons();
      wtypeId = weapons[0] != null ? weapons[0].wtypeId : 0;
      attackMotion = $dataSystem.attackMotions[wtypeId];
      if (attackMotion != null) {
        return attackMotion.weaponImageId;
      }
    } catch (error) {
      e = error;
      AA.w;
    }
    return 0;
  };
  _.aaCheckAndParseExtendedHitBoxes = function() {
    var actor, e;
    try {
      actor = this.actor();
      if ((actor != null) && (actor.meta.extraHitBoxes != null)) {
        this._aaExtendedHitBox = AA.Utils.Parser.convertArrayFromParameter(actor.meta.extraHitBoxes);
        return;
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    this._aaExtendedHitBox = null;
  };
  _.aaGetExtendedHitBoxes = function() {
    return this._aaExtendedHitBox;
  };
  _.aaOnEquipChanged = function() {
    var e;
    try {
      this._aaCachedWeaponAttackSkillId = null;
      // * Обработка смены оружия с навыком атаки только на игроке
      if (this.AACharacter() === $gamePlayer) {
        $gamePlayer.aaSkillsSet.refreshAttackSkillBinding();
      }
      uAPI.refreshSkillPanelSafe();
      return this.aaRefreshSkillExtensionItemForNewWeapon();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaGetProjectileStartOffset = function() {
    var e;
    try {
      return Number(KDCore.Utils.getValueFromMeta('vectorOffset', this.actor()));
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaGetWeaponAttackSkillId = function() {
    var currentWeapon, e, skillId;
    try {
      if (this._aaCachedWeaponAttackSkillId == null) {
        this._aaCachedWeaponAttackSkillId = 0;
        currentWeapon = this.weapons()[0];
        if (currentWeapon != null) {
          skillId = KDCore.Utils.getValueFromMeta('attackSkill', currentWeapon);
          if (String.any(skillId)) {
            skillId = parseInt(skillId);
            if ($dataSkills[skillId] && AA.Utils.isAASkill(skillId)) {
              this._aaCachedWeaponAttackSkillId = skillId;
            }
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaCachedWeaponAttackSkillId = 0;
    }
    return this._aaCachedWeaponAttackSkillId;
  };
  _.aaGetDefaultSecondarySkillId = function() {
    var e, isExistsAsAASkill, skillId;
    try {
      skillId = KDCore.Utils.getValueFromMeta('defaultSecondarySkill', this.actor());
      if (!String.any(skillId)) {
        return 0;
      }
      skillId = parseInt(skillId);
      isExistsAsAASkill = this.getAASkills().find(function(item) {
        return item.idA === skillId;
      });
      if (isExistsAsAASkill != null) {
        return skillId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  _.aaIsEquippedInHeavyArmor = function() {
    var e;
    try {
      return AA.Utils.isAnyItemHaveNotetag(this.equips(), 'aaHeavy');
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // * Данные параметры добавлены для Gauge Controller Exp gauge
  Object.defineProperties(_, {
    cexp: {
      get: function() {
        return this.currentExp() - this.currentLevelExp();
      },
      configurable: true
    }
  });
  Object.defineProperties(_, {
    nexp: {
      get: function() {
        return this.nextLevelExp() - this.currentLevelExp();
      },
      configurable: true
    }
  });
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //%[I] Показывать список новых навыков через PopUp (как в оригинале)
  _.aaDisplayCustomLevelUp = function() {
    var e, p;
    try {
      p = AA.PP.getCustomLevelUpSettings();
      if (p.databaseAnimationId > 0) {
        uAPI.scriptAction("an_" + p.databaseAnimationId, this.AACharacter());
      }
      if (String.any(p.imageSeqAnimationName)) {
        this.aaLvUpPlayExtraAnimation(p.imageSeqAnimationName, p.imageSeqAnimationMargins);
      }
      if (String.any(p.extraSE)) {
        KDCore.Utils.playSE(p.extraSE);
      }
      if (p.isShowPopUp === true) {
        this.aaLvUpShowLevelUpPopUp(p.popUpText, p.popUpStyle);
      }
      if (p.commonEvent > 0) {
        AA.Utils.startCE(p.commonEvent);
      }
      if (String.any(p.scriptAction)) {
        return uAPI.scriptAction(p.scriptAction, this.AACharacter());
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaLvUpPlayExtraAnimation = function(name, {x, y}) {
    var char, e;
    try {
      char = this.AACharacter();
      if (char == null) {
        return;
      }
      return uAPI.playExtraAnimation(char.x, char.y, name, "", x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaLvUpShowLevelUpPopUp = function(text, style) {
    var char, e;
    try {
      if (style == null) {
        return;
      }
      if (!String.any(text)) {
        return;
      }
      text = text.replace("%1", this.level);
      char = this.AACharacter();
      if (char == null) {
        return;
      }
      return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, style, text);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  _.aaIsCanUseWeaponWithExtension = function() {
    var def, e, extItemId;
    try {
      def = this.aaGetActiveWeaponExtensionDefinition();
      if (def == null) {
        return true;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId > 0) {
        return this.aaIsCanUseSkillDefinitionNow(def, extItemId);
      } else {
        if (def.isRequireExtensionItem()) {
          return false;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  _.aaGetActiveWeaponExtensionDefinition = function() {
    var activeWeapon, def, e;
    try {
      activeWeapon = this.weapons()[0];
      if (activeWeapon != null) {
        def = activeWeapon.AAExtDefinition;
        if ((def != null) && def.isValidDefinition()) {
          return def;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaGetActiveSkillExtensionItemId = function() {
    var e;
    try {
      if (this._aaActiveExtensionItemId != null) {
        return this._aaActiveExtensionItemId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  _.aaSetActiveSkillExtensionItemId = function(extItemId) {
    var def, e;
    try {
      this._aaActiveExtensionItemId = 0;
      if (extItemId == null) {
        return;
      }
      if (extItemId <= 0) {
        return;
      }
      def = this.aaGetActiveWeaponExtensionDefinition();
      if ((def != null) && def.extensions.contains(extItemId)) {
        this._aaActiveExtensionItemId = extItemId;
        return;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaActiveExtensionItemId = 0;
    }
  };
  // * Когда персонаж меняет оружие, надо убрать предметы не подходящие
  _.aaRefreshSkillExtensionItemForNewWeapon = function() {
    var def, e, i, item, len, prevExtensionItemId, ref;
    try {
      prevExtensionItemId = this.aaGetActiveSkillExtensionItemId();
      this.aaSetActiveSkillExtensionItemId(0);
      def = this.aaGetActiveWeaponExtensionDefinition();
      if (def == null) {
        return;
      }
      if (def.extensions.contains(prevExtensionItemId)) {
        this.aaSetActiveSkillExtensionItemId(prevExtensionItemId);
      } else {
        // * Если нет, пытаемся поставить любую (если требуется вообще)
        if (def.isRequireExtensionItem()) {
          ref = def.extensions;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            if ($gameParty.numItems($dataItems[item]) > 0) {
              this.aaSetActiveSkillExtensionItemId(item);
              return;
            }
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaSetActiveSkillExtensionItemId(0);
    }
  };
  // * Применить "расширение" оружия к (его) навыку атаки
  _.aaCheckAndApplySkillExtension = function(skill) {
    var aaSkillDataCopy, def, e, extItemId, item, skillId;
    try {
      if (skill.idA !== this.attackSkillId()) {
        return skill;
      }
      def = this.aaGetActiveWeaponExtensionDefinition(skill);
      if (def == null) {
        return skill;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId > 0) {
        if (this.aaIsCanUseSkillDefinitionNow(def, extItemId)) {
          item = $dataItems[this.aaGetActiveSkillExtensionItemId()];
          if (item == null) {
            return skill;
          }
          if (item.AAExtItem == null) {
            return skill;
          }
          skillId = skill.id;
          // * made a copy of skill data
          aaSkillDataCopy = JsonEx.parse(JsonEx.stringify(skill.AASkill));
          $dataSkills[skillId].__aaDefCopy = aaSkillDataCopy;
          $dataSkills[skillId].AASkill.setNoteParameters(item.AAExtItem.getParameters());
        } else {
          console.log("Skill extension not valid now for use (or you don't have any skill extension item)");
          return null;
        }
      } else {
        // * Если нет никаких, но необходим какой-либо
        // * то возращаем NULL, так как не можем использовать текущий навык
        if (def.isRequireExtensionItem()) {
          console.log("For use this skill " + skill.name + " you should have Skill Extension");
          return null;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return skill;
  };
  _.aaIsCanUseSkillDefinitionNow = function(def, extItemId) {
    var e;
    try {
      if ($gameParty.numItems($dataItems[extItemId]) <= 0) {
        return false;
      }
      if (!def.extensions.contains(extItemId)) {
        // * Только если этот предмет можно использовать с данным weapon
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
    return true;
  };
  _.consumeSkillExtension = function(skill) {
    var def, e, extItemId;
    try {
      if (skill.idA !== this.attackSkillId()) {
        return;
      }
      def = this.aaGetActiveWeaponExtensionDefinition(skill);
      if (def == null) {
        return;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId <= 0) {
        return;
      }
      if (def.isConsumeExtensionItem()) {
        return $gameParty.gainItem($dataItems[extItemId], -1, true);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startWeaponAnimation, _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  //@[ALIAS]
  ALIAS__startWeaponAnimation = _.startWeaponAnimation;
  _.startWeaponAnimation = function(weaponImageId) {
    AANetworkManager.requestWeaponAnimation(this, weaponImageId);
    ALIAS__startWeaponAnimation.call(this, ...arguments);
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  // * Все ABS навыки персонажа
  // У Actor и Enemy разные источники, поэтому метод тут не имеет тела
  _.getAASkills = function() {
    return [];
  };
  // * Все ABS предметы персонажа
  _.getAAItems = function() {
    return [];
  };
  // * ABS навыки, которые можно использовать в данный момент (включая предметы)
  _.getUsableAASkills = function() {
    return this.getAASkills().filter((skill) => {
      return this.canUse(skill);
    });
  };
  // * Когда совершили какое-либо АБС действие (навык)
  // * Не используется стандартный onAllActionsEnd, так как он очищает result
  // * Данный метод выполняется только если действие было полностью законченно
  // * Некоторые AASkills прерываются, если нет цели, тогда onAAActionEnd не вызывается
  _.onAAActionComplete = function() {};
  // * Данный метод выполняется когда действие только активированно (начинается)
  _.onAAActionStart = function() {
    this.aaStates.onAnyActionDone();
  };
  // * Запросить анимацию взмаха оружия (не AnimaX, а стандартная как было в АБС)
  // * См. в редакторе System -> [SV] Attack Motions
  // * Файлы -> System\weapons
  _.aaPlayAAWeaponMotionAnimation = function(skill) {
    var e, weaponId;
    try {
      // * ID номер оружия указа в навыке
      if (skill.isHaveWeaponMotionSpecialType()) {
        this.startWeaponAnimation(skill.weaponMotionType); // * Иначе стандартная (0 или оружие в руках)
      } else {
        weaponId = this.getDefaultWeaponMotionAnimationWeaponId();
        if (weaponId > 0) {
          this.startWeaponAnimation(weaponId);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Если параметр навыка weaponMotionType == 0, то этот метод вызывается
  // * Реализация на Actor и Enemy разная
  _.getDefaultWeaponMotionAnimationWeaponId = function() {
    return 0; // * 0 - нету
  };
  
  // * Изменение здоровье с показом PopUp
  _.aaGainHpWithPopUp = function(value, isCrit = false) {
    var e;
    try {
      this._result = new Game_ActionResult();
      this._result.used = true;
      this._result.hpDamage = value * -1;
      this._result.success = true;
      this._result.physical = true;
      this._result.critical = isCrit === true;
      this._result.hpAffected = true;
      this.startDamagePopup();
      return this.gainHp(value);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Изменение маны с показом PopUp
  _.aaGainMpWithPopUp = function(value, isCrit = false) {
    var e;
    try {
      this._result = new Game_ActionResult();
      this._result.used = true;
      this._result.mpDamage = value * -1;
      this._result.success = true;
      this._result.physical = true;
      this._result.critical = isCrit === true;
      this.startDamagePopup();
      return this.gainMp(value);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addNewState, ALIAS__canUse, ALIAS__clearStates, ALIAS__eraseState, ALIAS__initMembers, ALIAS__isAppeared, ALIAS__isOccasionOk, ALIAS__paySkillCost, _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  // * Этот метод используется в методе canMove, поэтому дополняем его
  // * В АБС бою, монстр всегда Appeared (видимый)
  //@[ALIAS]
  ALIAS__isAppeared = _.isAppeared;
  _.isAppeared = function() {
    if (AA.isABSMap()) {
      return true;
    } else {
      return ALIAS__isAppeared.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.initAASkills();
  };
  //@[ALIAS]
  ALIAS__canUse = _.canUse;
  _.canUse = function(item) {
    if (AA.isABSMap() && (item.AASkill != null)) {
      return this.canUseABSItem(item);
    } else {
      return ALIAS__canUse.call(this, item);
    }
  };
  //@[ALIAS]
  ALIAS__paySkillCost = _.paySkillCost;
  _.paySkillCost = function(skill) {
    ALIAS__paySkillCost.call(this, skill);
    if (AA.isABSMap() && (skill.AASkill != null)) {
      return this.aaSetSkillTimer(skill);
    }
  };
  // * АБС навыки не учитывают область действия, так как их можно использовать только на карте
  //@[ALIAS]
  ALIAS__isOccasionOk = _.isOccasionOk;
  _.isOccasionOk = function(item) {
    if (AA.isABSMap() && (item.AASkill != null)) {
      return true;
    } else {
      return ALIAS__isOccasionOk.call(this, item);
    }
  };
  // * STATES =========================================

  //@[ALIAS]
  ALIAS__addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    ALIAS__addNewState.call(this, stateId);
    // * Если состояние было добавленно
    if (this.isStateAffected(stateId)) {
      if (AA.Utils.isAAState(stateId)) {
        this.addNewStateABS(stateId);
      }
    }
  };
  //@[ALIAS]
  ALIAS__clearStates = _.clearStates;
  _.clearStates = function() {
    ALIAS__clearStates.call(this);
    return this.clearStatesABS();
  };
  
  //@[ALIAS]
  ALIAS__eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    var ref;
    ALIAS__eraseState.call(this, stateId);
    if (!this.isStateAffected(stateId)) {
      if (stateId === 1) { // * Death
        if ((ref = this.AACharacter()) != null) {
          ref.aaOnRevive();
        }
      }
      if (AA.Utils.isAAState(stateId)) {
        return this.eraseStateABS(stateId);
      }
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  _.gev_onABSPaused = function() {
    return this.aaStates.onABSSystemStop(this);
  };
  _.AACharacter = function() {
    return null;
  };
  _.isPlayer = function() {
    return false;
  };
  _.aaUpdateABS = function() {
    // * Обновление таймеров навыков
    this.aaSkillsTimers.update();
    return this.aaUpdateABSStates();
  };
  // * Расчёт значения по формуле для текущего бойца
  // * Выполняется внутри Battler, чтобы можно было получить
  // * знаения базовых параметров
  _.aaCalculateFormula = function(formula) {
    var e;
    try {
      return eval(formula);
    } catch (error) {
      e = error;
      AA.w(e);
      return 0;
    }
  };
  _.initAASkills = function() {
    this.aaSkillsTimers = new AASkillsTimers();
  };
  // * Запустить таймер перезарядки для навыка
  _.aaSetSkillTimer = function(skill) {
    var time;
    time = skill.AASkill.getReloadTime(this);
    if (time > 0) {
      this.aaSkillsTimers.startTimerForSkill(skill.idA, time);
    }
  };
  // * Если у навыка есть таймер, значит он не готов (не важно сколько осталось времени)
  _.aaIsSkillReadyInTime = function(skill) {
    return !this.aaSkillsTimers.isSkillHaveTimer(skill.idA);
  };
  // * Получить таймер навыка (используется для панели навыков в основном)
  _.aaGetRemainTimeForSkill = function(skillId) {
    // * Если таймер меньше секунды, то будет возращён 0 (чтобы не начинать визуальный отсчёт)
    if (this.aaSkillsTimers.isSkillHaveTimerToShow(skillId)) {
      return this.aaSkillsTimers.getRemainTimeForSkill(skillId);
    } else {
      return 0;
    }
  };
  _.canUseABSItem = function(item) {
    if (item == null) {
      return false;
    }
    if (!AA.isABSActive()) {
      return false;
    }
    if (!this.canMove()) {
      return false;
    }
    if (!AA.Utils.isAAObject(item)) {
      return false;
    }
    if (!this.meetsABSExtraConditions(item)) {
      return false;
    }
    if (DataManager.isSkill(item)) {
      return this.meetsABSSkillContitions(item);
    } else if (DataManager.isItem(item)) {
      return this.meetsABSItemContitions(item);
    } else {
      return false;
    }
  };
  _.meetsABSExtraConditions = function(item) {
    var aaSkill, e;
    try {
      aaSkill = item.AASkill;
      if (aaSkill.isRequireStateOnUser()) {
        if (!this.isStateAffected(aaSkill.gUsableIfState())) {
          return false;
        }
      }
      if (aaSkill.idA === this.attackSkillId()) {
        if (!this.aaIsCanUseWeaponWithExtension()) {
          return false;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return true;
  };
  _.aaIsCanUseWeaponWithExtension = function() {
    return true;
  };
  _.meetsABSSkillContitions = function(skill) {
    return this.aaIsSkillReadyInTime(skill) && this.meetsSkillConditions(skill);
  };
  // * Вещи не имеют таймеров
  _.meetsABSItemContitions = function(item) {
    return this.meetsItemConditions(item);
  };
  
  // * Применение "расширения" навыка (работает только Game_Actor)
  _.aaCheckAndApplySkillExtension = function(skill) {
    return skill;
  };
  // * Использование предмета "расширения" навыка (работает только Game_Actor)
  _.consumeSkillExtension = function(skill) {}; // * EMPTY
  _.aaGetExtraOverlayImage = function() {
    var e, state, states;
    try {
      states = this.states();
      if (states.length > 0) {
        state = states[0];
        if (state.meta != null) {
          return state.meta.svOverlay;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  // * Добавим MaxTp чтобы Gauge контроллеры работали
  Object.defineProperties(_, {
    mtp: {
      get: function() {
        return this.maxTp();
      },
      configurable: true
    }
  });
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  //TODO: подписаться на событие по остановке ABS

  // * Для оптимизации, вынес в отдельную переменную
  _.aaSetSpeedMod = function(_aaSpeedModValue) {
    this._aaSpeedModValue = _aaSpeedModValue;
  };
  _.aaUpdateABSStates = function() {
    return this.aaStates.update(this);
  };
  _.addNewStateABS = function(stateId) {
    var stateItem;
    stateItem = AA.Utils.getAAStateObject(stateId);
    if (stateItem == null) {
      return;
    }
    //"ABS STATE ADDED".p(stateId)
    this.aaStates.checkBattler(this);
    this.aaStates.add(stateId);
  };
  _.clearStatesABS = function() {
    this.aaStates = new AAStatesSet(this);
    this.aaSetSpeedMod(null);
  };
  _.eraseStateABS = function(stateId) {
    var stateItem;
    stateItem = AA.Utils.getAAStateObject(stateId);
    if (stateItem == null) {
      return;
    }
    //"ABS STATE REMOVED".p()
    this.aaStates.remove(stateId);
  };
  _.aaSpeedMod = function() {
    if (this._aaSpeedModValue != null) {
      return this._aaSpeedModValue;
    } else {
      return 1;
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__searchLimit, ALIAS__turnTowardCharacter, _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  //@[ALIAS]
  ALIAS__searchLimit = _.searchLimit;
  _.searchLimit = function() {
    if (this.isABS()) {
      return 24;
    } else {
      return ALIAS__searchLimit.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__turnTowardCharacter = _.turnTowardCharacter;
  _.turnTowardCharacter = function(character) {
    ALIAS__turnTowardCharacter.call(this, character);
    // * Дополнительно синхронизируем поворот
    // * В Alpha NET Z это делается через Observer 60, что не хватает для ABS
    if (AA.Network.isNetworkGame()) {
      AANetworkManager.sendTurnTowardCharacter(this, character);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaIsHaveExColliders = function() {
    return (this._aaExColliders != null) && this._aaExColliders.length > 0;
  };
  _.aaGetAllExColliders = function() {
    var e;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      this.aaRefreshAllColliders();
      return this._aaExColliders;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.aaRefreshAllColliders = function() {
    var col, e, i, len, ref, results;
    try {
      if (!this.aaIsHaveExColliders()) {
        return;
      }
      ref = this._aaExColliders;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        col = ref[i];
        results.push(this.aaRefreshColliderData(col));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaRefreshColliderData = function(c) {
    var e;
    try {
      if (c == null) {
        return;
      }
      return c.refreshPositionForChar(this);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaClearExCollider = function() {
    var e;
    try {
      return this._aaExColliders = [];
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaAddExCollider = function(config) {
    var c, col, e, i, len;
    try {
      if (config == null) {
        return;
      }
      if (config instanceof Array) {
        for (i = 0, len = config.length; i < len; i++) {
          c = config[i];
          this.aaAddExCollider(c);
        }
        return;
      }
      if (this._aaExColliders == null) {
        this._aaClearExCollider();
      }
      col = AACollider.FromConfig(config);
      if (col != null) {
        return this._aaExColliders.push(col);
      }
    } catch (error) {
      //console.log("collider created " + config.flag)
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaIsCollideWith = function(collider) {
    var col, e, i, len, myColliders;
    try {
      myColliders = this.aaGetAllExColliders();
      for (i = 0, len = myColliders.length; i < len; i++) {
        col = myColliders[i];
        if (col.isCollideWith(collider)) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // * Not for Events, for Player and Follower
  _._initExCollForABS = function(flag = 'player') {
    var config, e;
    try {
      if (this.AABattler() == null) {
        return;
      }
      config = this.AABattler().actor().meta.aCollider;
      if (String.any(config)) {
        if (config === "none") {
          return;
        }
        config = AA.Utils.parseColliderConfig(config, flag);
      } else {
        config = AACollider.DefaultConfig(flag);
      }
      return this.aaAddExCollider(config);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  (function() {    // * Методы ABS (Цель)
    // -----------------------------------------------------------------------
    _.AATarget = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.getTarget() : void 0;
    };
    //TODO: Это можно удалить

    // * Попытка установить активную цель
    _.aaTrySetTarget = function(target) {
      var ref;
      if (this.aaIsValidTargetToSet(target)) {
        if ((ref = this.AAEntity()) != null) {
          ref.setTarget(target);
        }
        return true;
      }
      return false;
    };
    
    // * Этот метод лучше переопределять у Game_Event и Game_Player
    _.aaIsValidTargetToSet = function(target) {
      return false;
    };
    // * Есть ли активная цель?
    return _.aaIsHaveTarget = function() {
      return this.AATarget() != null;
    };
  })();
  (function() {    
    // * Методы ABS (Навыки)
    // -----------------------------------------------------------------------
    _.aaApplyImpulse = function(power, dir = 0, withJump = false, isReversed = false) {
      var e, lastDirectionFix;
      try {
        if (power <= 0) {
          return;
        }
        //console.log ("APPLY IMPULSE "  + power)
        // * Random direction
        if (dir <= 0) {
          dir = 2 + Math.randomInt(4) * 2;
        }
        lastDirectionFix = this.isDirectionFixed();
        this.setDirectionFix(true);
        // * Move away around
        if (dir === 100 && ($gameTemp._aaImpuleAwayFrom != null)) {
          this.aaMoveAwayByImpulse(power, withJump, isReversed);
        } else {
          if (isReversed) {
            dir = this.reverseDir(dir);
          }
          this.aaMoveInImpulseDirection(power, dir, withJump);
        }
        return this.setDirectionFix(lastDirectionFix);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaMoveAwayByImpulse = function(power, withJump, isReversed = false) {
      var e, i, j, ref;
      try {
        //"MOVE AWAY".p()
        this.aaClearMovePath();
        for (i = j = 0, ref = power; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (isReversed) {
            this.moveTowardCharacter($gameTemp._aaImpuleAwayFrom);
          } else {
            this.moveAwayFromCharacter($gameTemp._aaImpuleAwayFrom);
          }
        }
        if (withJump) {
          return this.jump(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaMoveInImpulseDirection = function(power, dir, withJump) {
      var e, i, j, ref;
      try {
        this.aaClearMovePath();
        if (this.canPass(this._x, this._y, dir)) {
          for (i = j = 0, ref = power; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            if (!this.aaForceMoveByImpluse(dir)) {
              break;
            }
          }
          if (withJump) {
            return this.jump(0, 0);
          }
        } else {
          return this.jump(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.aaForceMoveByImpluse = function(direction) {
      var e;
      try {
        if (this.canPass(this._x, this._y, direction)) {
          this.moveStraight(direction);
          return true;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
  })();
  (function() {    // * Методы ABS (Движение)
    // -----------------------------------------------------------------------
    _.aaTurnTowardTouchInput = function() {
      return this.turnTowardCharacter(TouchInput.toMapPoint());
    };
    _.aaTeleport = function(point, inAnimation, outAnimation, delay = 1) {
      var e, staticPoint;
      try {
        // * Чтобы не хранить лишние данные, вдруг в качестве Point передался Game_Character
        staticPoint = {
          x: point.x,
          y: point.y
        };
        this._aaTeleportData = {
          point: staticPoint,
          inAnimation,
          outAnimation
        };
        this._aaTeleportDelay = delay;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _._aaPerformTeleport = function() {
      var e, inAnimation, outAnimation, point;
      if (this._aaTeleportData == null) {
        return;
      }
      try {
        ({point, inAnimation, outAnimation} = this._aaTeleportData);
        if ($gameMap.isValid(point.x, point.y)) {
          if (inAnimation > 0) {
            AABattleActionsManager.playAnimationOnMap(this.x, this.y, inAnimation);
            return this.aaTeleport(point, 0, outAnimation, 10); // * Если нет анимации входа, то мнгновенно!
          } else {
            this.locate(point.x, point.y);
            if (outAnimation > 0) {
              AABattleActionsManager.playAnimationOnMap(point.x, point.y, outAnimation);
            }
            this._aaOnTeleportPerformed();
            return this._aaTeleportData = null;
          }
        } else {
          return this._aaTeleportData = null;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return this._aaTeleportData = null;
      }
    };
    return _._aaUpdateTeleportRequest = function() {
      if (this._aaTeleportData == null) {
        return;
      }
      if (this._aaTeleportDelay > 0) {
        this._aaTeleportDelay--;
        if (this._aaTeleportDelay <= 0) {
          this._aaTeleportDelay = 0;
          this._aaPerformTeleport();
        }
      }
    };
  })();
  // -----------------------------------------------------------------------
  _.aaIsOutOfScreen = function() {
    var e, limitH, limitW, margin, sx, sy;
    try {
      sx = this.screenX();
      sy = this.screenY();
      margin = 20;
      limitW = Graphics.width + margin;
      limitH = Graphics.height + margin;
      if (sx < -margin || sx > limitW || sy < -margin || sy > limitH) {
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //TODO LIST:
  // Casting Party AI members
  // Add Casting Progress Bar to UI Editor
  // Правильная остановка звука

  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaInSkillCastingProcess = function() {
    return this._aaCastingNowSkill != null;
  };
  // * Начать процесс каста навыка
  _.aaStartSkillCastingProcess = function(skill) {
    var e;
    try {
      console.log("Start Casting Skill: " + skill.name());
      this._aaCastingNowSkill = skill;
      this._aaCastingTimer = 0;
      this._aaCastingTimeMax = skill.gCastingTime() * 60;
      this._aaOnCastingStarted();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaAbortSkillCastingProcess();
    }
  };
  _._aaOnCastingStarted = function() {
    var e;
    try {
      AA.Utils.startCE(this._aaCastingNowSkill.onCastingStartCE);
      if (String.any(this._aaCastingNowSkill.castingSE)) {
        KDCore.Utils.playSE(this._aaCastingNowSkill.castingSE);
      }
      if (String.any(this._aaCastingNowSkill.castingAnimation)) {
        return this.startAnimaXCustomAction(this._aaCastingNowSkill.castingAnimation, true, true);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Прервать (например при движени или входа в меню)
  _.aaAbortSkillCastingProcess = function() {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      this._aaOnCastingAborted();
      AA.Utils.startCE(this._aaCastingNowSkill.onCastingAbortedCE);
      console.log("Abort Casting Skill");
      return this.aaClearSkillCastingProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingAborted = function() {
    var e;
    try {

    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaClearSkillCastingProcess = function() {
    var e;
    try {
      this._aaCastingTimer = 0;
      this._aaCastingTimeMax = 0;
      this._aaBeforeCastingTargetPoint = null;
      this._aaOnCastingEnd();
      return this._aaCastingNowSkill = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingEnd = function() {
    var e;
    try {
      //TODO: Not good way
      if (String.any(this._aaCastingNowSkill.castingSE)) {
        AudioManager.stopSe();
      }
      if ((this._aaCastingNowSkill != null) && String.any(this._aaCastingNowSkill.castingAnimation)) {
        return this.resetXAnima();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaFinishSkillCastingProcess = function() {
    var dbItem, e, extraCondition, skill, targetPoint;
    try {
      this._aaOnCastingFinished();
      console.log("Finish Casting Skill");
      skill = this._aaCastingNowSkill;
      targetPoint = this._aaBeforeCastingTargetPoint;
      if (this._aaBeforeCastingTargetPoint instanceof Game_Character) {

      } else {
        // * Nothing
        if (skill.isInPoint() && !skill.isNeedSelectZone()) {
          targetPoint = TouchInput.toMapPoint();
          extraCondition = skill.isInstant() || skill.isInCertainPoint();
          if (extraCondition === false) {
            targetPoint.touchXY = {
              x: TouchInput.x,
              y: TouchInput.y
            };
          }
        }
      }
      this.aaClearSkillCastingProcess();
      dbItem = skill.dbItem();
      return setTimeout((() => {
        var e;
        try {
          if (targetPoint != null) {
            return this.startPerformAASkill(targetPoint, true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 1);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingFinished = function() {
    var e;
    try {
      return AA.Utils.startCE(this._aaCastingNowSkill.onCastingCompletedCE);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnEventWhileCasting = function(eventName) {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      if (eventName === "hit") {
        if (this._aaCastingNowSkill.castingStopWhenHit > 0) {
          console.log("Character was hit while casting");
          this.aaAbortSkillCastingProcess();
        } else if (this._aaCastingNowSkill.castingDelayWhenHit > 0) {
          console.log("Character was hit while casting, delay casting");
          this._aaCastingTimer -= this._aaCastingNowSkill.castingDelayWhenHit * 60;
          if (this._aaCastingTimer < 0) {
            this._aaCastingTimer = 0;
          }
        }
        return;
      }
      if (eventName === "move") {
        console.log("Character is moving while casting");
        this.aaAbortSkillCastingProcess();
        return;
      }
      if (eventName === "click") {
        if (this._aaCastingNowSkill.castingRotation > 0) {
          this.aaTurnTowardTouchInput();
        }
        return;
      }
      if (eventName === "cancel" || eventName === "menu") {
        console.log("Character canceled casting (or menu)");
        this.aaAbortSkillCastingProcess();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Not used now
  //_.aaIsCantMoveWhileCasting = () ->
  //    return false unless @aaInSkillCastingProcess()
  //    return @_aaCastingNowSkill.castingStopWhenMove == 0
  _._aaUpdateCastingProcess = function() {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      if (this._aaCastingNowSkill.castingRotation > 0) {
        this.aaTurnTowardTouchInput();
      }
      this._aaCastingTimer += 1;
      if (this._aaCastingTimer >= this._aaCastingTimeMax) {
        return this.aaFinishSkillCastingProcess();
      } else {
        if (this.isMoving()) {
          return this.aaOnEventWhileCasting('move');
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.setActiveAASkill = function(_activeAASkillId) {
    this._activeAASkillId = _activeAASkillId;
  };
  _.activeAASkill = function() {
    if (this._activeAASkillId > 0) {
      return AA.Utils.getAASkillObject(this._activeAASkillId).AASkill;
    } else {
      return null;
    }
  };
  _.startPerformAASkill = function(point, afterCasting = false) {
    var skill;
    skill = this.activeAASkill();
    if (skill.isNeedCasting() && !afterCasting) {
      this._aaBeforeCastingTargetPoint = point;
      this.aaStartSkillCastingProcess(skill);
      return;
    }
    if (skill.isInPoint()) {
      this.turnTowardCharacter(point);
    }
    //TODO: Тут можно ещё дополнительную проверку canUse
    // так как пока шёл выборо цели (например) мана могла закончиться
    // * Анимация Motion и AnimaX могут работать вместе
    this.aaDetermineAndPlaySkillAnimation(skill);
    // * Персонаж "платит" за навык как только использует его
    this.AABattler().useItem(skill.dbItem());
    this.AABattler().consumeSkillExtension(skill);
    this.AABattler().onAAActionStart();
    // * Ограничение задержки для безопасности (было снято)
    if (skill.actionStartDelay > 0) { //and skill.actionStartDelay <= 60
      this.setupDelayedAASkill(skill, point);
    } else {
      AABattleActionsManager.startAASkill(skill, this, point);
    }
  };
  _.aaDetermineAndPlaySkillAnimation = function(skill) {
    if (skill.animaXPriority > 1) {
      if (skill.isHaveWeaponMotion()) {
        // * Анимация Motion и AnimaX могут работать вместе
        this.AABattler().aaPlayAAWeaponMotionAnimation(skill);
      }
      this.aaPlayAASkillXAnimation(skill);
    } else {
      // * Если в приоритете AnimaX
      if (skill.animaXPriority === 1) {
        // * Если есть анимация для действия, то проиграть её
        if (this.aaIsAvailableAnimaXForSkill(skill)) {
          this.aaPlayAASkillXAnimation(skill); // * Иначе анимаци Weapon Motion
        } else {
          if (skill.isHaveWeaponMotion()) { // * Если в приоритете Weapon Motion
            this.AABattler().aaPlayAAWeaponMotionAnimation(skill);
          }
        }
      } else {
        if (skill.isHaveWeaponMotion()) {
          this.AABattler().aaPlayAAWeaponMotionAnimation(skill); // * Если нет Weapon Motion, то AnimaX (если есть)
        } else {
          if (this.aaIsAvailableAnimaXForSkill(skill)) {
            this.aaPlayAASkillXAnimation(skill);
          }
        }
      }
    }
  };
  _.aaIsAvailableAnimaXForSkill = function(skill) {
    if (Imported.PKD_AnimaX !== true) {
      return false;
    }
    if (!this.isAnimX()) {
      return false;
    }
    return this.isHaveAnimaXActionWithName(skill.getAnimaXActionName());
  };
  _.aaPlayAASkillXAnimation = function(skill) {
    var e;
    try {
      if (!Imported.PKD_AnimaX) {
        return;
      }
      if (!this.isAnimX()) {
        return;
      }
      // * For AnimaX network
      // * Команда startAnimaXCustomAction отправляет
      if (this instanceof Game_Event) {
        // * по номеру события
        $gameTemp._lastAxNetworkChar = this.eventId();
      } else {
        // * 0 - значит будет по Actor ID, который отправляет
        $gameTemp._lastAxNetworkChar = 0;
      }
      this.startAnimaXCustomAction(skill.getAnimaXActionName(), false, true);
      return $gameTemp._lastAxNetworkChar = null;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.setupDelayedAASkill = function(skill, point) {
    this.aaDelayedSkillActions.push([skill.actionStartDelay, skill.idA, AA.Utils.packAAPoint(point)]);
  };
  _._aaUpdateDelayedSkillActions = function() {
    var action, i, len, point, ref, skill;
    ref = this.aaDelayedSkillActions;
    //TODO: Навык с задержкой должен иметь задержку перед использованием иначе ошибка, если спамить навык
    for (i = 0, len = ref.length; i < len; i++) {
      action = ref[i];
      if (action == null) {
        continue;
      }
      if (action[0]-- <= 0) {
        skill = AA.Utils.unpackAASkill(action[1]);
        point = AA.Utils.unpackAAPoint(action[2]);
        AABattleActionsManager.startAASkill(skill, this, point);
        this.aaDelayedSkillActions.delete(action);
      }
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaUpdateAIMovement = function() {
    this.aaUpdateSmartMovementDelay();
    if (this.isMoving()) {
      return;
    }
    if (this.aaInSkillCastingProcess()) {
      return;
    }
    switch (this._moveType) {
      case 91: // * Approach target
        this.aaMoveTypeToTarget();
        return this.aaMoveTypeTeleportToTarget();
      case 92:
        this.aaMoveTypeKeepDistance();
        return this.aaMoveTypeTeleportFromTarget();
      case 93:
        return this.aaMoveTypeReturnToHomePoint();
      case 94:
        // * СТОИТ НА МЕСТЕ И ВСЁ
        return this.aaTurnTowardTarget();
    }
  };
  // * NOTHING
  // Просто стоим
  _.aaUpdateSmartMovementDelay = function() {
    var e;
    try {
      if (this.__aaNextDirectionFindDelay > 0) {
        this.__aaNextDirectionFindDelay--;
        if (this.__aaNextDirectionFindDelay <= 0) {
          return this.__aaNextDirectionFindDelay = null;
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Эти два метода реализует Game_Event (т.к. враги поддерживают телепорт)
  // * см. файл Game_Event_AIMove_Teleport
  _.aaMoveTypeTeleportToTarget = function() {}; // * EMPTY
  _.aaMoveTypeTeleportFromTarget = function() {}; // * EMPTY
  
  // * Сохраняем базовые настройки движения события
  _.aaStoreMoveData = function() {
    var i, item, len, ref;
    // * Выполняется один раз, при первой инициализации
    if (this._storedMoveData != null) {
      return;
    }
    this._storedMoveData = {};
    ref = ["_moveSpeed", "_moveType", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this._storedMoveData[item] = this[item];
    }
  };
  // * Восстанавливаем базоыве настройки движения события
  _.aaRestoreMoveData = function() {
    var i, item, len, ref;
    this.__aaNextDirectionFindDelay = null;
    if (this._storedMoveData == null) {
      return;
    }
    ref = ["_moveSpeed", "_moveType", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this[item] = this._storedMoveData[item];
    }
  };
  
  // * Восстановить базовую скорость движения события
  _.aaResetDefaultFreqAndSpeed = function() {
    var i, item, len, ref;
    this.__aaNextDirectionFindDelay = null;
    if (this._storedMoveData == null) {
      return;
    }
    ref = ["_moveSpeed", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this[item] = this._storedMoveData[item];
    }
  };
  // * Сохранить текущую координату как точка "дом"
  _.aaStoreHomePoint = function() {
    this.homePoint = {
      x: this.x,
      y: this.y
    };
  };
  _.aaResetHomePoint = function() {
    return this.homePoint = null;
  };
  // * У событий AI Free State управляет этим процессом (начинает и завершает)
  _.aaSetMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      if (this._moveType === 93) {
        return;
      }
      if (this.homePoint == null) {
        return;
      }
      return this._moveType = 93;
    } catch (error) {
      //returnMoveData[F, S]
      //TODO:
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeApproachTarget = function() {
    var e, params;
    try {
      if (this._moveType === 91) {
        return;
      }
      // * Быстрая проверка, что есть цель
      if (!this.AAEntity().inBattle()) {
        return;
      }
      // * Approach target
      this._moveType = 91;
      // * Задержка перед следующим движением (для оптимизации)
      // * Используется, когда вокруг цели (игрока, персонажа) нет места
      this._aaLastMovingActionDelay = 0;
      params = this.AAModel().approachMoveData;
      if (this.distTo(this.AAEntity().getTarget()) >= params[0]) {
        this.setMoveFrequency(params[1]);
        return this.setMoveSpeed(params[2]);
      } else {
        return this.aaResetDefaultFreqAndSpeed();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeKeepBattleDistance = function() {
    var e, params;
    try {
      if (this._moveType === 92) {
        return;
      }
      if (!this.AAEntity().inBattle()) {
        return;
      }
      this._moveType = 92;
      params = this.AAModel().inBattleMoveData;
      this.setMoveFrequency(params[1]);
      this.setMoveSpeed(params[2]);
      this._aaMinPatrolDist = params[0];
      this._aaMaxPatrolDist = this.AAModel().gViewRadius();
      return this._aaCanMakeRandomPatrolMove = params[3];
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      //"HOME ".p()
      if (this.homePoint != null) {
        return this.aaMoveTypeToPoint(this.homePoint);
      } else {
        return this.aaRestoreMoveData();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeStayStill = function() {
    var e;
    try {
      if (this._moveType === 94) {
        return;
      }
      if (!this.AAEntity().inBattle()) {
        return;
      }
      return this._moveType = 94;
    } catch (error) {
      //"STAY STILL".p()
      e = error;
      return AA.w(e);
    }
  };
  // * Держать дистанцию боя
  // * Не подходить близко и не отходить далеко
  _.aaMoveTypeKeepDistance = function() {
    var distance, e, target;
    try {
      // * Если меньше 0, то ничего
      if (this._aaMinPatrolDist <= 0) {
        this.aaTurnTowardTarget();
        return;
      }
      target = this.AAEntity().getTarget();
      if (target == null) {
        return;
      }
      distance = this.distTo(target);
      if (distance >= this._aaMaxPatrolDist) {
        //"DIST > MAX".p()
        this.aaMoveTypeToTarget(target);
        return;
      }
      if (distance <= this._aaMinPatrolDist) {
        //"DIST <= MIN".p()
        this.moveAwayFromCharacter(target);
        this.aaTurnTowardTarget();
        return;
      }
      if (this._aaCanMakeRandomPatrolMove) {
        //"RAND MOVE".p()
        this.moveRandom();
        this.aaTurnTowardTarget();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[EXTENSION]
AA.extend(function() {
  var ALIAS___createXAnimaSetsForState, ALIAS__createNewAnimaXForCharacter, ALIAS__isHaveAnimaXState, ALIAS__onAnimaXActionEnd, _;
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_AnimaX !== true) {
    return;
  }
  //@[DEFINES]
  _ = Game_Character.prototype;
  // * Логика состояний анимации (бой, смерть) (всегда работает)
  _.aaUpdateABSAnimaX = function() {
    var ref;
    if (!this.isAnimX()) {
      return;
    }
    if (!((ref = this.AABattler()) != null ? ref.isAlive() : void 0)) {
      return;
    }
    this.aaUpdateABSAnimaXInBattleState();
  };
  _.aaUpdateABSAnimaXInBattleState = function() {
    var e;
    if (this._aaIsInBattleAnimaXState()) {
      if (this._axState !== 'inBattle') {
        this._aaOnGoInBattleAnimaXState();
      }
      try {
        if (this === $gamePlayer) {
          this.aaStartAutoBattleBgm();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    } else {
      if (this._axState !== 'base') {
        this._aaOnOutFromInBattleAnimaXState();
      }
      try {
        if (this === $gamePlayer) {
          this.aaStopAutoBattleBgm();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
  _._aaOnGoInBattleAnimaXState = function() {
    this.switchToXAnimaState('inBattle');
    // * Только персонаж игрока сам определяет состояние "В бою"
    // * NET Character не определяет, только получает от севрера
    // * Game_Event - у него по AAEntity, target через Observer синхронизируется
    if (AA.Network.isNetworkGame() && this === $gamePlayer) {
      AANetworkManager.animaXChangeState('inBattle', this);
    }
  };
  _._aaOnOutFromInBattleAnimaXState = function() {
    this.resetXAnimaState();
    if (AA.Network.isNetworkGame() && this === $gamePlayer) {
      AANetworkManager.animaXChangeState('base', this);
    }
  };
  // * Game_Event and Game_Player имеют разную реализацию
  _._aaIsInBattleAnimaXState = function() {
    return false;
  };
  // * Из-за ALIAS пришлось выносить в Extenstion, чтобы не было зависимости от положения AnimaX плагина
  //@[ALIAS]
  ALIAS__createNewAnimaXForCharacter = _.createNewAnimaXForCharacter;
  _.createNewAnimaXForCharacter = function(animaXProfile) {
    ALIAS__createNewAnimaXForCharacter.call(this, animaXProfile);
    this.refreshAnimaXABSStates(animaXProfile);
  };
  // * Добавляем специальный флаг для Dead, чтобы не было Loop и заканчивался на последнем кадре (и с него воспроизводился снова)
  //@[ALIAS]
  ALIAS___createXAnimaSetsForState = _._createXAnimaSetsForState;
  _._createXAnimaSetsForState = function(state, moveSet, idleSet, dashSet) {
    ALIAS___createXAnimaSetsForState.call(this, ...arguments);
    if ((idleSet != null) && state === "dead") {
      idleSet.aaNoRepeatFlag = true;
    }
  };
  // * Загрузка состояний анимации
  _.refreshAnimaXABSStates = function(animaXProfile) {
    var animaXStateBattle, animaXStateDead;
    animaXStateBattle = XAnimaTools.getXAnimaParamsForState('inBattle', animaXProfile);
    this.registerAnimaXState('inBattle', animaXStateBattle);
    animaXStateDead = XAnimaTools.getXAnimaParamsForState('dead', animaXProfile);
    if (animaXStateDead != null) {
      this.registerAnimaXState('dead', animaXStateDead);
    }
  };
  _._aaOnGoInDeadAnimaXState = function() {
    var e;
    try {
      if (!this.isHaveAnimaXState('dead')) {
        return;
      }
      if (this._axState !== "dead") {
        this.switchToXAnimaState('dead');
      }
      if (AA.Network.isNetworkGame() && this === $gamePlayer) {
        AANetworkManager.animaXChangeState('dead', this);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  
  //@[ALIAS]
  ALIAS__isHaveAnimaXState = _.isHaveAnimaXState;
  _.isHaveAnimaXState = function() {
    if (this._axStates == null) {
      this._axStates = {};
    }
    return ALIAS__isHaveAnimaXState.call(this, ...arguments);
  };
  _.aaPlayAnimaXActionWithEndCallback = function(actionName, callback) {
    var e;
    try {
      if (!this.isAnimX()) {
        return;
      }
      this.__aaActionCallback = callback;
      return this.startAnimaXCustomAction(actionName, false, true);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@[ALIAS]
  ALIAS__onAnimaXActionEnd = _.onAnimaXActionEnd;
  _.onAnimaXActionEnd = function() {
    var e;
    ALIAS__onAnimaXActionEnd.call(this, ...arguments);
    try {
      return this.aaExecuteAnimaXActionCalback();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaExecuteAnimaXActionCalback = function() {
    var e;
    try {
      if (this.__aaActionCallback == null) {
        return;
      }
      this.__aaActionCallback();
      return this.__aaActionCallback = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
});

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__attackSkillId, ALIAS__requestAnimation, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  //@[ALIAS]
  ALIAS__requestAnimation = _.requestAnimation;
  _.requestAnimation = function(animationId, isFromAA) {
    this.__aaIsRequestAnimationScale = isFromAA === true;
    ALIAS__requestAnimation.call(this, ...arguments);
  };
  
  //$[OVER]
  ALIAS__attackSkillId = _.attackSkillId;
  _.attackSkillId = function() {
    var e, set;
    try {
      set = this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_SKILL);
      if (set.length > 0) {
        return Math.max(...set);
      } else {
        return ALIAS__attackSkillId.call(this, ...arguments);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return ALIAS__attackSkillId.call(this, ...arguments);
    }
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    // * Набор навыков с задержкой
    this.aaDelayedSkillActions = [];
    this.aaClearCharacterEffects();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    this._aaUpdate();
  };
  (function() {    
    // * Диагональное движение
    // -----------------------------------------------------------------------
    var ALIAS__moveDiagonally, ALIAS__moveStraight, ALIAS__realMoveSpeed, ALIAS__setDirection;
    
    //@[ALIAS]
    ALIAS__realMoveSpeed = _.realMoveSpeed;
    _.realMoveSpeed = function() {
      var e, speed;
      speed = ALIAS__realMoveSpeed.call(this);
      try {
        if (this.isABS()) {
          speed *= this.aaSpeedMod();
        }
      } catch (error) {
        e = error;
        AA.w(e);
        speed = ALIAS__realMoveSpeed.call(this);
        this.aaSpeedMod = function() {
          return 1;
        };
      }
      if (this._diagonalDir) {
        return speed * AA.Input.diagonalSpeed;
      } else {
        return speed;
      }
    };
    //@[ALIAS]
    ALIAS__moveStraight = _.moveStraight;
    _.moveStraight = function(direction) {
      this._diagonalDir = false;
      return ALIAS__moveStraight.call(this, direction);
    };
    //@[ALIAS]
    ALIAS__setDirection = _.setDirection;
    _.setDirection = function(direction) {
      if (this._diagStraigten === true) {
        this._diagonalDir = false;
      }
      return ALIAS__setDirection.call(this, direction);
    };
    
    //@[ALIAS]
    ALIAS__moveDiagonally = _.moveDiagonally;
    _.moveDiagonally = function(horz, vert) {
      var diag, norm;
      if (this.aaIsThisCharCanUseDiagMovement()) {
        diag = this.canPassDiagonally(this._x, this._y, horz, vert);
        norm = this.canPass(this._x, this._y, horz) || this.canPass(this._x, this._y, vert);
        if (diag) {
          this._diagonalDir = AA.Utils.get4Dir(horz, vert);
          this._x = $gameMap.roundXWithDirection(this._x, horz);
          this._y = $gameMap.roundYWithDirection(this._y, vert);
          this._realX = $gameMap.xWithDirection(this._x, this.reverseDir(horz));
          this._realY = $gameMap.yWithDirection(this._y, this.reverseDir(vert));
          this.increaseSteps();
        } else if (norm) {
          this._diagonalDir = false;
          this.moveStraight(this.aaGetOtherDiagDirection(horz, vert));
        }
        this._diagStraigten = false;
        if (this._direction === this.reverseDir(horz)) {
          this.setDirection(horz);
        }
        if (this._direction === this.reverseDir(vert)) {
          this.setDirection(vert);
        }
        return this._diagStraigten = true;
      } else {
        return ALIAS__moveDiagonally.call(this, horz, vert);
      }
    };
  })();
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  _._aaUpdate = function() {
    var e;
    try {
      if (!this.isABS()) {
        return;
      }
      if (Imported.PKD_AnimaX) {
        this.aaUpdateABSAnimaX();
      }
      if (AA.isABSActive()) {
        return this.aaUpdateABS();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Для оптимизации, вынес параметр в общий метод класса
  Game_CharacterBase.aaColExt = function() {
    var e, v;
    if (Game_CharacterBase._aaColExtAA == null) {
      try {
        v = AA.PP.getCollisionPreccissionLevel() / 100;
        if (v < 0) {
          // * Проверка значения
          v = 0;
        }
        if (v > 0.99) {
          v = 0.99;
        }
      } catch (error) {
        e = error;
        AA.w(e);
        v = 0;
      }
      Game_CharacterBase._aaColExtAA = v;
    }
    return Game_CharacterBase._aaColExtAA;
  };
  if (!Imported.PKD_AnimaX) {
    _.isAnimX = function() {
      return false;
    };
  }
  (function() {    // * Общие методы ABS
    // -----------------------------------------------------------------------
    // * Основной метод, является ли персонаж вообще ABS объектом
    // * Тут НЕЛЬЗЯ добавлять доп. проверку на AA.isABSActive()
    _.isABS = function() {
      return this.AAEntity() != null;
    };
    _.AAEntity = function() {
      return this.aaEntity;
    };
    _.AAModel = function() {
      return null;
    };
    _.initABS = function() {
      var ref, ref1;
      if ((ref = this.aaEntity) != null) {
        ref.initABS();
      }
      if ((ref1 = this.AASprite()) != null) {
        ref1.initABS();
      }
    };
    // * Деактивировать АБС режим
    _.stopABS = function() {
      var ref;
      if ((ref = this.aaEntity) != null) {
        ref.deactivate();
      }
    };
    // * Полностью отключить (очистить) АБС режим у персонажа
    _.clearABS = function() {
      this.aaEntity = null;
      return this._aaClearExCollider();
    };
    _.AABattler = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.battler() : void 0;
    };
    _.AASprite = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.sprite() : void 0;
    };
    // * Логика АИ
    _.AALogic = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.logic() : void 0;
    };
    _.inBattle = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.inBattle() : void 0;
    };
    _.isActive = function() {
      var ref;
      return this.isABS() && ((ref = this.AAEntity()) != null ? ref.isActive() : void 0);
    };
    _.onTurnEnd = function() {};
    // * Данный персонаж не может принимать урон (Projectile пролетают через него)
    _.aaIsInvincible = function() {
      return false;
    };
    _.isMyEnemy = function(character) {
      if (!this.isABS()) {
        return false;
      }
      if (character == null) {
        return false;
      }
      if (!character.isABS()) {
        return false;
      }
      return this.AAEntity().isMyEnemy(character.AAEntity());
    };
    // * Логика АБС (только если АБС включена)
    _.aaUpdateABS = function() {
      var ref;
      this._aaUpdateDelayedSkillActions();
      this._aaUpdateTeleportRequest();
      if ((ref = this.AABattler()) != null) {
        ref.aaUpdateABS();
      }
      if (AA.Network.isNetworkGame()) {
        return this.aaUpdateForNetwork();
      }
    };
    _.aaUpdateForNetwork = function() {
      var ref;
      if (!ANGameManager.isMapMaster()) {
        return;
      }
      // * AABattler тут не обновляется, так как у Game_Actor он отдельно
      // * обновляется уже в Alpha NET Z по стандарту
      if ((ref = this.AAEntity()) != null) {
        ref.updateDataObserver();
      }
    };
    // * Специальный идентификатор персонажа на карте (0 - игрок, Х - номер события)
    _.aaCharId = function() {
      return -1;
    };
    _.aaDirection = function() {
      if (this._diagonalDir) {
        return this._diagonalDir;
      } else {
        return this.direction();
      }
    };
    return _.aaIsDodging = function() {
      return false;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Методы ABS (Бой и состояния)
    // -----------------------------------------------------------------------
    // * Когда какое-либо действие было выполненно на мне
    _.aaOnActionOnMe = function(action) {};
    // * Когда персонаж повержен
    // * Отличается от aaOnDeath так как тут надо давать бонусы победившему
    _.aaOnDefeat = function() {};
    // * Когда надо сменить состояние персонажа на Dead (вывести из АБС системы)
    _.aaOnDeath = function() {};
    // * Когда выходит из состояние смерти
    _.aaOnRevive = function() {};
    // * Эффект от навыка с параметром Impulse (сдвиг, толчок)
    _.aaIsCanMoveByImpulse = function() {
      return true;
    };
    _.aaApplyImpulse = function(power, dir, withJump, isReversed = false) {};
    _._aaUpdateTeleportRequest = function() {}; // * Game_Character_AA
    return _._aaOnTeleportPerformed = function() {};
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Эффекты спрайта (тряска и прочее)
    // -----------------------------------------------------------------------
    _.aaClearCharacterEffects = function() {
      // * Первое значение - время
      // * Второе значение DX (отклонение по X)
      this._aaShakeEffectData = [0, 0];
      // * [Запрос, массив данных для сохранения, флаг что надо создать части, DX, DY]
      //TODO: Сохранение не используется пока что
      this._aaShatterEffectData = [false, [], true, 0, 0];
    };
    _.aaMotionDX = function() {
      return this._aaShakeEffectData[1];
    };
    _.aaRequestShakeEffect = function(time = 10) {
      this._aaShakeEffectData[0] = time;
      return AANetworkManager.requestCharacterShakeEffect(this, time);
    };
    _.aaIsShakeRequested = function() {
      return this._aaShakeEffectData[0] > 0;
    };
    _.aaIsShatterRequested = function() {
      return this._aaShatterEffectData[0] === true;
    };
    _.aaRequestShatterEffect = function(dx = 0.5, dy = -4) {
      this._aaShatterEffectData = [true, [], true, dx, dy];
      AANetworkManager.requestCharacterShatterEffect(this, dx, dy);
    };
    _.aaOnShatterEffectCreated = function() {
      return this._aaShatterEffectData[0] = false;
    };
    _.aaIsSupportMotion = function() {
      return false;
    };
    _.aaIsMotionRequested = function() {
      return this.aaMotionType != null;
    };
    _.aaClearMotion = function() {
      this.aaMotionType = null;
      AANetworkManager.requestCharacterMotion(this, this.aaMotionType);
    };
    return _.aaRequestMotion = function(aaMotionType) {
      this.aaMotionType = aaMotionType;
      AANetworkManager.requestCharacterMotion(this, this.aaMotionType);
    };
  })();
  // -----------------------------------------------------------------------

  // * Добавляем метод canMove для всех персонажей
  // * В основном он нужен чтобы AAEntities не ходили во время XAnima
  _.canMove = function() {
    if (this.isAnimX()) {
      if (this.isAnimXIsBusy()) {
        // * Персонаж не может идти, если он выполняет действие анимации
        return false;
      }
    }
    if (AA.isABSMap()) {
      return this.AABattler().canMove();
    }
    return true;
  };
  // * Модификатор скорости движения (исп. в состояни)
  _.aaSpeedMod = function() {
    return this.AABattler().aaSpeedMod();
  };
  // * Позиция с учётом расширенных HitBox
  // * Реализован отдельный метод, так как HitBox учитывается только при поражении навыками
  _.posExt = function(x, y) {
    var d, extHitBoxes, l, r, u;
    //TODO: posExtCol не используется пока что при ExtendedHitBoxes
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      l = this.x - extHitBoxes[3];
      r = this.x + extHitBoxes[1];
      u = this.y - extHitBoxes[0];
      d = this.y + extHitBoxes[2];
      return l <= x && x <= r && u <= y && y <= d;
    } else {
      return this.posExtCol(x, y);
    }
  };
  // * Расширенная позиция, для расширения коллизий атак (прямым нажатием)
  _.posExtCol = function(x, y) {
    var isX, isY, v;
    v = Game_CharacterBase.aaColExt();
    isX = this._realX > x - v && this._realX < x + v;
    isY = this._realY > y - v && this._realY < y + v;
    return isX && isY;
  };
  // * Позиции X на экране, с учётом расширенных HitBox
  _.screenXExt = function() {
    var extHitBoxes, i, k, l, m, points, r, ref, ref1, tw, x;
    points = [this.screenX()]; // * базовая точка
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      r = extHitBoxes[1];
      l = extHitBoxes[3];
      tw = $gameMap.tileWidth();
      // * Точка права (если есть)
      if (r > 0) {
        for (i = k = 1, ref = r; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
          x = $gameMap.adjustX(this._realX + i);
          x = Math.floor(x * tw + tw / 2);
          points.push(x);
        }
      }
      // * Точка слева (если есть)
      if (l > 0) {
        for (i = m = 1, ref1 = l; (1 <= ref1 ? m <= ref1 : m >= ref1); i = 1 <= ref1 ? ++m : --m) {
          x = $gameMap.adjustX(this._realX - i);
          x = Math.floor(x * tw + tw / 2);
          points.push(x);
        }
      }
    }
    return points;
  };
  // * Позиции Y на экране, с учётом расширенных HitBox
  _.screenYExt = function() {
    var d, extHitBoxes, i, k, m, points, ref, ref1, th, u, y;
    points = [this.screenY()]; // * базовая точка
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      u = extHitBoxes[0];
      d = extHitBoxes[2];
      th = $gameMap.tileHeight();
      // * Точка снизу (если есть)
      if (d > 0) {
        for (i = k = 1, ref = d; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
          y = $gameMap.adjustY(this._realY + i);
          y = Math.floor(y * th + th - this.shiftY() - this.jumpHeight());
          points.push(y);
        }
      }
      // * Точка сверху (если есть)
      if (u > 0) {
        for (i = m = 1, ref1 = u; (1 <= ref1 ? m <= ref1 : m >= ref1); i = 1 <= ref1 ? ++m : --m) {
          y = $gameMap.adjustY(this._realY - i);
          y = Math.floor(y * th + th - this.shiftY() - this.jumpHeight());
          points.push(y);
        }
      }
    }
    return points;
  };
  // * Есть ли у персонажа расширенные HitBox для АБС навыков
  _.aaIsHaveExtendedHitBoxes = function() {
    return this.aaGetExtendedHitBoxes() != null;
  };
  // * У событий и персонажей своя реализация
  _.aaGetExtendedHitBoxes = function() {
    return null;
  };
  _.aaUpdateABSAnimaX = function() {}; // * EMPTY (Переопределяется в Game_Character_AnimaX)
  
  // * Дополнительный метод для сетевой игры
  // * Вызывается в AA.Network (через Alias метода Alpha NET Z)
  _.aaFillNetworkDataObserver = function() {
    var e;
    if (this.netDataObserver == null) {
      return;
    }
    try {

    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaIsThisCharCanUseDiagMovement = function() {
    return AA.Input.IsDiagonal === true;
  };
  _.distTo = function(point) {
    return $gameMap.distance(this.x, this.y, point.x, point.y);
  };
  // * Дистанция с учётом расширенной коллизии
  _.distToCol = function(point) {
    return ~~$gameMap.distance(this._realX, this._realY, point.x, point.y);
  };
  _.aaGetOtherDiagDirection = function(horz, vert) {
    if (this.canPass(this._x, this._y, horz)) {
      return horz;
    } else {
      return vert;
    }
  };
  // * Находится ли на Х расстоянии к точке
  _.aaIsNearThePoint = function(point, minDist = 1) {
    var e, sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      return (sx + sy) <= minDist;
    } catch (error) {
      e = error;
      AA.w;
      return false;
    }
  };
  // * Повернуться к цели
  _.aaTurnTowardTarget = function() {
    var e, target;
    try {
      target = this.AAEntity().getTarget();
      if (target == null) {
        return;
      }
      return this.turnTowardCharacter(target);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Поиск пути (диагональное движение)
  _.aaFindDirectionToDiagonal = function(goalX, goalY) {
    var best, bestIndex, closedList, current, deltaX1, deltaX2, deltaY1, deltaY2, diag, direction, g1, g2, goaled, horz, i, index2, j, mapWidth, neighbor, node, nodeList, openList, pos1, pos2, searchLimit, start, vert, x1, x2, y1, y2;
    searchLimit = this.searchLimit();
    mapWidth = $gameMap.width();
    nodeList = [];
    openList = [];
    closedList = [];
    start = {};
    best = start;
    if (this.x === goalX && this.y === goalY) {
      return 0;
    }
    start.parent = null;
    start.x = this.x;
    start.y = this.y;
    start.g = 0;
    start.f = $gameMap.distance(start.x, start.y, goalX, goalY);
    nodeList.push(start);
    openList.push(start.y * mapWidth + start.x);
    while (nodeList.length > 0) {
      bestIndex = 0;
      i = 0;
      while (i < nodeList.length) {
        if (nodeList[i].f < nodeList[bestIndex].f) {
          bestIndex = i;
        }
        i++;
      }
      current = nodeList[bestIndex];
      x1 = current.x;
      y1 = current.y;
      pos1 = y1 * mapWidth + x1;
      g1 = current.g;
      nodeList.splice(bestIndex, 1);
      openList.splice(openList.indexOf(pos1), 1);
      closedList.push(pos1);
      if (current.x === goalX && current.y === goalY) {
        best = current;
        goaled = true;
        break;
      }
      if (g1 >= searchLimit) {
        continue;
      }
      j = 0;
      while (j < 9) {
        direction = 1 + j;
        if (direction === 5) {
          j++;
          continue;
        }
        diag = Math.abs(direction % 2) === 1;
        [horz, vert] = AA.Utils.get8Dir(direction);
        if (diag && this.canPassDiagonally(x1, y1, horz, vert) && (this.canPass(x1, y1, horz) || this.canPass(x1, y1, vert))) {
          x2 = $gameMap.roundXWithDirection(x1, horz);
          y2 = $gameMap.roundYWithDirection(y1, vert);
        } else if (this.canPass(x1, y1, direction)) {
          x2 = $gameMap.roundXWithDirection(x1, direction);
          y2 = $gameMap.roundYWithDirection(y1, direction);
        } else {
          j++;
          continue;
        }
        pos2 = y2 * mapWidth + x2;
        if (closedList.contains(pos2)) {
          j++;
          continue;
        }
        g2 = g1 + 1;
        index2 = openList.indexOf(pos2);
        if (index2 < 0 || g2 < nodeList[index2].g) {
          if (index2 >= 0) {
            neighbor = nodeList[index2];
          } else {
            neighbor = {};
            nodeList.push(neighbor);
            openList.push(pos2);
          }
          neighbor.parent = current;
          neighbor.x = x2;
          neighbor.y = y2;
          neighbor.g = g2;
          neighbor.f = g2 + $gameMap.distance(x2, y2, goalX, goalY);
          if (!best || neighbor.f - neighbor.g < best.f - best.g) {
            best = neighbor;
          }
        }
        j++;
      }
    }
    node = best;
    while (node.parent && node.parent !== start) {
      node = node.parent;
    }
    deltaX1 = $gameMap.deltaX(node.x, start.x);
    deltaY1 = $gameMap.deltaY(node.y, start.y);
    if (deltaY1 > 0 && deltaX1 > 0) {
      return 3;
    } else if (deltaY1 > 0 && deltaX1 < 0) {
      return 1;
    } else if (deltaY1 < 0 && deltaX1 < 0) {
      return 7;
    } else if (deltaY1 < 0 && deltaX1 > 0) {
      return 9;
    }
    if (deltaY1 > 0) {
      return 2;
    } else if (deltaX1 < 0) {
      return 4;
    } else if (deltaX1 > 0) {
      return 6;
    } else if (deltaY1 < 0) {
      return 8;
    }
    deltaX2 = this.deltaXFrom(goalX);
    deltaY2 = this.deltaYFrom(goalY);
    if (Math.abs(deltaX2) > Math.abs(deltaY2)) {
      if (deltaX2 > 0) {
        return 4;
      } else {
        return 6;
      }
    } else if (deltaY2 !== 0) {
      if (deltaY2 > 0) {
        return 8;
      } else {
        return 2;
      }
    }
    return 0;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__erase, ALIAS__initMembers, ALIAS__isCollidedWithEvents, ALIAS__list, ALIAS__searchLimit, ALIAS__setPosition, ALIAS__updateSelfMovement, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.aaInitExtraParams();
  };
  //@[ALIAS]
  //@_aaFindDirCallCount = 0
  ALIAS__isCollidedWithEvents = _.isCollidedWithEvents;
  _.isCollidedWithEvents = function(x, y) {
    var events;
    // * АИ не учитывает события, которые выше или ниже по приоритету
    if (this.isABS()) {
      // * Собираем события в точке X, Y, которые с Normal Priority
      events = $gameMap.eventsXyNt(x, y).filter(function(ev) {
        return ev.isNormalPriority();
      });
      if (events.length <= 0) {
        // * Если таковых нет, то проходим (ниже и выше не учитываем)
        return false;
      }
      return this.isNormalPriority(); // * Если есть, то TRUE, если это событие тоже Normal Priority
    } else {
      return ALIAS__isCollidedWithEvents.call(this, x, y);
    }
  };
  
  //@[ALIAS]
  ALIAS__updateSelfMovement = _.updateSelfMovement;
  _.updateSelfMovement = function() {
    if (this.isABS() && !this.canMove()) {
      return;
    }
    if (this._moveType > 3) {
      if (!this._locked) {
        return this.aaUpdateAIMovement();
      }
    } else {
      return ALIAS__updateSelfMovement.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__searchLimit = _.searchLimit;
  _.searchLimit = function() {
    if (this.isABS() && this.aaIsNearToTarget()) {
      return 6;
    }
    return ALIAS__searchLimit.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__setPosition = _.setPosition;
  _.setPosition = function() {
    ALIAS__setPosition.call(this, ...arguments);
    if (this.isABS()) {
      // * Если мы перемещаем событие, то обновляем его "дом" точку
      return this.aaStoreHomePoint();
    }
  };
  (function() {})();  // * Система анимации XAnima
  // -----------------------------------------------------------------------
  (function() {    // -----------------------------------------------------------------------

    // * Система AAEntity
    // -----------------------------------------------------------------------
    var ALIAS__clearPageSettings, ALIAS__setupPage;
    //@[ALIAS]
    ALIAS__setupPage = _.setupPage;
    _.setupPage = function() {
      // * Сбрасываем профиль
      this._currentAnimaXProfile = null;
      ALIAS__setupPage.call(this);
      this.aaCheckABSEventState();
      this.aaCheckExtraParams();
      if (AA.System.isExCollisionActive()) {
        this.aaInitExCollider();
      }
    };
    //@[ALIAS]
    ALIAS__clearPageSettings = _.clearPageSettings;
    _.clearPageSettings = function() {
      ALIAS__clearPageSettings.call(this);
      if (this.isABS()) {
        return this.clearABS();
      }
    };
  })();
  // -----------------------------------------------------------------------

  //@[ALIAS]
  ALIAS__erase = _.erase;
  _.erase = function() {
    ALIAS__erase.call(this, ...arguments);
    return this._aaClearExCollider();
  };
  //@[ALIAS]
  ALIAS__list = _.list;
  _.list = function() {
    var e, t;
    try {
      // * Вызов общего события, которое было bind к этому событию (SActions)
      if (this._aaExtraEventList != null) {
        t = this._aaExtraEventList;
        // * Один раз, поэтому зануляем
        this._aaExtraEventList = null;
        return [
          {
            // * Команда "Вызов Общего события" внутри этого события
            // * (Так можно использовать this. и есть _eventId)
            code: 117,
            indent: 0,
            parameters: [t]
          }
        ];
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return ALIAS__list.call(this);
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.aaInitExCollider = function() {
    var collidersConfigs, config, e;
    try {
      this._aaClearExCollider();
      if (this._aaIsForceNoColliderByUser()) {
        return;
      }
      collidersConfigs = this._aaGetUserDefinedColliders();
      if ((collidersConfigs != null) && collidersConfigs.length > 0) {
        return this.aaAddExCollider(collidersConfigs);
      } else {
        if (this.aaIsSupportAutoCollider()) {
          config = AA.PP.getDefaultEventCollider();
          config.flag = 'event';
          return this.aaAddExCollider(config);
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaIsForceNoColliderByUser = function() {
    var e, noColliderComment;
    try {
      if ((this.page() != null) && (this.page().list != null)) {
        noColliderComment = KDCore.Utils.getEventCommentValue('aCollider:none', this.page().list);
        if (noColliderComment != null) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaGetUserDefinedColliders = function() {
    var c, colliders, collidersConfigs, config, e, i, len, list;
    try {
      if (this.page() == null) {
        return null;
      }
      collidersConfigs = [];
      list = this.page().list;
      colliders = KDCore.Utils.getEventCommentValueArray('aCollider', list);
      for (i = 0, len = colliders.length; i < len; i++) {
        c = colliders[i];
        try {
          config = AA.Utils.parseColliderConfig(c, 'event');
          if (config != null) {
            collidersConfigs.push(config);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          continue;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return collidersConfigs;
  };
  _.aaIsSupportAutoCollider = function() {
    return this.isNormalPriority();
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e, ref;
    try {
      try {
        if ((ref = this.AABattler()) != null) {
          ref.gev_onABSPaused();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      if (this.AALogic() == null) {
        return;
      }
      if (!this.AALogic().isFreeState()) {
        return this.AALogic().switchToFreeState();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  (function() {    // * Система AAEntity
    // -----------------------------------------------------------------------
    // * Когда мы переключили страницу события, надо пересоздать Battler и активировать АБС
    _.aaIsShouldBeReActivated = function() {
      return this.isABS() && (this.AABattler() == null);
    };
    _.aaCheckABSEventState = function() {
      if (this.aaIsABSEventPage()) {
        //TODO: Проверить переключение с АБС на АБС событие
        return this._initMembersABS();
      } else {
        if (this.isABS()) {
          // * Если переключили страницу, но событие было АИ, то надо отключить
          this.clearABS();
        }
      }
    };
    _.aaIsABSEventPage = function() {
      var ABSComment, e, enemyId;
      try {
        if (this.event() == null) {
          return false;
        }
        if (this.page() == null) {
          return false;
        }
        // * Для сохранения производительности, сперва просто смотрим есть ли ABS комментарий
        ABSComment = KDCore.Utils.getEventCommentValue("ABS", this.list());
        if ((ABSComment != null) && (ABSComment.match(/<ABS:\s*\d+>/) != null)) {
          // * Дополнительная проверка, что указан правильный ID
          enemyId = AA.Utils.Parser.getABSEnemyId(ABSComment);
          if (enemyId > 0) {
            if (AA.Utils.Guard.isProperEnemyIdForABSEvent(enemyId)) {
              // * Данный объект хранится даже после переключения страницы на НЕ АБС
              this.aaEventSettings = new AA.AAEventSettingsParser(this.list());
              //console.info @aaEventSettings
              return true;
            } else {
              AA.w("Enemy ID " + enemyId + " not exists in DB or not have a name");
            }
          } else {
            AA.w("Can't read Enemy ID from <ABS> comment for event " + this.eventId());
          }
        }
        return false;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    _._initMembersABS = function() {
      this.aaEntity = new AAEnemyEntity(this.eventId());
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Основная логика АБС
    // -----------------------------------------------------------------------
    var ALIAS__aaOnActionOnMe, ALIAS__aaOnDeath, ALIAS__aaOnDefeat, ALIAS__aaOnShatterEffectCreated, ALIAS__clearABS, ALIAS__erase, ALIAS__initABS, ALIAS__isActive, ALIAS_aaUpdateABS;
    _.aaCharId = function() {
      return this.eventId();
    };
    // * Этот метод выполняется из отдельного потока для логики АИ
    //$[OUTER]
    _.aaUpdateAILogic = function() {
      var e;
      try {
        if (this.isActive()) {
          if (AA.isABSActive()) {
            return this.AALogic().update();
          }
        } else {
          return $gameTemp.aaClearAILogicThread(this.eventId());
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__initABS = _.initABS;
    _.initABS = function() {
      ALIAS__initABS.call(this);
      this.aaStoreMoveData();
      this._aaLastMovingActionDelay = 0;
      $gameTemp.aaRegisterAILogicThread(this.eventId());
      this._aaInitParallelUserActions();
    };
    _._aaInitParallelUserActions = function() {
      var e, model;
      try {
        model = this.AAModel();
        if (AA.SAaction.isProper(this.AAModel().turnAction) || AA.SAaction.isProper(this.AAModel().turnActionInBattle)) {
          this._aaParallelActionTick = 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.aaClearParallelUserActions();
      }
    };
    //@[ALIAS]
    ALIAS__clearABS = _.clearABS;
    _.clearABS = function() {
      ALIAS__clearABS.call(this);
      $gameTemp.aaClearAILogicThread(this.eventId());
      this.aaClearParallelUserActions();
    };
    _.aaClearParallelUserActions = function() {
      return this._aaParallelActionTick = -1;
    };
    //@[ALIAS]
    ALIAS__isActive = _.isActive;
    _.isActive = function() {
      return ALIAS__isActive.call(this) && !this._erased;
    };
    // * Этот метод работает только когда АБС активна
    //@[ALIAS]
    ALIAS_aaUpdateABS = _.aaUpdateABS;
    _.aaUpdateABS = function() {
      ALIAS_aaUpdateABS.call(this);
      this._aaUpdateDeadState();
      if (this._aaParallelActionTick >= 0) {
        this._aaUpdateParallelUserActions();
      }
    };
    //@[ALIAS]
    ALIAS__aaOnShatterEffectCreated = _.aaOnShatterEffectCreated;
    _.aaOnShatterEffectCreated = function() {
      ALIAS__aaOnShatterEffectCreated.call(this);
      if (!this.isABS()) {
        return;
      }
      this.aaOnDefeat();
    };
    //@[ALIAS]
    ALIAS__erase = _.erase;
    _.erase = function() {
      if (this.isABS()) {
        this.setPriorityType(0); // * Below Characters
      }
      this._aaEraseAnimaXPartsForEvent();
      ALIAS__erase.call(this);
    };
    _._aaEraseAnimaXPartsForEvent = function() {
      var e, spr;
      try {
        if (Imported.PKD_AnimaX !== true) {
          return;
        }
        if (this.AASprite() == null) {
          return;
        }
        spr = this.AASprite();
        if (spr._animaXParts != null) {
          return spr._destroyAnimaXParts(); // * Если есть части
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__aaOnDefeat = _.aaOnDefeat;
    _.aaOnDefeat = function() {
      ALIAS__aaOnDefeat.call(this);
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      if (this.AAModel().lootDropOnDeath === 1) {
        this.aaExecuteEnemyLootVisualDrop();
      }
      this.aaOnDeath();
    };
    // * Данный метод работает только при PKD_ExtendedLoot
    _.aaExecuteEnemyLootVisualDrop = function() {
      var e, gold, goldItem, i, item, items, len;
      try {
        if (!Imported.PKD_ExtendedLoot) {
          return;
        }
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        items = this.AABattler().makeDropItems();
        $gameTemp._pelLastGainEventId = this.eventId();
        if (items.length > 0) {
          for (i = 0, len = items.length; i < len; i++) {
            item = items[i];
            if (item == null) {
              continue;
            }
            //TODO: Переделать под новый метод в Extended Loot
            // * Используем другой метод, чтобы обойти, если опция VisualDrop выключена
            //$gameParty.pelMakeVisualDrop(item, 1)
            SceneManager._scene.pCreateVisualDropItem($gameTemp._pelLastGainEventId, item, 1);
          }
        }
        gold = this.AABattler().gold();
        if ($gameParty.hasGoldDouble()) {
          gold *= 2;
        }
        if (gold >= 1) {
          goldItem = $dataItems[PKD_ExtendedLoot.PP.goldItemId()];
          //$gameParty.pelMakeVisualDrop(goldItem, gold) if goldItem?
          SceneManager._scene.pCreateVisualDropItem($gameTemp._pelLastGainEventId, goldItem, gold);
        }
        // * Это обязательно, чтобы при подборе не повторился Visual Drop
        return $gameTemp._pelLastGainEventId = -1;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__aaOnDeath = _.aaOnDeath;
    _.aaOnDeath = function() {
      var model;
      ALIAS__aaOnDeath.call(this);
      if (Imported.PKD_AnimaX === true && this.isAnimX()) {
        this.clearXAnimParts();
      }
      model = this.AAModel();
      if (model.isHaveDeadSwitch()) {
        // * Включаем self.switch
        AA.SAaction.execute("ss_" + model.deadSwitch + "_true", this);
      } else {
        if (model.eraseOnDead === 1) {
          this.erase();
          // * Только Erase синхронизируется, onDeathAction нет в данном методе
          // * SA синхронизируются отдельно
          AANetworkManager.executeEraseOnDeadAAEvent(this.eventId());
        }
      }
      if (model.isHaveOnDeathAction()) {
        AA.SAaction.execute(model.onDeath, this);
      }
      if (model.isHaveOnDeathVariable()) {
        KDCore.Utils.addToVar(model.onDeathVar, 1);
      }
    };
    //@[ALIAS]
    //TODO: Что делать с xAnimaDead ???
    ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
    _.aaOnActionOnMe = function(action) {
      var result;
      ALIAS__aaOnActionOnMe.call(this, action);
      result = this.AABattler().result();
      if (result == null) {
        return;
      }
      //TODO: model paramter or skill parameter (shake str)
      //%[I] Система смены цели в зависимости от полученного урона
      if (result.isHit() && result.hpDamage > 0) {
        if (this.aaInSkillCastingProcess()) {
          this.aaOnEventWhileCasting('hit');
        }
        this.aaRequestShakeEffect();
        // * Если ещё живой, то будет onHit
        if (this.AABattler().isAlive()) {
          AA.SAaction.execute(this.AAModel().onHit, this);
          if (action.isPlayerActionOwner()) {
            this.aaSetPartyAIOnPlayerAttackFlag();
          }
          this.aaCheckBattleStartInitiation(action);
        }
      }
      if (!this.AABattler().isAlive()) {
        this.aaOnKilledBy(action);
      }
    };
    // * Данный метод проверет, стоит ли врагу "агриться" на того кто ему нанёс урон
    // * Сейчас это работает для не агресивных врагов
    _.aaCheckBattleStartInitiation = function(action) {
      var char, e, subject;
      try {
        subject = action.subject();
        char = subject.AACharacter();
        if ((char != null) && this.isMyEnemy(char)) {
          //TODO: Some agro state, or check is current target is valid for now (like in AABS)
          if (this.AALogic().isBattleState()) {
            if (Math.random() > 0.55) {
              this.AAEntity().setTarget(char);
              return this.aaOnTargetChanged();
            }
          } else {
            // * We checked that we not in Battle State, so we directly use state 0
            return this.AALogic().getStateFlow(0).tryStartFightWithTarget(char);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaSetPartyAIOnPlayerAttackFlag = function() {
      if (!$gamePlayer.aaIsHaveAnyABSFollower()) {
        return;
      }
      $gameTemp._aaPartyAI_flag_playerAttackSomeone = this.eventId();
      // * Убираем флаг через время
      setTimeout((function() {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerAttackSomeone = null : void 0;
      }), 1000);
    };
    _.aaOnKilledBy = function(action) {
      var e;
      try {
        if (action.isPlayerTeamOwner()) {
          if (this.AAModel().autoExp === 1) {
            // * Если Exp Pop Up должен появляться над "дающим" опыт врагом
            $gameTemp.__aaExpGiver = this;
            $gameTemp.__aaExpReceiver = action.subject();
            uAPI.gainExpForEnemyEv(this.eventId());
            console.log($gameTemp.__aaExpReceiver);
            // * Надо обнулять сразу
            $gameTemp.__aaExpGiver = null;
            $gameTemp.__aaExpReceiver = null;
          }
          if (this.AAModel().isHaveAfterDeathBonus()) {
            return uAPI.spawnFlyingBonus(this.eventId(), this.AAModel().bonusOnDeadIds);
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _._aaUpdateDeadState = function() {
      if (this.isActive() && !this.AABattler().isAlive()) {
        // * Отключаем АБС для этого события
        this.stopABS();
        // * Если параметр включён, запускаем эффект
        if (this.AAModel().shatterEffect === 1) {
          this.aaRequestShatterEffect(); // * Иначе сразу
        } else {
          this.aaOnDefeat();
        }
      }
    };
    // * Обработка параллельный пользовательских действий (из Model)
    _._aaUpdateParallelUserActions = function() {
      var e, model;
      try {
        // * Используется обычный таймер, а не KDCore.TimedUpdate, чтобы сохранялось
        // * и загружалось
        this._aaParallelActionTick++;
        if (this._aaParallelActionTick >= 60) {
          this._aaParallelActionTick = 0;
          model = this.AAModel();
          AA.SAaction.execute(model.turnAction, this);
          if (this.inBattle()) {
            AA.SAaction.execute(model.turnActionInBattle, this);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.aaClearParallelUserActions();
      }
    };
    _._aaIsInBattleAnimaXState = function() {
      return this.AAEntity().inBattle();
    };
    _.aaIsCanMoveByImpulse = function() {
      return this.isABS() && !this.AAModel().isHeavy();
    };
    _.aaIsNearToTarget = function() {
      var dist, e, target;
      try {
        target = this.AAEntity().getTarget();
        if (target == null) {
          return false;
        }
        dist = this.distTo(target);
        if (dist >= 2) {
          return false;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnTargetChanged = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Дополнительные возможности АБС события
    // -----------------------------------------------------------------------
    // * Запускает общее события внутри данного события (т.е. внутри себя вызов общего)
    // * Это позволяет использовать this. и менять АБС параметры события
    _.aaStartCommonEvent = function(ceId) {
      var commonEvent, e;
      try {
        this._aaExtraEventList = null;
        if (ceId <= 0) {
          return;
        }
        //"Call outer CE ".p(ceId)
        commonEvent = $dataCommonEvents[ceId];
        if (commonEvent == null) {
          return;
        }
        this._aaExtraEventList = ceId;
        // * Переключаем напрямую, без метода start(), так как не нужен Lock
        this._starting = true;
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    // * Было ли данное событие добалвено на карту динамически
    _.aaIsSpawned = function() {
      return false;
    };
    _.aaIsLabeledAs = function(label) {
      var e;
      try {
        return this.AAModel().label === label;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
  })();
  // -----------------------------------------------------------------------

  // * Для оптимизации игры, алгоритмы проверки окружён ли персонаж отключены на событии
  //$[OVER]
  _.aaInitNoPassFlagThread = function() {}; //*EMPTY
  
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    return this._aaExtendedHitBox;
  };
  //$[OVER]
  _.aaIsThisCharCanUseDiagMovement = function() {
    return AA.Input.IsDiagonalForAI === true;
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------
//TODO: СБРОС ЦЕЛИ
//TODO: ОФФСЕТ ДЛЯ ВЫБОРА
//TODO: МИНИ ХП БАР
// Также добавить управление ним во время игры (один из трёх типов)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.AAModel = function() {
    return this.AAEntity().model();
  };
  _.aaSmartPathRefreshTime = function() {
    var e, model;
    try {
      if (!this.isABS()) {
        return 30;
      }
      model = this.AAModel();
      if ((model != null) && (model.smartPathRefreshTime != null)) {
        return model.smartPathRefreshTime;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 30;
  };
  // * Изменить параметр AAModel у данного события
  _.aaChangeModelParam = function(paramName, newValue) {
    var e, model;
    try {
      if (!String.any(paramName)) {
        return;
      }
      model = this.AAModel();
      if (model == null) {
        return;
      }
      //log = "Model param: " + paramName + " changed to " + newValue
      //log.p()
      return model[paramName] = newValue;
    } catch (error) {
      // * Надо может какой то метод что параметры были изменены?
      //TODO: some refresh or _convertParameters? on onParamsChanged?
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.aaIsAICanTeleportIn = function() {
    if (this.aaInSkillCastingProcess()) {
      return false;
    }
    return this.AAModel().isCanTeleportIn() && this.aaIsAIReadyForNextTeleport() && this.aaIsAITeleportInPointExists();
  };
  _.aaIsAICanTeleportOut = function() {
    if (this.aaInSkillCastingProcess()) {
      return false;
    }
    return this.AAModel().isCanTeleportOut() && this.aaIsAIReadyForNextTeleport() && this.aaIsAITeleportOutPointExists();
  };
  _.aaIsAIReadyForNextTeleport = function() {
    if (this._aaTeleportTimer == null) {
      this._aaTeleportTimer = 0;
    }
    this._aaTeleportTimer++;
    // * Если Delay между телепортами прошёл
    if (this._aaTeleportTimer >= this.AAModel().gTeleportDelay() / 60) {
      this._aaTeleportTimer = 0;
      if (!$gameTemp._aaIsTeleportIsBusy && KDCore.Utils.isChanceIsGood(this.AAModel().gTeleportRate())) {
        return true;
      }
    }
    return false;
  };
  // * Чтобы боты не телепортировались одновременно
  _.aaPrepareSafeTeleportForAI = function() {
    $gameTemp._aaIsTeleportIsBusy = true;
    setTimeout((function() {
      var e;
      try {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaIsTeleportIsBusy = null : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }), 500);
  };
  //TODO: Переделать, добавить проверку поиска пути к точке телепорта
  _.aaIsAITeleportInPointExists = function() {
    var candidatePoints, dist, e, target;
    this._aaLastTeleportPoint = null;
    target = this.AAEntity().getTarget();
    if (target == null) {
      return false;
    }
    dist = this.distTo(target);
    if (dist <= 1) {
      return false;
    }
    if (dist > this.AAModel().gTeleportDistIn()) {
      return false;
    }
    try {
      candidatePoints = AA.Utils.Math.getAdjacentPoints(target.x, target.y);
      if ((candidatePoints != null) && candidatePoints.length > 0) {
        this._aaLastTeleportPoint = this.aaFilterProperTeleportPoint(candidatePoints);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaLastTeleportPoint = null;
    }
    return this._aaLastTeleportPoint != null;
  };
  _.aaFilterProperTeleportPoint = function(points) {
    var e, goodPoints, i, len, p;
    try {
      goodPoints = [];
      for (i = 0, len = points.length; i < len; i++) {
        p = points[i];
        if (this.canPass(p.x, p.y, this.direction()) && (p.x !== this.x && p.y !== this.y)) {
          goodPoints.push(p);
        }
      }
      if (goodPoints.length > 0) {
        return goodPoints.sample();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaIsAITeleportOutPointExists = function() {
    var candidatePoints, dist, e, outDist, target;
    this._aaLastTeleportPoint = null;
    target = this.AAEntity().getTarget();
    if (target == null) {
      return false;
    }
    dist = this.distTo(target);
    outDist = this.AAModel().gTeleportDistOut();
    if (dist > outDist) {
      return false;
    }
    try {
      candidatePoints = AA.Utils.Math.getPointsOutRadius(this.x, this.y, outDist);
      if ((candidatePoints != null) && candidatePoints.length > 0) {
        this._aaLastTeleportPoint = this.aaFilterProperTeleportPoint(candidatePoints);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaLastTeleportPoint = null;
    }
    return this._aaLastTeleportPoint != null;
  };
  _.aaMoveTypeTeleportToTarget = function() {
    var e;
    try {
      if (this.aaIsAICanTeleportIn()) {
        return this.aaPerformAITeleport();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaPerformAITeleport = function() {
    var e, teleportEndAnim, teleportStartAnim, x, y;
    try {
      if (this._aaLastTeleportPoint == null) {
        return;
      }
      this.aaPrepareSafeTeleportForAI();
      ({x, y} = this._aaLastTeleportPoint);
      ({teleportStartAnim, teleportEndAnim} = this.AAModel());
      this.aaTeleport({x, y}, teleportStartAnim, teleportEndAnim);
      return this._aaLastTeleportPoint = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaMoveTypeTeleportFromTarget = function() {
    var e;
    try {
      if (this.aaIsAICanTeleportOut()) {
        return this.aaPerformAITeleport();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  
  //$[OVER]
  _._aaOnTeleportPerformed = function() {
    var e;
    if (!this.isABS()) {
      return;
    }
    try {
      return this.aaTurnTowardTarget();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Дополнительные параметры, которые расширяют возможности взаимодействия событий в АБС
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  // * При попадании Projectile в событие
  _.aaOnVectorHit = function(skillId) {
    var action, e, i, len, ref;
    if (!this.aaIsHaveVectorHitAction(skillId)) {
      // * Если нет для skillId ничего, то смотрим общие - 0
      skillId = 0;
      if (!this.aaIsHaveVectorHitAction(0)) {
        return;
      }
    }
    try {
      ref = this._aaMapSkillVectorHitActions[skillId];
      for (i = 0, len = ref.length; i < len; i++) {
        action = ref[i];
        AA.SAaction.execute(action, this);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Блокирует ли данное событие Visor
  _.aaIsBlockVision = function() {
    return this._aaNoVisionPass === true;
  };
  // * Есть ли действие при попадании конкретного Vector?
  _.aaIsHaveVectorHitAction = function(skillId) {
    var actions;
    if (this._aaMapSkillVectorHitActions == null) {
      return false;
    }
    actions = this._aaMapSkillVectorHitActions[skillId];
    return (actions != null) && !actions.isEmpty();
  };
  // * Если ли флаг блокировки спавна у этого события
  _.aaIsHaveSpawnBlockFlag = function() {
    return this._aaBlockSpawnRadius > 0;
  };
  // * Является ли событие точкой спавна
  _.aaIsHaveSpawnPointId = function() {
    return this._aaSpawnPointId != null;
  };
  // * Есть ли локатор у данного события
  _.aaIsHaveLocator = function() {
    return this._aaLocatorConfig != null;
  };
  // * Инициализация расширенных параметров события
  _.aaInitExtraParams = function() {
    this._aaMapSkillVectorBlockList = null;
    this._aaMapSkillVectorHitActions = null;
    this._aaMapSkillVectorOffset = 0;
    this._aaExtendedHitBox = null;
    this._aaNoVisionPass = false;
    this._aaBlockSpawnRadius = 0;
    this._aaSpawnPointId = null;
    this._aaSpawnPointStep = 0;
    this._aaSpawnPointSpawnedCount = 0;
    this._aaLocatorConfig = null;
  };
  // * Проверка дополнительных параметров, которые могут касаться не только АА но и всех событий
  _.aaCheckExtraParams = function() {
    this.aaInitExtraParams();
    if (this.page() == null) {
      return;
    }
    this._aaExtractVectorOffsetParam();
    this._aaExtractVectorHitActions();
    this._aaExtractVectorBlockList();
    this._aaExtractExtendedHitBoxes();
    this._aaExtractNoVisionPass();
    this._aaExtractBlockSpawn();
    this._aaExtractSpawnPoint();
    this._aaExtractLocator();
  };
  // * Извлекает параметр смщенеия вектора для данного события
  // * Т.е. смещение начала графики, когда данное событие "выпускает" вектор из себя
  // * <vectorOffset:X>
  _._aaExtractVectorOffsetParam = function() {
    var e, param, svOffset;
    try {
      svOffset = KDCore.Utils.getEventCommentValue("vectorOffset", this.list());
      if (svOffset == null) {
        return;
      }
      param = AA.Utils.Parser.extractABSParameter(svOffset);
      if (param != null) {
        return this._aaMapSkillVectorOffset = param[1];
      }
    } catch (error) {
      //console.info(@_aaMapSkillVectorOffset)
      e = error;
      return AA.warning(e);
    }
  };
  // * Извлекает все onVectorHit действия
  // * Пример: <onVectorHit_307:ss_A_true>
  // * Можно 0 - тогда будет для всех навыков (для любого) или просто onVectorHit:SA>
  _._aaExtractVectorHitActions = function() {
    var action, actionData, args, e, i, len, onHitActions, skillId;
    try {
      onHitActions = KDCore.Utils.getEventCommentValueArray("onVectorHit", this.list());
      if (onHitActions.isEmpty()) {
        return;
      }
      this._aaMapSkillVectorHitActions = {};
      for (i = 0, len = onHitActions.length; i < len; i++) {
        action = onHitActions[i];
        try {
          actionData = AA.Utils.Parser.extractABSParameterAny(action);
          args = actionData[0].split("_");
          if (args.length > 1) {
            skillId = parseInt(args[1]);
          } else {
            skillId = 0; // * any
          }
          this._aaRegisterOnHitActionForSkill(skillId, actionData[1]);
        } catch (error) {
          e = error;
          AA.warning(e);
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Регестрирует SAction для навыка skillId при OnVectorHit
  _._aaRegisterOnHitActionForSkill = function(skillId, actionString) {
    var e;
    try {
      if (this._aaMapSkillVectorHitActions[skillId] == null) {
        this._aaMapSkillVectorHitActions[skillId] = [];
      }
      this._aaMapSkillVectorHitActions[skillId].push(actionString);
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Извлекает список ID навыков, которые блокирет данное событие
  // * <vectorBlock:no> - ничего не блокирует
  // * <vectorBlock:all> - всё блокирует (по умолчанию)
  // * <vectorBlock: 301, 302> - НЕ блокирует 301 и 302 навыки
  _._aaExtractVectorBlockList = function() {
    var e, param, vectorBlockList;
    try {
      vectorBlockList = KDCore.Utils.getEventCommentValue("vectorBlock", this.list());
      if (vectorBlockList == null) {
        return;
      }
      param = AA.Utils.Parser.extractABSParameterAny(vectorBlockList);
      if (param[1] === "no") {
        this._aaMapSkillVectorBlockList = [];
      } else if (param[1] === "all") {
        this._aaMapSkillVectorBlockList = null;
      } else {
        this._aaMapSkillVectorBlockList = AA.Utils.Parser.convertArrayFromParameter(param[1]);
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Расширенные границы коллизии события (учитывается только для АБС навыков)
  // * UP, RIGHT, DOWN, LEFT (по часовой)
  // * Пример: <extraHitBoxes:1,0,0,0> - расширение на 1 клетку вверх
  _._aaExtractExtendedHitBoxes = function() {
    var e, param, values;
    try {
      values = KDCore.Utils.getEventCommentValue("extraHitBoxes", this.list());
      if (values == null) {
        return;
      }
      param = AA.Utils.Parser.extractABSParameterAny(values);
      this._aaExtendedHitBox = AA.Utils.Parser.convertArrayFromParameter(param[1]);
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaExtendedHitBox = null;
    }
  };
  // * Если есть этот комментарий, Visor АИ не может проходить через это событие
  // * <noVisionPass>
  //TODO: Добавить except ID событий (или врагов) как с vectorBlock
  //TODO: Т.е. только определённые враги могут видеть через этот объект
  _._aaExtractNoVisionPass = function() {
    var e, value;
    try {
      value = KDCore.Utils.getEventCommentValue("noVisionPass", this.list());
      // * Не важно какое значение, если есть комментарий, значит noVisionPass есть
      this._aaNoVisionPass = value != null;
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaNoVisionPass = false;
    }
  };
  _._aaExtractBlockSpawn = function() {
    var e, value;
    try {
      value = KDCore.Utils.getEventCommentValue("disableSpawn", this.list());
      if (value == null) {
        return;
      }
      value = AA.Utils.Parser.extractABSParameterAny(value);
      if (value != null) {
        this._aaBlockSpawnRadius = parseInt(value[1]);
      }
      if (this._aaBlockSpawnRadius > 0) {
        // * Для производительности, устанавливаем флаг на карте, что существует blockSpawn
        $gameMap.aaRegisterBlockSpawnEventExist();
      }
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaBlockSpawnRadius = 0;
    }
  };
  // * Точка спавна, определяется только ID, а настройки берутся из параметров плагина
  // * <absSpawnPoint:ID>
  _._aaExtractSpawnPoint = function() {
    var e, id, value;
    try {
      value = KDCore.Utils.getEventCommentValue("absSpawnPoint", this.list());
      if (value == null) {
        return;
      }
      value = AA.Utils.Parser.extractABSParameterAny(value);
      id = value[1];
      // * Если заданы настройки точки спавна
      if (AA.PP.getSpawnPointSettings(id) != null) {
        this._aaSpawnPointId = id;
        // * Для оптимизации
        $gameTemp.aaSpawnPointExistsOnMap = true;
      } else {
        AA.w("You trying use spawn point " + id + ", but not define setting in Plugin Parameters");
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaSpawnPointId = null;
    }
  };
  // * Локатор. Ищет персонажа в радиусе и активирует действие
  // * <absLocator:RADIUS, SERACH_EVENT_TYPE, CE_ID, LOOP>
  // * SERACH_EVENT_TYPE:
  // * 0 - player
  // * X - teamId
  // * -1 - my team Id (only for AA events) OR any ABS event
  // * -2 - any NOT ABS event
  // * -3 - any event (not abs || abs)
  // * -4 - all (any event + player)
  _._aaExtractLocator = function() {
    var e, value;
    try {
      value = KDCore.Utils.getEventCommentValue("absLocator", this.list());
      if (value == null) {
        return;
      }
      value = AA.Utils.Parser.extractABSParameterAny(value);
      this._aaLocatorConfig = AA.Utils.Parser.convertArrayFromParameter(value[1]);
      return $gameTemp.aaLocatorEventExistsOnMap = this.aaIsHaveLocator();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this._aaLocatorConfig = null;
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__aaFillNetworkDataObserver, ALIAS__aaUpdateForNetwork, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[ALIAS]
  ALIAS__aaUpdateForNetwork = _.aaUpdateForNetwork;
  _.aaUpdateForNetwork = function() {
    var ref;
    ALIAS__aaUpdateForNetwork.call(this);
    if (!ANGameManager.isMapMaster()) {
      return;
    }
    if ((ref = this.AABattler()) != null) {
      ref._updateDataObserver();
    }
  };
  
  //@[ALIAS]
  ALIAS__aaFillNetworkDataObserver = _.aaFillNetworkDataObserver;
  _.aaFillNetworkDataObserver = function() {
    ALIAS__aaFillNetworkDataObserver.call(this);
    // * Будем хранить точку "дома", чтобы АИ
    // мог вернуться домой, даже если
    // мастер карты был сменён в бою
    this.aaResetHomePoint();
    this.netDataObserver.addFields(this, ["homePoint"]);
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------
//TODO: Помимо обновления раз в 1 секундку
// * Сделать так что когда приходит какой-либо Action
// * на событие, то ещё раз сразу обновить DataObserver 


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__chaseCharacter, ALIAS__initMembers, ALIAS__isActive, ALIAS__isVisible, ALIAS__refresh, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  //@[ALIAS]
  ALIAS__isActive = _.isActive;
  _.isActive = function() {
    return ALIAS__isActive.call(this, ...arguments) && (this.actor() != null);
  };
  //@[ALIAS]
  ALIAS__isVisible = _.isVisible;
  _.isVisible = function() {
    var result;
    result = ALIAS__isVisible.call(this, ...arguments);
    if (this.isABS()) {
      return result && this.isActive() && !this.aaIsKilledNow();
    }
    return result;
  };
  
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this, ...arguments);
    this._moveType = 0;
    this._aaSetupInitialABSParameters();
  };
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this, ...arguments);
    setTimeout((() => {
      return this._aaRefreshABS();
    }), 200);
  };
  //@[ALIAS]
  ALIAS__chaseCharacter = _.chaseCharacter;
  _.chaseCharacter = function(character) {
    if (this.aaIsInBattleState() || this.aaIsInReturnState()) {

    } else {
      // * EMPTY
      ALIAS__chaseCharacter.call(this, ...arguments);
      this._diagonalDir = false; // * Без этого персонаж дёргается при диагональном движении
    }
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    if (!this.isABS()) {
      return;
    }
    if (!AA.isABSActive()) {
      return;
    }
    if (!this.isActive()) {
      return;
    }
    if (this.aaIsKilledNow()) {
      return;
    }
    this.aaUpdateABS();
    if (this.aaIsInReturnState()) {
      this.aaUpdateReturnState();
    }
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__aaOnActionOnMe, ALIAS__aaOnDeath, ALIAS__aaOnDefeat, ALIAS__aaUpdateABS, ALIAS__clearABS, ALIAS__initABS, _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  _.AAModel = function() {
    return this.AAEntity().model();
  };
  _.aaCharId = function() {
    return this._memberIndex * -1;
  };
  _.actorId = function() {
    var e;
    try {
      if (this.actor() != null) {
        return this.actor().actorId();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  // * После смены сцены (если потеряли поток логики)
  _.aaIsShouldBeReActivated = function() {
    return this.isABS() && !$gameTemp.aaIsHaveAILogicThreadFor();
  };
  _.aaIsInBattleState = function() {
    return this._aaMainAIState === 1;
  };
  _.aaIsInReturnState = function() {
    return this._aaMainAIState === 2;
  };
  _.aaIsInFreeState = function() {
    return this._aaMainAIState === 0;
  };
  _.aaIsKilledNow = function() {
    return this._aaBeenKilled === true;
  };
  // * Этот метод вызывается для выхода из АИ логики и возвращения к игроку
  _.aaForceResetAILogicState = function() {
    this._aaChangeAllyAIMainStateTo(2);
  };
  // * Этот метод вызывается для выхода из АИ логики снова в обычного Follower
  _.aaForceStopAILogic = function() {
    var e;
    try {
      this._aaChangeAllyAIMainStateTo(0);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  _.aaRefreshABSThread = function() {
    //TODO: PARTY UPD Нормельная система смерти!!!
    if (this.isABS() && this.aaIsKilledNow() === true && this.AABattler().isAlive()) {
      this.aaRevivePartyMember();
      return;
    }
    if (!$gameTemp.aaIsHaveAILogicThreadFor(this.aaCharId())) {
      $gameTemp.aaRegisterAILogicThread(this.aaCharId());
    }
  };
  _.aaRevivePartyMember = function() {
    var e;
    try {
      this._aaBeenKilled = false;
      this.initABS();
      this.AAEntity().activate();
      return this.refresh();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e, ref;
    try {
      try {
        if ((ref = this.AABattler()) != null) {
          ref.gev_onABSPaused();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      if (this.AALogic() == null) {
        return;
      }
      return this.aaForceStopAILogic();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  //@[ALIAS]
  ALIAS__initABS = _.initABS;
  _.initABS = function() {
    ALIAS__initABS.call(this);
    this._aaLastMovingActionDelay = 0;
    this.aaRefreshABSThread();
    this._aaInitParallelUserActions();
    if (AA.System.isExCollisionActive()) {
      this._initExCollForABS();
    }
  };
  _._aaInitParallelUserActions = function() {
    var e, model;
    try {
      model = this.AAModel();
      if (AA.SAaction.isProper(this.AAModel().turnAction) || AA.SAaction.isProper(this.AAModel().turnActionInBattle)) {
        this._aaParallelActionTick = 0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaClearParallelUserActions();
    }
  };
  //@[ALIAS]
  ALIAS__clearABS = _.clearABS;
  _.clearABS = function() {
    ALIAS__clearABS.call(this);
    this.aaForceStopAILogic();
    $gameTemp.aaClearAILogicThread(this.aaCharId());
    this.aaClearParallelUserActions();
  };
  _.aaClearParallelUserActions = function() {
    return this._aaParallelActionTick = -1;
  };
  //@[ALIAS]
  ALIAS__aaUpdateABS = _.aaUpdateABS;
  _.aaUpdateABS = function() {
    ALIAS__aaUpdateABS.call(this, ...arguments);
    this._aaUpdateABSMoving();
    this._aaUpdateDeadState();
    if (this._aaParallelActionTick >= 0) {
      this._aaUpdateParallelUserActions();
    }
    if (!this.aaIsInBattleState()) {
      this._aaUpdateMainStateTransferThread();
    }
  };
  _._aaUpdateABSMoving = function() {
    if (!this.aaIsInBattleState()) {
      return;
    }
    if (!this.canMove()) {
      return;
    }
    this.aaUpdateAIMovement();
  };
  _._aaUpdateDeadState = function() {
    if (this.isActive() && !this.AABattler().isAlive()) {
      // * Отключаем АБС для этого события
      this.stopABS();
      this.aaOnDefeat();
    }
  };
  //@[ALIAS]
  ALIAS__aaOnDefeat = _.aaOnDefeat;
  _.aaOnDefeat = function() {
    ALIAS__aaOnDefeat.call(this, ...arguments);
    this.aaForceStopAILogic();
    this.aaOnDeath();
  };
  //@[ALIAS]
  ALIAS__aaOnDeath = _.aaOnDeath;
  _.aaOnDeath = function() {
    var model;
    ALIAS__aaOnDeath.call(this, ...arguments);
    if (Imported.PKD_AnimaX === true && this.isAnimX()) {
      this.clearXAnimParts();
    }
    model = this.AAModel();
    if (model.isHaveOnDeathAction()) {
      AA.SAaction.execute(model.onDeath, this);
    }
    if (model.isHaveOnDeathVariable()) {
      KDCore.Utils.addToVar(model.onDeathVar, 1);
    }
    //TODO: PARTY UPD Нормельная система смерти!!!
    this._aaBeenKilled = true;
    this.refresh();
    "ON DEATH AA AI".p();
  };
  // * Обработка параллельный пользовательских действий (из Model)
  _._aaUpdateParallelUserActions = function() {
    var e, model;
    try {
      // * Используется обычный таймер, а не KDCore.TimedUpdate, чтобы сохранялось
      // * и загружалось
      this._aaParallelActionTick++;
      if (this._aaParallelActionTick >= 60) {
        this._aaParallelActionTick = 0;
        model = this.AAModel();
        AA.SAaction.execute(model.turnAction, this);
        if (this.inBattle()) {
          AA.SAaction.execute(model.turnActionInBattle, this);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaClearParallelUserActions();
    }
  };
  //@[ALIAS]
  ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
  _.aaOnActionOnMe = function(action) {
    var result;
    ALIAS__aaOnActionOnMe.call(this, action);
    result = this.AABattler().result();
    if (result == null) {
      return;
    }
    if (result.isHit() && result.hpDamage > 0) {
      this.aaRequestShakeEffect();
      // * Если ещё живой, то будет onHit
      if (this.AABattler().isAlive()) {
        AA.SAaction.execute(this.AAModel().onHit, this);
        // * Для условия
        this._aaAllyGotDamage = true;
      }
    }
    if (!this.AABattler().isAlive()) {
      this.aaOnKilledBy(action);
    }
  };
  _._aaIsInBattleAnimaXState = function() {
    return this.AAEntity().inBattle();
  };
  _.aaIsCanMoveByImpulse = function() {
    var e;
    try {
      if (!this.isABS()) {
        return false;
      }
      if (this.AAModel().isHeavy()) {
        return false;
      }
      if (this.AABattler().aaIsEquippedInHeavyArmor()) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  _.aaOnKilledBy = function(action) {};
  _.aaSmartPathRefreshTime = function() {
    return 10;
  };
  _._aaSetupInitialABSParameters = function() {
    // 0 - follower (ABS like OFF)
    // 1 - Battle (ABS controll)
    // 2 - Looting (not implemented)
    this._aaMainAIState = 0;
    this._aaMainStateTransferCheckTimer = 0;
  };
  _._aaUpdateMainStateTransferThread = function() {
    this._aaMainStateTransferCheckTimer++;
    if (this._aaMainStateTransferCheckTimer >= 30) {
      this._aaUpdateMainStateTransferConditions();
      this._aaMainStateTransferCheckTimer = 0;
    }
  };
  _._aaUpdateMainStateTransferConditions = function() {
    var conditions, e;
    conditions = this._aaConvertMainStateConditions(this.AAModel().getBattleStartConditions());
    this._aaClearConditionsTempFlags();
    try {
      //console.log conditions
      // * Проверяем все условия
      if (eval(conditions)) {
        this._aaChangeAllyAIMainStateTo(1);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      KDCore.warning("Check Ally AI battleConditionType");
      this.aaForceResetAILogicState();
      // * Force change to proper conditions
      this.AAModel().battleConditionType = "seeEnemy";
    }
  };
  _._aaClearConditionsTempFlags = function() {
    return this._aaAllyGotDamage = false;
  };
  _._aaConvertMainStateConditions = function(conditionString) {
    var e, i, item, len, method, ref;
    try {
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      ref = ['seeEnemy', 'gotDamage', 'playerAction', 'playerGotDamage', 'playerInDanger', 'playerAttacksSomeone', 'condition'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAICondition_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  _._aaChangeAllyAIMainStateTo = function(newStateIndex) {
    if (this._aaMainAIState !== newStateIndex) {
      this._aaMainAIState = newStateIndex;
      this._aaOnAIMainStateChanged();
    }
  };
  _._aaOnAIMainStateChanged = function() {
    if (this.aaIsInBattleState()) {
      // * Переходим в режим поиска (выбора) цели
      this.AALogic().switchToFreeState();
    }
    console.log("STATE CHANGED to " + this._aaMainAIState);
    this.setThrough(this.aaIsInFreeState());
  };
  _._aaRefreshABS = function() {
    var e;
    try {
      //TODO: PARTY UPD Надо делать нормальную обработку ABS состояния в зависимости от Visible
      //TODO: PARTY UPD нормельная обработка смерти игрока
      if ($gamePlayer.AABattler() == null) {
        this.clearABS();
        return;
      }
      if (!$gamePlayer.AABattler().isAlive()) {
        this.clearABS();
        return;
      }
      if ((this.actor() != null) && this.actor().isSupportAIControl()) {
        if (this.aaEntity != null) {
          if (this.aaEntity.actorId !== this.actorId()) {
            return this._aaInitNewABSEntity();
          } else {

          }
        } else {
          // * NOTHING, same Actor
          return this._aaInitNewABSEntity();
        }
      } else {
        return this.clearABS();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaInitNewABSEntity = function() {
    if (this.isABS()) {
      this.clearABS();
    }
    this._aaBeenKilled = false;
    this.aaEntity = new AAAllyEntity(this.actorId());
    if (this.aaEntity.character() != null) {
      this.initABS();
    } else {
      KDCore.warning("Follower character not found on Game Map");
      this.clearABS();
    }
  };
  // * Этот метод выполняется из отдельного потока для логики АИ
  //$[OUTER]
  _.aaUpdateAILogic = function() {
    var e;
    try {
      if (!this.isVisible()) {
        return;
      }
      if (!this.aaIsInBattleState()) {
        return;
      }
      if (this.isActive()) {
        if (AA.isABSActive()) {
          return this.AALogic().update();
        }
      } else {
        return $gameTemp.aaClearAILogicThread(this.aaCharId());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Точка (дом) союзника - это игрок
  //$[OVER]
  _.aaMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      return this.aaMoveTypeToPoint($gamePlayer);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaUpdateReturnState = function() {
    if (!this.canMove()) {
      this.aaForceStopAILogic();
      return;
    }
    if (!this.isMoving()) {
      if (!this.aaIsNearThePoint($gamePlayer)) {
        this.aaMoveTypeReturnToHomePoint();
      } else {
        this.aaForceStopAILogic();
      }
    }
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  // * Данный метод является только лишь условием, он только проверяет наличие целей, но
  // не устанавливает ни одну из них, т.к. для этого есть другие услвоия
  _._aaAICondition_seeEnemy = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this, this.AAModel().gViewRadius());
      if ((targetsAround != null) && targetsAround.length > 0) {
        targetsAround = targetsAround.filter((t) => {
          return AAVisionManager.isVisionLineIsFree(this, t);
        });
        return targetsAround.length > 0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_gotDamage = function() {
    return this._aaAllyGotDamage === true;
  };
  _._aaAICondition_playerGotDamage = function() {
    return $gameTemp._aaPartyAI_flag_playerGotDamage === true;
  };
  _._aaAICondition_playerInDanger = function() {
    return $gamePlayer._aaIsInBattleAnimaXState();
  };
  // * Алтернатива (но в методы выше этот же код, чтоыб два раза не выполнять)
  //playerEnemies =
  //    AATargetsManager.getAllWhoHavePlayerAsTargetInRange(@AAModel().gViewRadius())
  //return playerEnemies.length > 0
  _._aaAICondition_playerAttacksSomeone = function() {
    return $gameTemp._aaPartyAI_flag_playerAttackSomeone > 0;
  };
  _._aaAICondition_playerAction = function() {
    var certainId;
    certainId = this.AAModel().getCertainActionId();
    if (certainId > 0) {
      return $gameTemp._aaPartyAI_flag_playerMadeAction === certainId;
    } else {
      return $gameTemp._aaPartyAI_flag_playerMadeAction != null;
    }
  };
  _._aaAICondition_condition = function() {
    var condition, e;
    try {
      condition = this.AAModel().getBattleStartUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.AABattler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateMove, _;
  //@[DEFINES]
  _ = Game_Followers.prototype;
  //@[ALIAS]
  ALIAS__updateMove = _.updateMove;
  _.updateMove = function() {
    var charToChase, i, j, ref, results;
    if ($gamePlayer.aaIsHaveAnyABSFollower()) {
      results = [];
      for (i = j = ref = this._data.length - 1; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
        if (i > 0) {
          charToChase = this._data[i - 1];
          if ((charToChase != null) && charToChase.isABS() && charToChase.aaIsInBattleState()) {
            charToChase = $gamePlayer;
          }
        } else {
          charToChase = $gamePlayer;
        }
        results.push(this._data[i].chaseCharacter(charToChase));
      }
      return results;
    } else {
      return ALIAS__updateMove.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Followers.prototype;
  _.aaGetABSFollowers = function() {
    return this._data.filter(function(f) {
      return (f != null) && f.isABS() && f.isActive();
    });
  };
  _.aaGetABSFollowersAll = function() {
    return this._data.filter(function(f) {
      return (f != null) && f.isABS();
    });
  };
  _.aaGetABSFollowersXyAAExt = function(x, y) {
    return this.aaGetABSFollowers().filter(function(f) {
      return f.posExt(x, y);
    });
  };
  _.aaGetFollowerByActorId = function(actorId) {
    var e;
    try {
      return this._data.find(function(f) {
        return (f.actor() != null) && f.actorId() === actorId;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaGetFollowerByCharId = function(charId) {
    var e;
    try {
      return this._data.find(function(f) {
        return (f.actor() != null) && f.aaCharId() === charId;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaRefreshABSMemebers = function() {
    var i, len, p, ref, results;
    ref = this.aaGetABSFollowersAll();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      results.push(p.aaRefreshABSThread());
    }
    return results;
  };
  _.aaOnPlayerDeathEvent = function() {
    var e, i, len, p, ref, results;
    try {
      ref = this.aaGetABSFollowersAll();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        results.push(p.refresh());
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnPlayerRevive = function() {
    var e, i, len, p, ref, results;
    try {
      ref = this._data;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        // * We need Activate ABS again
        results.push(p.refresh());
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__command126, ALIAS__command127, ALIAS__command128, ALIAS__command204, ALIAS__terminate, ALIAS__updateWaitMode, _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  //TODO: Вынести это в отдельный плагин
  //TODO: change GOLD and visual notify (command125)

  // * Показывает Notify только когда игрок получает предмет именно через команду, а не
  // * через игровой процесс (смена экипировки и т.д.)

  //@[ALIAS]
  ALIAS__command126 = _.command126;
  _.command126 = function() {
    var r;
    r = ALIAS__command126.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command127 = _.command127;
  _.command127 = function() {
    var r;
    r = ALIAS__command127.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command128 = _.command128;
  _.command128 = function() {
    var r;
    r = ALIAS__command128.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command204 = _.command204;
  _.command204 = function() {
    this.aaBlockMapMouseScroll();
    return ALIAS__command204.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__updateWaitMode = _.updateWaitMode;
  _.updateWaitMode = function() {
    this.aaCheckMapMouseScroll();
    return ALIAS__updateWaitMode.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__terminate = _.terminate;
  _.terminate = function() {
    ALIAS__terminate.call(this, ...arguments);
    this.aaResetMapMouseScrollBlock();
  };
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  (function() {    // * Управление АБС событиями
    // -----------------------------------------------------------------------
    _.aaBattler = function() {
      var e, ref;
      try {
        return (ref = this.aaEvent()) != null ? ref.AABattler() : void 0;
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
    _.aaEvent = function() {
      var char, e;
      try {
        if (this.eventId() <= 0) {
          return null;
        }
        char = $gameMap.event(this.eventId());
        if (char == null) {
          return null;
        }
        if (!char.isABS()) {
          return null;
        }
        return char;
      } catch (error) {
        e = error;
        AA.w(e);
        return null;
      }
    };
    // * Изменить параметр АА события (врага)
    _.aaChangeAIParam = function(paramName, newValue) {
      var char, e;
      try {
        char = this.aaEvent();
        return char != null ? char.aaChangeModelParam(paramName, newValue) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Выполнить SAction
    _.aaExecuteSAction = function(action) {
      var e;
      try {
        return uAPI.scriptAction(action, this, 0);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Получить опыт с данного события "врага"
    _.aaGainExp = function() {
      var e;
      try {
        if (this.eventId() <= 0) {
          return;
        }
        uAPI.gainExpForEnemyEv(this.eventId());
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Скролл карты (решение проблем с командой события)
    // -----------------------------------------------------------------------
    _.aaBlockMapMouseScroll = function() {
      this._aaBlockScroll = true;
      $gameTemp.aaIsMapScrolledByEvent = true;
      if (KDCore.isMV() && AA.PP.getMapScrollingSettings().isEnabled === true) {
        this.setWaitMode('scroll');
      }
    };
    _.aaCheckMapMouseScroll = function() {
      if (!this._aaBlockScroll) {
        return;
      }
      if (this._waitMode === 'scroll' && !$gameMap.isScrolling()) {
        $gameTemp.aaIsMapScrolledByEvent = false;
        return this._aaBlockScroll = false;
      }
    };
    _.aaResetMapMouseScrollBlock = function() {
      if (this._aaBlockScroll === true) {
        return $gameTemp.aaIsMapScrolledByEvent = false;
      }
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__refresh, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    this.aaOnNewMapLoaded();
    ALIAS__setup.call(this, ...arguments);
    if (AA.System.isExCollisionActive()) {
      this.aaCreateColliders();
    }
  };
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    return this.initABSMembers();
  };
  
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    return this.refreshABSMembers();
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaEventWithColliders = function() {
    return this.events().filter(function(ev) {
      return ev.aaIsHaveExColliders();
    });
  };
  _.aaIsHaveExColliders = function() {
    return (this._aaExColliders != null) && this._aaExColliders.length > 0;
  };
  _.aaGetAllExColliders = function() {
    var e;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      this.aaRefreshAllColliders();
      return this._aaExColliders;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.aaRefreshAllColliders = function() {
    var col, e, j, len, ref, results;
    try {
      if (!this.aaIsHaveExColliders()) {
        return;
      }
      ref = this._aaExColliders;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        col = ref[j];
        results.push(this.aaRefreshColliderData(col));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaRefreshColliderData = function(c) {
    var e, x, y;
    try {
      if (c == null) {
        return;
      }
      ({x, y} = c.tilePos);
      return c.setScreenCharPosition(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaClearExCollider = function() {
    var e;
    try {
      return this._aaExColliders = [];
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateColliders = function() {
    var e;
    try {
      this.aaCreateTerrainTagsColliders();
      return this.aaCreateRegionColliders();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateTerrainTagsColliders = function() {
    var config, configs, e, j, k, len, len1, p, ref, results, t, tag, tagsWithCollisions, terrainTagConfigs;
    try {
      terrainTagConfigs = AA.PP.getTerrainTagColliders();
      tagsWithCollisions = terrainTagConfigs.map(function(i) {
        return i.terrainTag;
      });
      configs = {};
      for (j = 0, len = tagsWithCollisions.length; j < len; j++) {
        tag = tagsWithCollisions[j];
        config = terrainTagConfigs.getByField('terrainTag', tag);
        configs[tag] = config.colliderConfig;
        configs[tag].flag = 'terrain';
      }
      ref = this.aaGetAllPoints();
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        p = ref[k];
        t = this.terrainTag(p.x, p.y);
        if (tagsWithCollisions.contains(t)) {
          results.push(this.aaAddExCollider(p, configs[t]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateRegionColliders = function() {
    var config, configs, e, j, k, len, len1, p, r, ref, regionConfigs, regionId, regionsWithCollisions, results;
    try {
      regionConfigs = AA.PP.getRegionIdColliders();
      regionsWithCollisions = regionConfigs.map(function(i) {
        return i.regionId;
      });
      configs = {};
      for (j = 0, len = regionsWithCollisions.length; j < len; j++) {
        regionId = regionsWithCollisions[j];
        config = regionConfigs.getByField('regionId', regionId);
        configs[regionId] = config.colliderConfig;
        configs[regionId].flag = 'region';
      }
      ref = this.aaGetAllPoints();
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        p = ref[k];
        r = this.regionId(p.x, p.y);
        if (regionsWithCollisions.contains(r)) {
          results.push(this.aaAddExCollider(p, configs[r]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetAllPoints = function() {
    var e, j, k, ref, ref1, x, y;
    try {
      if (this._aaAllMapPointsCache == null) {
        this._aaAllMapPointsCache = [];
        for (x = j = 0, ref = this.width(); (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
          for (y = k = 0, ref1 = this.height(); (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
            this._aaAllMapPointsCache.push({x, y});
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return this._aaAllMapPointsCache;
  };
  _.aaAddExCollider = function(point, config) {
    var col, e;
    try {
      if (config == null) {
        return;
      }
      col = AACollider.FromConfig(config);
      if (col == null) {
        return;
      }
      col.tilePos = point;
      return this._aaExColliders.push(col);
    } catch (error) {
      //console.log("collider created " + config.flag)
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetExCollidersWithin = function(x, y, distance) {
    var candidats, col, col2, e, j, k, len, len1, ref, tilePos;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      candidats = [];
      distance *= distance;
      ref = this._aaExColliders;
      for (j = 0, len = ref.length; j < len; j++) {
        col = ref[j];
        ({tilePos} = col);
        if (AA.Utils.Math.getXYDistanceQuick(x, y, tilePos.x, tilePos.y) <= distance) {
          candidats.push(col);
        }
      }
      for (k = 0, len1 = candidats.length; k < len1; k++) {
        col2 = candidats[k];
        this.aaRefreshColliderData(col2);
      }
      //console.log(candidats.length)
      return candidats;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.aaGetEventCollidersWithin = function(x, y, distance) {
    var candidats, e, ev, j, len, ref;
    try {
      candidats = [];
      distance *= distance;
      ref = this.aaEventWithColliders();
      for (j = 0, len = ref.length; j < len; j++) {
        ev = ref[j];
        if (AA.Utils.Math.getXYDistanceQuick(x, y, ev.x, ev.y) <= distance) {
          candidats.push(ev);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return candidats;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaIsHaveEncounters = function() {
    return this.aaEncountersData != null;
  };
  _.aaIsABSOnlyEncounters = function() {
    return this.aaIsHaveEncounters() && this.aaEncountersData.absOnly;
  };
  _.addGetEncountersRadius = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.radius;
    } else {
      return 2;
    }
  };
  _.addGetEncounterAnimation = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.animation;
    } else {
      return 0;
    }
  };
  _.aaGetEncountersCount = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.count;
    } else {
      return 0;
    }
  };
  _.aaInitMapEncounters = function() {
    var e, g, group, i, len, p;
    this.aaEncountersData = null;
    try {
      if (KDCore.Utils.getValueFromMeta('AAENC', $dataMap) == null) {
        return;
      }
      group = AA.Utils.Parser.parseNoteGroup('AAENC', $dataMap.note);
      if (group == null) {
        return;
      }
      this.aaEncountersData = {};
      for (i = 0, len = group.length; i < len; i++) {
        g = group[i];
        p = AA.Utils.Parser.extractABSParameter(g);
        this.aaEncountersData[p[0]] = p[1];
      }
      //console.info @aaEncountersData
      this.aaEncountersData.count = 0;
      return console.log("Map use ABS Encounters");
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.aaEncountersData = null;
    }
  };
  _.aaExecuteEncounter = function(playerRegionId, encTroopId) {
    var e, regionIdForSpawnEnemy;
    try {
      regionIdForSpawnEnemy = this.aaGetRegionForEncounterEnemy(playerRegionId, encTroopId);
      if (regionIdForSpawnEnemy > 0) {
        uAPI.spawnEnemy(encTroopId, regionIdForSpawnEnemy);
      } else {
        uAPI.spawnEnemyNearPlayer(encTroopId, this.addGetEncountersRadius());
      }
      // * Учёт количества, если спавн прошёл успешно
      if ($gameTemp.aaLastSpawnedEvent != null) {
        this.aaEncountersData.count++;
        if (($gameSystem.aaEnemySpawnAnimationId == null) || $gameSystem.aaEnemySpawnAnimationId <= 0) {
          return this.aaPlaySpawnAnimation($gameTemp.aaLastSpawnedEvent, this.addGetEncounterAnimation());
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaPlaySpawnAnimation = function(char, animId) {
    var e;
    try {
      if (animId <= 0) {
        return;
      }
      return AA.SAaction.execute('an_' + animId, char);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Получить номер региона в котором спавнить врага (учитывается регион игрока)
  _.aaGetRegionForEncounterEnemy = function(playerRegionId, encTroopId) {
    var candidates, e, en, i, len, ref;
    try {
      candidates = [];
      ref = this.encounterList();
      for (i = 0, len = ref.length; i < len; i++) {
        en = ref[i];
        if (en.troopId === encTroopId) {
          if (en.regionSet.contains(playerRegionId)) {
            candidates.push(...en.regionSet);
          }
        }
      }
      if (candidates.length === 0) {
        return 0;
      } else {
        return playerRegionId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return 0; // * any point on map
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Инициализация переменных ABS
  _.initABSMembers = function() {
    this.aaMapAnimations = [];
    return this.aaEncountersData = null;
  };
  // * Инициализация временных данных, когда переход на новую карту
  _.aaOnNewMapLoaded = function() {
    AA.System.onNewMapLoaded();
    // * Храним все навыки на карте
    this._aaMapSkills = [];
    // * Храним все летающие бонусы на карте
    this._aaMapBonuses = [];
    // * Сбрасываем сетку навигации
    this._aaMapPathGrid = null;
    $gameTemp.aaProjYOff = $gameMap.tileWidth() * 0.25;
    // * Сохраняем состояние врагов (пока ещё прошлой карты, не новой)
    this.aaStoreEnemiesHPs();
    $gameTemp.__aaIsShouldRestoreEnemiesHp = true;
    // * Для производительности, флаг что существует хоть один Spawn Block
    this._aaIsAnySpawnBlockEvent = false;
    // * Кэш точек карты для конкретного региона (для оптимизации)
    this._aaRegionPointsCache = {};
    // * В конце вызывается оригинальный метод, это важно
    this._aaGlobalSkillsCache = {};
    // * Cache of all map points
    this._aaAllMapPointsCache = null;
    // * Remove all colliders
    this._aaClearExCollider();
    this.aaInitMapEncounters();
  };
  // * Проверка АБС событий и активация по требованию
  _.refreshABSMembers = function() {
    var e, j, len, ref;
    try {
      ref = this.eventsAA();
      for (j = 0, len = ref.length; j < len; j++) {
        e = ref[j];
        if (e.aaIsShouldBeReActivated()) {
          e.initABS();
        }
      }
      $gamePlayer.followers().aaRefreshABSMemebers();
      if (AA.Network.isNetworkGame()) {
        return AA.Network.refreshABSMembers();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Когда карта загружена, происходит активация ABS событий
  _.initABS = function() {
    var e, j, len, ref;
    try {
      ref = this.eventsAA();
      for (j = 0, len = ref.length; j < len; j++) {
        e = ref[j];
        e.initABS();
      }
      // * Чтобы АИ союзников восстановил поток после выхода из меню
      return this.refreshABSMembers();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Все ABS события на карте
  _.eventsAA = function() {
    return this.events().filter(function(e) {
      return e.isABS();
    });
  };
  // * Все АИ собзники на карте
  _.followersAA = function() {
    return $gamePlayer.followers().aaGetABSFollowers();
  };
  // * Все ABS события с меткой label
  _.eventAAWithLabel = function(label = "") {
    return this.eventsAA().filter(function(e) {
      return e.aaIsLabeledAs(label);
    });
  };
  // * Все события (не обязательно АБС), которые имеют точку спавна
  _.eventsWithSpawnPoints = function() {
    return this.events().filter(function(e) {
      return e.aaIsHaveSpawnPointId();
    });
  };
  _.eventsWithLocators = function() {
    return this.events().filter(function(e) {
      return e.aaIsHaveLocator();
    });
  };
  // * ABS события в указанной точке
  _.eventsXyAA = function(x, y) {
    var e;
    try {
      return this.eventsXy(x, y).filter(function(e) {
        return e.isActive();
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * ABS события в указанной точке (с учётом Extended Hit Box)
  _.eventsXyAAExt = function(x, y) {
    var e;
    try {
      return this.eventsXyExt(x, y).filter(function(e) {
        return e.isActive();
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  _.eventsXyNoAAExt = function(x, y) {
    var e, events;
    try {
      events = this.eventsXyExt(x, y);
      return events.filter(function(ev) {
        return !ev.isABS();
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * События в указанной точке (с учётом Extended Hit Box)
  _.eventsXyExt = function(x, y) {
    var e;
    try {
      return this.events().filter(function(event) {
        return event.posExt(x, y);
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Аналогично, только Network Characters в данной точке
  _.netCharsXyAAExt = function(x, y) {
    var e;
    try {
      if (!AA.Network.isNetworkGame()) {
        return [];
      }
      return this.netChars().filter(function(char) {
        return char.posExt(x, y);
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Аналогично, только члены партии в данной точке
  _.follwersXyAAExt = function(x, y) {
    var e;
    try {
      return $gamePlayer.followers().aaGetABSFollowersXyAAExt(x, y);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Возвращяет спрайтсет карты (!Надо проверять сцену сперва)
  _.aaSpriteset = function() {
    return SceneManager._scene._spriteset;
  };
  _.aaIsMapAnimationRequested = function() {
    return this.aaMapAnimations.length > 0;
  };
  _.aaRequestMapAnimation = function(x, y, animationId, sx, sy) {
    if (animationId <= 0) {
      return;
    }
    this.aaMapAnimations.push({x, y, animationId, sx, sy});
  };
  // * Данный метод возвращает позиции с учётом расширенного HitBox
  _.aaGetExtendedPointsFor = function(char) {
    var d, e, extHitBoxes, i, j, k, l, m, n, positions, r, ref, ref1, ref2, ref3, u;
    try {
      positions = [
        {
          x: char.x,
          y: char.y
        }
      ];
      if (char.aaIsHaveExtendedHitBoxes()) {
        extHitBoxes = char.aaGetExtendedHitBoxes();
        l = extHitBoxes[3];
        r = extHitBoxes[1];
        u = extHitBoxes[0];
        d = extHitBoxes[2];
        if (r > 0) {
          for (i = j = 1, ref = r; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
            positions.push({
              x: char.x + i,
              y: char.y
            });
          }
        }
        if (l > 0) {
          for (i = k = 1, ref1 = l; (1 <= ref1 ? k <= ref1 : k >= ref1); i = 1 <= ref1 ? ++k : --k) {
            positions.push({
              x: char.x - i,
              y: char.y
            });
          }
        }
        if (u > 0) {
          for (i = m = 1, ref2 = u; (1 <= ref2 ? m <= ref2 : m >= ref2); i = 1 <= ref2 ? ++m : --m) {
            positions.push({
              x: char.x,
              y: char.y - i
            });
          }
        }
        if (d > 0) {
          for (i = n = 1, ref3 = d; (1 <= ref3 ? n <= ref3 : n >= ref3); i = 1 <= ref3 ? ++n : --n) {
            positions.push({
              x: char.x,
              y: char.y + i
            });
          }
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return positions;
  };
  // * Сохраняет состояния HP врагов
  _.aaStoreEnemiesHPs = function() {
    var b, dataToStore, e, ev, events, j, len;
    try {
      //"STORE ENEMIES HPS".p()
      events = this.eventsAA().filter(function(ev) {
        return ev.AAModel().saveHp > 0 && !(ev instanceof Game_AASpawnedEvent);
      });
      if (events.length === 0) {
        return;
      }
      dataToStore = {};
      for (j = 0, len = events.length; j < len; j++) {
        ev = events[j];
        try {
          b = ev.AABattler();
          if (b == null) {
            continue;
          }
          if (b.hpRate() !== 1) {
            dataToStore[ev.eventId()] = b._hp;
          }
        } catch (error) {
          //"STORED FOR".p(ev.eventId())
          e = error;
          KDCore.warning(e);
        }
      }
      return $gameSystem.aaSaveEnemiesHpDataForMap(this.mapId(), dataToStore);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Восстанавливает HP врагов из сохранённого состояния
  _.aaRestoreEnemiesHPs = function() {
    var dataToRestore, e, evId, events, hp, results, targetEvent;
    try {
      //"RESTORE ENEMIES HPS".p()
      dataToRestore = $gameSystem.aaGetEnemiesHpDataForMap(this.mapId());
      if (dataToRestore == null) {
        return;
      }
      events = this.eventsAA().filter(function(ev) {
        return ev.AAModel().saveHp > 0;
      });
      if (events.length === 0) {
        return;
      }
      results = [];
      for (evId in dataToRestore) {
        hp = dataToRestore[evId];
        try {
          targetEvent = events.find(function(ev) {
            return ev.eventId() === Number(evId);
          });
          if (targetEvent == null) {
            continue;
          }
          results.push(targetEvent.AABattler()._hp = hp);
        } catch (error) {
          //"RESTORED FOR".p(evId)
          e = error;
          results.push(KDCore.warning(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaIsPointPassableForDodge = function(x, y) {
    var e;
    try {
      if (x == null) {
        return false;
      }
      if (y == null) {
        return false;
      }
      if (!this.aaIsPointInMapBorders(x, y)) {
        return false;
      }
      if (this.eventsXyNoAAExt(x, y).length > 0) {
        return false;
      }
      return this.isPassable(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetBattleAutoBgm = function() {
    var e;
    try {
      if (($dataMap.meta != null) && ($dataMap.meta.battleAutoBgm != null)) {
        return $dataMap.meta.battleAutoBgm;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaMapFlyBonuses = function() {
    return this._aaMapBonuses;
  };
  _.aaRequestFlyBonusSpawn = function(evId, bonusData) {
    var e, event, mapBonusObj;
    try {
      if (bonusData == null) {
        return;
      }
      //"SPAWN BONUS".p()
      event = this.event(evId);
      if (event == null) {
        return;
      }
      mapBonusObj = new AAMapFlyBonusInstance(event.x, event.y, bonusData);
      //TODO: Network code! (see Game_Map::startAASkill)
      KDCore.Utils.playSE(bonusData.spawnSE);
      return this._aaRegisterNewFlyBonus(mapBonusObj);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaRegisterNewFlyBonus = function(bonus) {
    var e, i, index, j, ref;
    try {
      index = 0;
      for (i = j = 0, ref = this._aaMapBonuses.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._aaMapBonuses[i] == null) {
          index = i;
          break;
        }
      }
      this._aaMapBonuses[index] = bonus;
      //TODO: NETWORK CODE (see Game_Map::_registerNewAASkill)
      if (KDCore.Utils.isSceneMap()) {
        return $gameMap.aaSpriteset().aaCreateNewMapFlyBonus(index, bonus.delay() > 0);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaAddProjectile = function(projectileData) {
    var e;
    try {
      if (projectileData == null) {
        return;
      }
      // * For initialization check
      console.log("Added Projectile: " + projectileData.id);
      return this.aaGetAllProjectiles().push(projectileData);
    } catch (error) {
      //if KDCore.Utils.isSceneMap()
      //    SceneManager._scene._spriteset.aaCreateProjectileSprite(projectileData.id)
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetAllProjectiles = function() {
    var e;
    try {
      if (this._aaProjectiles == null) {
        this._aaProjectiles = [];
      }
      return this._aaProjectiles;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetProjectileById = function(projectileId) {
    var e;
    try {
      return this.aaGetAllProjectiles().getById(projectileId);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaRemoveProjectile = function(projectileId) {
    var e, projectileData;
    try {
      if (this._aaProjectiles == null) {
        return;
      }
      projectileData = this.aaGetProjectileById(projectileId);
      if (projectileData == null) {
        return;
      }
      //if KDCore.Utils.isSceneMap()
      //    SceneManager._scene._spriteset.aaRemoveProjectileSprite(projectileId)
      return this._aaProjectiles.delete(projectileData);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaRemoveAllProjectiles = function() {
    var e;
    try {
      return this._aaProjectiles = [];
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaMapSkills = function() {
    return this._aaMapSkills;
  };
  // * Инициализировать (создать объект) навык на карте
  _.startAASkill = function(aaSkill, subject, targetPoint) {
    var mapSkill;
    if (aaSkill == null) {
      return;
    }
    //TODO: Возможно не надо полный навык хранить, а только ID из базы
    mapSkill = new AASkill2MapAction(aaSkill, subject, targetPoint);
    AANetworkManager.startAASkillOnMap(aaSkill, subject, targetPoint, mapSkill.uniqueId);
    this._registerNewAASkill(mapSkill);
  };
  // * Добавить навык
  _._registerNewAASkill = function(skill) {
    var i, index, j, ref;
    index = 0;
    for (i = j = 0, ref = this._aaMapSkills.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (this._aaMapSkills[i] == null) {
        index = i;
        break;
      }
    }
    this._aaMapSkills[index] = skill;
    // * Запоминаем последний навык (если это сетевая игра и навык внешний)
    // * чтобы установить в него уникальный ID от сервера
    if (AA.Network.isNetworkGame()) {
      $gameTemp.__lastAAMapSkill = skill;
    }
    //"PROJECTILE REGISTRED ON MAP".p(index)
    if (KDCore.Utils.isSceneMap()) {
      $gameMap.aaSpriteset().aaCreateNewMapSkill(index);
    }
  };
  // * Работа с глобальными навыками (см. uAPI.executeAASkillOnMap)
  _.aaRegisterGlobalSkill = function(uId, aaDummyChar) {
    return this._aaGlobalSkillsCache[uId] = aaDummyChar;
  };
  _.aaDisposeGlobalSkill = function(uId) {
    this._aaGlobalSkillsCache[uId] = null;
    return delete this._aaGlobalSkillsCache[uId];
  };
  _.aaGetGlobalSkill = function(uId) {
    return this._aaGlobalSkillsCache[uId];
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Спавн врага в точке карты X, Y
  // * isForce - если true, то пропускаем любые проверки
  //%[Основной метод спавна врага на карте]
  _.aaSpawnEnemyInPoint = function(refEventId, x, y, isForce = false) {
    var e;
    try {
      if (isForce === true || this.aaIsMapPointIsValidForSpawn(x, y)) {
        this._aaExecuteSpawnInPoint(refEventId, x, y);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Спавн монстра (не безопасно вызывать этот метод сам по себе)
  _._aaExecuteSpawnInPoint = function(refEventId, x, y) {
    var e, refEvent;
    try {
      if (!DataManager.aaIsSpawnMapValid()) {
        return;
      }
      if (refEventId == null) {
        return;
      }
      if (refEventId <= 0) {
        return;
      }
      // * Проверка, что основа существует
      refEvent = $dataAASpawnMap.events[refEventId];
      if (refEvent == null) {
        return;
      }
      return $gameTemp.aaLastSpawnedEvent = new Game_AASpawnedEvent(refEventId, x, y);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaIsMapPointIsValidForSpawn = function(x, y) {
    var e;
    try {
      if (x == null) {
        return false;
      }
      if (y == null) {
        return false;
      }
      if (!this.aaIsPointInMapBorders(x, y)) {
        return false;
      }
      // * Режим Force Spawn, без каких-либо проверок
      if ($gameTemp.aaIsForceSpawn === true) {
        $gameTemp.aaIsForceSpawn = false;
        return true;
      }
      if (!AA.PP.isCanSpawnAboveEvents()) {
        if (this.eventsXyNt(x, y).length > 0) {
          // * Что нет события другого в данном месте
          return false;
        }
      }
      if ($gamePlayer.pos(x, y)) {
        // * Нельзя на игроке спавнить
        return false;
      }
      if (this.aaIsSpawnOnMapPointIsBlocked(x, y)) {
        // * Не заблокированная зона
        return false;
      }
      // * Точка проходимая
      return this.isPassable(x, y);
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  _.aaIsPointInMapBorders = function(x, y) {
    if (x < 0 || y < 0) {
      return false;
    }
    if (x >= $gameMap.width()) {
      return false;
    }
    if (y >= $gameMap.height()) {
      return false;
    }
    return true;
  };
  _.aaSpawnEnemyInRegion = function(refEventId, regionId, isForce = false) {
    var point, x, y;
    // Получение случайной Valid точки в регионе
    point = this.aaGetRandomSpawnPointForRegion(regionId);
    if (point == null) {
      return;
    }
    ({x, y} = point);
    this.aaSpawnEnemyInPoint(refEventId, x, y, true);
  };
  // * Возвращает случайную (доступную) точку спавна в регионе
  _.aaGetRandomSpawnPointForRegion = function(regionId) {
    var validPoints;
    if (this._aaRegionPointsCache[regionId] == null) {
      this._aaCollectAllPointsForRegion(regionId);
    }
    validPoints = this._aaRegionPointsCache[regionId].filter((p) => {
      return this.aaIsMapPointIsValidForSpawn(p.x, p.y);
    });
    // * Если опция кэширования отключена, удаляем кэш
    if (!AA.PP.isSpawnRegionCacheAllowed()) {
      this._aaRegionPointsCache[regionId] = [];
    }
    return validPoints.sample();
  };
  // * Собираем все точки на карте соответствующего региона
  _._aaCollectAllPointsForRegion = function(regionId) {
    var i, j, ref, ref1, x, y;
    this._aaRegionPointsCache[regionId] = [];
    for (x = i = 0, ref = this.width(); (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
      for (y = j = 0, ref1 = this.height(); (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
        if (this.regionId(x, y) === regionId) {
          this._aaRegionPointsCache[regionId].push({x, y});
        }
      }
    }
  };
  // * Точка вокруг точки (в радиусе), Valid точка
  // * Если не найдена, возвращает NULL
  _.aaGetRandomSpawnPointInRadius = function(x, y, radius) {
    var e, isPointFinded, point, tryCount;
    if ((radius == null) || radius <= 0) {
      return {x, y};
    }
    try {
      tryCount = radius * 2;
      isPointFinded = false;
      while (!isPointFinded) {
        if (tryCount <= 0) {
          break;
        }
        tryCount--;
        point = AA.Utils.Math.getPointInRadius(x, y, radius);
        isPointFinded = this.aaIsMapPointIsValidForSpawn(point.x, point.y);
      }
      if (isPointFinded === true) {
        return point;
      } else {
        return null;
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return null;
    }
  };
  
  // * SPAWN BLOCK SYSTEM =========================================
  _.aaRegisterBlockSpawnEventExist = function() {
    return this._aaIsAnySpawnBlockEvent = true;
  };
  _.aaIsSpawnBlockEventRegistred = function() {
    return this._aaIsAnySpawnBlockEvent === true;
  };
  _.aaIsSpawnOnMapPointIsBlocked = function(x, y) {
    var ev, i, len, point, spawnBlockEvents;
    if (this.aaIsSpawnBlockEventRegistred()) {
      spawnBlockEvents = this.events().filter(function(ev) {
        return ev.aaIsHaveSpawnBlockFlag();
      });
      point = {x, y};
      for (i = 0, len = spawnBlockEvents.length; i < len; i++) {
        ev = spawnBlockEvents[i];
        if (ev == null) {
          continue;
        }
        if (ev.distTo(point) < ev._aaBlockSpawnRadius) {
          console.log("Block Event disable Spawn on point " + [x, y]);
          return true;
        }
      }
    }
    return false;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addActor, ALIAS__gainItem, ALIAS__removeActor, ALIAS__setupStartingMembers, _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  //@[ALIAS]
  ALIAS__removeActor = _.removeActor;
  _.removeActor = function() {
    ALIAS__removeActor.call(this, ...arguments);
    if ($gameParty.leader() == null) {
      AA.System.checkABSPlayerExists();
    }
  };
  //@[ALIAS]
  ALIAS__addActor = _.addActor;
  _.addActor = function() {
    ALIAS__addActor.call(this, ...arguments);
    // * Если игрока не было, но появился
    if ($gameTemp._noABSPlayer === true && ($gameParty.leader() != null)) {
      AA.System.checkABSPlayerExists();
    }
  };
  //@[ALIAS]
  ALIAS__setupStartingMembers = _.setupStartingMembers;
  _.setupStartingMembers = function() {
    ALIAS__setupStartingMembers.call(this);
    // * Игнорирование членов группы с пустыми именами (частая ошибка новичков)
    this._actors = this._actors.filter(function(actor) {
      return String.any($dataActors[actor].name);
    });
  };
  
  //@[ALIAS]
  ALIAS__gainItem = _.gainItem;
  _.gainItem = function(item, amount, includeEquip) {
    var e, ref;
    ALIAS__gainItem.call(this, item, amount, includeEquip);
    try {
      if ((ref = AA.Sprite_WeaponExtensionSlot.Instance()) != null) {
        ref.closeMenu();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    //TODO: Пока так, но вообще это будет отдельный плагин
    if (amount > 0 && (this.itemContainer(item) != null)) {
      $gameTemp._pLastItemGainedToParty = [item, amount];
    } else {
      $gameTemp._pLastItemGainedToParty = null;
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  _.aaRefreshABSStatesSet = function() {
    var actor, e, i, len, ref, results;
    try {
      ref = this.members();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        if (actor == null) {
          continue;
        }
        if (actor.aaStates == null) {
          continue;
        }
        if (actor.aaStates.isNotHaveBattler()) {
          results.push(actor.clearStatesABS());
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCheckDeath = function() {
    //TODO: PARTY UPD Что делать если игрок погиб, а партия нет?
    if ($gameParty.leader() == null) {
      return;
    }
    if ($gameParty.leader().isAlive()) {
      return;
    }
    // * Пока GAME OVER если игрок погибает
    //TODO: Если будет партия по типу переключения (Genshin mode),
    //TODO: то можно переключать персонажа на живого (опция)
    $gamePlayer.aaOnDefeat();
  };
  // * Дать опыт всей группе (с учётом опций (разделение, для всех))
  // * isVisible == true -> Показать PopUp
  _.aaGainExpForParty = function(value, isVisible = true) {
    var char, charReceivers, e, expGainMode, i, j, len, len1, m, ref, ref1, valueX;
    try {
      if (value === 0) {
        return;
      }
      // * In network mode, only killer get exp (for now)
      if (AA.Network.isNetworkGame()) {
        try {
          if ($gameTemp.__aaExpReceiver != null) {
            if ($gameTemp.__aaExpReceiver === $gameParty.leader()) {
              $gameParty.leader().gainExp(value);
              if (isVisible === true) {
                this._aaShowExpPopUpVisually([$gamePlayer], value);
              }
            } else {
              if ($gameTemp.__aaExpReceiver.AACharacter() != null) {
                char = $gameTemp.__aaExpReceiver.AACharacter();
                AANetworkManager.gainExpFor(char, value, isVisible);
              }
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return;
      }
      expGainMode = AA.PP.getPartyExpGainMode();
      switch (expGainMode) {
        case "party":
          charReceivers = $gameParty.members().map(function(m) {
            return m.AACharacter();
          });
          ref = $gameParty.members();
          for (i = 0, len = ref.length; i < len; i++) {
            m = ref[i];
            m.gainExp(value);
          }
          break;
        case "partyDivided":
          if (value === 0) {
            return;
          }
          charReceivers = $gameParty.members().map(function(m) {
            return m.AACharacter();
          });
          valueX = Math.round(value / $gameParty.members().length);
          if (valueX <= 0) {
            valueX = 1;
          }
          ref1 = $gameParty.members();
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            m = ref1[j];
            m.gainExp(valueX);
          }
          // * Делим, если показывать над персонажами всеми
          if (AA.PP.getExpPopUpSettings().aboveChar === true) {
            value = valueX;
          }
          break;
        case "killer":
          if ($gameTemp.__aaExpReceiver != null) {
            charReceivers = [$gameTemp.__aaExpReceiver.AACharacter()];
            $gameTemp.__aaExpReceiver.gainExp(value);
          } else {
            $gameTemp.__aaExpReceiver = $gamePlayer;
            this.leader().gainExp(value); // * player
          }
          break;
        default:
          charReceivers = [$gamePlayer];
          this.leader().gainExp(value);
      }
      // * Не показывать, если флаг отключён
      if (!isVisible) {
        return;
      }
      this._aaShowExpPopUpVisually(charReceivers, value);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._aaShowExpPopUpVisually = function(charReceivers, value) {
    var char, data, e, i, len, p, results;
    try {
      if (value === 0) {
        return;
      }
      p = AA.PP.getExpPopUpSettings();
      // * Не показывать, если параметр плагина отключён
      if (!p.active) {
        return;
      }
      if (p.aboveChar === false && ($gameTemp.__aaExpGiver != null)) {
        charReceivers = [$gameTemp.__aaExpGiver];
      }
      if (charReceivers == null) {
        return;
      }
      results = [];
      for (i = 0, len = charReceivers.length; i < len; i++) {
        char = charReceivers[i];
        if (char == null) {
          continue;
        }
        data = AADamagePopUpFactory.createExpPopUpData(value, char);
        if (data == null) {
          continue;
        }
        if (p.bindToChar === true) {
          results.push(Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, data.settings, data.value));
        } else {
          results.push(Sprite_AADamagePopUpItem.CreateOnCharacter(char, data.settings, data.value));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Дать золото всей группе (только над игроком)
  _.aaGainGoldForParty = function(value) {
    var char, data, e, p;
    try {
      this.gainGold(value);
      p = AA.PP.getGoldPopUpSettings();
      char = $gamePlayer;
      data = AADamagePopUpFactory.createGoldPopUpData(value, char);
      if (data == null) {
        return;
      }
      if (p.bindToChar === true) {
        return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, data.settings, data.value);
      } else {
        return Sprite_AADamagePopUpItem.CreateOnCharacter(char, data.settings, data.value);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  // * Когда игрок получил какой-либо предмет
  _.pOnSomeItemBeenGained = function() {
    var e;
    try {
      // * У Extended Loot свой метод, см. pelOnSomeItemBeenGained (3_EL_Compatibility.coffee)
      if (Imported.PKD_ExtendedLoot) {
        return;
      }
      return this.pOnItemBeenGainedProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Обработка полученного предмета
  _.pOnItemBeenGainedProcess = function() {
    if ($gameTemp._pLastItemGainedToParty == null) {
      return;
    }
    if ($gameTemp._pLastItemGainedToParty[0] == null) {
      return;
    }
    if ($gameTemp._pLastItemGainedToParty[1] <= 0) {
      return;
    }
    if (AA.PP.isAddNewItemOnPanelOnPickup()) {
      return this.aaAddGainedItemToPanel(...$gameTemp._pLastItemGainedToParty);
    }
  };
  _.aaAddGainedItemToPanel = function(item, count) {
    if (!AA.Utils.isAAObject(item)) {
      return;
    }
    // * Новый предмет (т.е. раньше не было)
    if (this.numItems(item) === count) {
      // * Тут надо использовать idA
      if (!$gamePlayer.aaSkillsSet.isHaveItemOnPanel(item.idA)) {
        // * Тут используется обычный ID (так как конвертируется в методе)
        uAPI.setItemToPanel(item.id);
      }
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__canMove, ALIAS__executeEncounter, ALIAS__initMembers, ALIAS__moveStraight, ALIAS__update, ALIAS__updateScroll, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._initMembersABS();
  };
  // ======================================================================

  //@[ALIAS]
  ALIAS__updateScroll = _.updateScroll;
  _.updateScroll = function() {
    if (this.aaIsDodging()) {
      return;
    }
    return ALIAS__updateScroll.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__canMove = _.canMove;
  _.canMove = function() {
    var canMove;
    canMove = ALIAS__canMove.call(this);
    if (canMove && this.isABS() && AA.isABSActive() && (this.AABattler() != null)) {
      return this.AABattler().canMove();
    } else {
      return canMove;
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function(sceneActive) {
    ALIAS__update.call(this, sceneActive);
    if (AA.isABSActive()) {
      this._aaUpdatePlayerABS(sceneActive);
    }
    if (sceneActive === true) {
      this._aaUpdatePlayerABSCommon();
    }
  };
  //@[ALIAS]
  ALIAS__moveStraight = _.moveStraight;
  _.moveStraight = function() {
    ALIAS__moveStraight.call(this, ...arguments);
    $gameTemp.aaResetMapScrollOnMoving();
  };
  //@[ALIAS]
  ALIAS__executeEncounter = _.executeEncounter;
  _.executeEncounter = function() {
    if ($gameMap.aaIsHaveEncounters()) {
      if (AA.isABSActive()) {
        this.aaExecuteEncounter();
        return false; // * Always!
      } else {
        if ($gameMap.aaIsABSOnlyEncounters()) {
          return false;
        }
      }
    }
    return ALIAS__executeEncounter.call(this, ...arguments);
  };
  (function() {    // * Диагональное движение
    // -----------------------------------------------------------------------
    var ALIAS__executeMove, ALIAS__findDirectionTo, ALIAS__getInputDirection;
    //@[ALIAS]
    ALIAS__getInputDirection = _.getInputDirection;
    _.getInputDirection = function() {
      if (this.aaIsThisCharCanUseDiagMovement()) {
        return Input.dir8;
      } else {
        return ALIAS__getInputDirection.call(this);
      }
    };
    
    //@[ALIAS]
    ALIAS__executeMove = _.executeMove;
    _.executeMove = function(direction) {
      var horz, vert;
      if (this.aaIsThisCharCanUseDiagMovement()) {
        if (direction % 2 === 0) {
          return ALIAS__executeMove.call(this, direction);
        } else if (Math.abs(direction % 2) === 1) {
          [horz, vert] = AA.Utils.get8Dir(direction);
          return this.moveDiagonally(horz, vert);
        }
      } else {
        return ALIAS__executeMove.call(this, direction);
      }
    };
    
    //@[ALIAS]
    ALIAS__findDirectionTo = _.findDirectionTo;
    _.findDirectionTo = function(goalX, goalY) {
      if (this.aaIsThisCharCanUseDiagMovement()) {
        return this.aaFindDirectionToDiagonal(goalX, goalY);
      } else {
        return ALIAS__findDirectionTo.call(this, goalX, goalY);
      }
    };
  })();
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.aaGetAutoBattleBgmData = function() {
    var data, defaultSettings, delay, e, mapAutoBattleBgm, name;
    try {
      defaultSettings = AA.PP.getDefaultBattleBgm();
      mapAutoBattleBgm = $gameMap.aaGetBattleAutoBgm();
      if (String.any(mapAutoBattleBgm)) {
        name = mapAutoBattleBgm;
      } else {
        if (defaultSettings != null) {
          name = defaultSettings.name;
        } else {
          name = "";
        }
      }
      if (defaultSettings != null) {
        delay = defaultSettings.delay;
      } else {
        delay = 0;
      }
      data = {name, delay};
      return data;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaStartAutoBattleBgm = function() {
    var autoBattleBgmData, delay, e, name;
    try {
      if (this._aaIsAutoBattleBgmStarted === true) {
        return;
      }
      autoBattleBgmData = this.aaGetAutoBattleBgmData();
      if (autoBattleBgmData == null) {
        return;
      }
      ({name, delay} = autoBattleBgmData);
      if (String.any(name)) {
        uAPI.playBattleBgm(name, delay);
        return this._aaIsAutoBattleBgmStarted = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaStopAutoBattleBgm = function() {
    var autoBattleBgmData, delay, e;
    try {
      if (!this._aaIsAutoBattleBgmStarted) {
        return;
      }
      autoBattleBgmData = this.aaGetAutoBattleBgmData();
      ({delay} = autoBattleBgmData);
      if (delay == null) {
        delay = 0;
      }
      uAPI.stopBattleBgm(delay);
      return this._aaIsAutoBattleBgmStarted = false;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___aaOnCastingAborted, ALIAS___aaOnCastingEnd, ALIAS___aaOnCastingStarted, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS___aaOnCastingEnd = _._aaOnCastingEnd;
  _._aaOnCastingEnd = function() {
    ALIAS___aaOnCastingEnd.call(this, ...arguments);
    return AA_NUI_Sprite_PlayerCastingProgressBar.Hide();
  };
  //@[ALIAS]
  ALIAS___aaOnCastingAborted = _._aaOnCastingAborted;
  _._aaOnCastingAborted = function() {
    ALIAS___aaOnCastingAborted.call(this, ...arguments);
    return AA.UI.skillPerformResult(this._aaCastingNowSkill.idA, 0);
  };
  //@[ALIAS]
  ALIAS___aaOnCastingStarted = _._aaOnCastingStarted;
  _._aaOnCastingStarted = function() {
    ALIAS___aaOnCastingStarted.call(this, ...arguments);
    return AA_NUI_Sprite_PlayerCastingProgressBar.Show();
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.aaIsInvincible = function() {
    return this.aaIsDodging() && AA.PP.getDodgeSettings().isInvincible === true;
  };
  _.aaIsDodging = function() {
    return this._aaInDodgeMovement === true;
  };
  _.aaIsCanDodgeNow = function() {
    return this.aaIsDodgeAllowedNow() && this.isABS() && this.canMove() && !this.aaIsDodging() && this.aaIsNextDodgeReady();
  };
  _.aaIsDodgeAllowedNow = function() {
    var e;
    try {
      if (!AA.PP.isAllowDodge()) {
        return false;
      }
      if (AA.PP.getDodgeSettings().dodgeSwitch > 0) {
        if ($gameSwitches.value(AA.PP.getDodgeSettings().dodgeSwitch) === true) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _.aaIsNextDodgeReady = function() {
    return !this._aaDodgeRestTimer || this._aaDodgeRestTimer <= 0;
  };
  _.aaPerformDodge = function() {
    var dodgeMoveSpeed, dodgeSteps, dodgeStepsDelay, e, isAnimaXDodge;
    try {
      //console.log("DODGE!")
      this._aaInDodgeMovement = true;
      this.__aaPrevMoveSpeed = this.moveSpeed();
      this.setThrough(true);
      dodgeSteps = this._aaGetDodgeStepsCount();
      isAnimaXDodge = this.isAnimX() && this.isHaveAnimaXActionWithName('Dodge');
      dodgeStepsDelay = AA.PP.getDodgeSettings().delayBetweenStepMS;
      dodgeMoveSpeed = AA.PP.getDodgeSettings().dodgeMoveSpeed;
      if (isAnimaXDodge) {
        this.aaPlayAnimaXActionWithEndCallback("Dodge", this.aaOnDodgeEnds.bind(this));
      }
      if (dodgeSteps > 0) {
        if (!isAnimaXDodge) {
          setTimeout((() => {
            return this.aaOnDodgeEnds();
          }), dodgeStepsDelay + 1);
        }
        this.setMoveSpeed(dodgeMoveSpeed);
        this._aaMakeDodgeMovement();
        if (dodgeSteps > 1) {
          return setTimeout((() => {
            return this._aaMakeDodgeMovement();
          }), dodgeStepsDelay);
        }
      } else {
        return this.aaOnDodgeEnds();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaMakeDodgeMovement = function() {
    var e, h, v;
    try {
      if (this._diagonalDir) {
        [h, v] = AA.Utils.get8Dir(this._diagonalDir);
        return this.moveDiagonally(h, v);
      } else {
        return this.moveStraight(this.direction());
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaGetDodgeStepsCount = function() {
    var d, e, nextMovePoint, pointsCount;
    try {
      pointsCount = 0;
      d = this.aaDirection();
      nextMovePoint = AA.Utils.Math.getNextPointByDirection(this.x, this.y, d);
      if ($gameMap.aaIsPointPassableForDodge(nextMovePoint.x, nextMovePoint.y)) {
        pointsCount += 1;
        if (AA.PP.getDodgeSettings().stepsCount > 1) {
          nextMovePoint = AA.Utils.Math.getNextPointByDirection(nextMovePoint.x, nextMovePoint.y, d);
          if ($gameMap.aaIsPointPassableForDodge(nextMovePoint.x, nextMovePoint.y)) {
            pointsCount += 1;
          }
        }
      }
      return pointsCount;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return 0;
    }
  };
  _.aaOnDodgeEnds = function() {
    var e, time;
    try {
      //console.log("DODGE END")
      this._aaInDodgeMovement = false;
      this.setThrough(false);
      this.setMoveSpeed(this.__aaPrevMoveSpeed || 4);
      if (AA.PP.getDodgeSettings().dodgeRestVariable > 0) {
        time = KDCore.Utils.getVar(AA.PP.getDodgeSettings().dodgeRestVariable);
      } else {
        time = AA.PP.getDodgeSettings().dodgeRestTimerFrames;
      }
      return this._aaDodgeRestTimer = time;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaUpdateDodgeRestTimer = function() {
    var e;
    try {
      if (this._aaDodgeRestTimer > 0) {
        return this._aaDodgeRestTimer -= 1;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isABS, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Доп. проверка
  //@[ALIAS]
  ALIAS__isABS = _.isABS;
  _.isABS = function() {
    return ALIAS__isABS.call(this) && ($gameParty.leader() != null);
  };
  // * Когда сцена карты останавливается (сменяется другой)
  _.aaOnMapSceneEnd = function() {
    var ref;
    // * Выходим из цикла проверти Dead Timer, если разработчик забыл удалить состояние Death
    if ($gameTemp.aaDeathCEExecuted === true) {
      $gameTemp.aaDeathCEExecuted = null;
      if ((ref = this.AABattler()) != null) {
        ref.removeState(1);
      }
      this.aaClearMotion();
    }
    if (this.isInSkillTargetingState()) {
      this.onSkillTargetCancel();
    }
  };
  // * Можно ли управлять? (АБС элементы: навыки, атака и всё в этом роде)
  _.canBeControlled = function() {
    return this.isActive() && AA.isABSMap();
  };
  _.isInSkillTargetingState = function() {
    return this.aaState === 'skill';
  };
  // * Если ли у игрока АБС навык с ID
  _.aaIsHaveABSSkill = function(skillId) {
    return this.AABattler().getAASkills().getById(skillId) != null;
  };
  //TODO:?
  // * Проверка цели (см. Game_CharacterBase_AA)
  _.aaIsValidTargetToSet = function(target) {
    return true;
  };
  // * Когда игрок выбрал зону поражения навыка на карте (нажал левую кнопку мыши)
  _.onSkillTargetSelected = function() {
    var point, skill;
    //"SKILL ZONE SELECTED".p()
    //console.info $gameTemp._aaSkillSelectorTargets
    // * Проверка радиуса
    skill = this.activeAASkill();
    point = TouchInput.toMapPoint();
    if (AA.Utils.Math.getDistanceMapPlayerPoint(point) <= skill.gRange()) {
      this.startPerformAASkill(point);
      // * Сбрасываем состояние
      this.onSkillTargetCancel();
    } else {
      AA.UI.shakeSkillImpactSelector();
    }
  };
  //TODO: shake sprite
  _.onSkillTargetCancel = function() {
    return this._resetAAState();
  };
  //TODO: Возможно эта реализация довольно затратная по производительности
  //TODO: Сделать параметр плагина - использовать боевую стойку или нет
  _._aaIsInBattleAnimaXState = function() {
    var myEnemies;
    if (!AA.isABSActive()) {
      return false;
    }
    myEnemies = AATargetsManager.getAllWhoHavePlayerAsTargetInRange(5);
    return myEnemies.length > 0;
  };
  // * Обработка общей логики (вне зависимости Active ABS или нет)
  _._aaUpdatePlayerABSCommon = function() {
    if (this._aaOnDeathTimer != null) {
      this._aaUpdateDeathTimer();
    }
    if (this._aaDodgeRestTimer != null) {
      this._aaUpdateDodgeRestTimer();
    }
    //TODO: Можно убрать, но пока оставлю
    if (this.aaIsMotionRequested() && $gameParty.leader().isAlive()) {
      this.aaClearMotion();
    }
  };
  _._aaUpdateDeathTimer = function() {
    if (this._aaOnDeathTimer > 0) {
      this._aaOnDeathTimer--;
    } else {
      this.aaOnDeath();
    }
  };
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e;
    try {
      // * Сбрасываем состояние (выбор навыка)
      return this._resetAAState();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaGetABSFollowers = function() {
    return this.followers().aaGetABSFollowers();
  };
  _.aaIsHaveAnyABSFollower = function() {
    return this.aaGetABSFollowers().length > 0;
  };
  _.aaIsCanMoveByImpulse = function() {
    var e;
    try {
      if (this.isABS() && this.AABattler().aaIsEquippedInHeavyArmor()) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  (function() {    // * Основные (приватные) методы АБС
    // -----------------------------------------------------------------------
    var ALIAS__initABS;
    
    //TODO: Доделать поддержку техники
    // * Боты сейчас не учитывают isActive
    // * Надо там добавить isTagetValid
    //@[ALIAS]
    //ALIAS__isActive = _.isActive
    //_.isActive = ->
    //    ALIAS__isActive.call(@) && !@isInVehicle()

    // * 0 - Игрок
    _.aaCharId = function() {
      return 0;
    };
    //@[ALIAS]
    ALIAS__initABS = _.initABS;
    _.initABS = function() {
      ALIAS__initABS.call(this);
      if (AA.System.isExCollisionActive()) {
        this._initExCollForABS();
      }
      this.aaRefreshABSSkillsForPanel();
    };
    _._initMembersABS = function() {
      this.aaEntity = new AAPlayerEntity();
      this.aaState = null; // * Свободное состояние (нулевое)
      this.aaSkillsSet = new AASkillsSet();
    };
    _._setAAStateToSelectSkillTarget = function() {
      // * Наверное должно быт в AAEntity!!! Так как у ботов тоже будет этот параметр
      this.aaState = 'skill';
      AA.EV.call("PlayerSkillSelector");
    };
    _._setAAStateToSmartSkillUse = function(skillId, point) {
      this.aaState = 'smartAttack';
      this._aaSmartSkillId = skillId;
      this._aaSmartPoint = point;
    };
    _._resetAAState = function() {
      this.aaState = null;
      AA.EV.call("PlayerSkillSelector");
    };
    _._aaUpdatePlayerABS = function(sceneActive) {
      if (sceneActive === true) {
        this._aaUpdateStates();
        this._aaUpdatePlayerInput();
        return this._aaUpdateCastingProcess();
      }
    };
    _._aaUpdateStates = function() {
      switch (this.aaState) {
        case 'skill':
          // * Обновляем цели под кругом выбора
          return $gameTemp._aaSkillSelectorTargets = AATargetsManager.collectTargetsForPlayerSelector(this.activeAASkill());
        //? Не используется пока что
        // * Работает, но проблема что надо сбрасывать во многих случаях - путаница
        case 'smartAttack':
          if (!this.isMoving()) {
            if (AATargetsManager.isInSkillRange(this, this._aaSmartSkillId, this._aaSmartPoint)) {
              this._resetAAState();
              return this.aaTryPerformSkill(this._aaSmartSkillId);
            } else {
              return this.aaMoveTypeToPoint(this._aaSmartPoint);
            }
          }
          break;
      }
    };
    _.aaIsSupportMotion = function() {
      return AA.PP.getShowDeadMotionOnDeathType() > 0;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Методы ABS (Бой и состояния)
    // -----------------------------------------------------------------------
    var ALIAS__aaOnActionOnMe;
    // * Когда какое-либо действие было выполненно на мне
    //@[ALIAS]
    ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
    _.aaOnActionOnMe = function(action) {
      var result;
      ALIAS__aaOnActionOnMe.call(this, action);
      //TODO: На будущее: тут можно определить кто именно атаковал, так как action имеет packedSubject
      // * Сброс камеры (если есть опция)
      $gameTemp.aaResetMapScrollOnAction();
      result = this.AABattler().result();
      if ((result != null) && result.isHit() && result.hpDamage > 0) {
        this.aaOnActionDamageReceived();
      }
      if (AA.Network.isNetworkPvPGame()) {
        this.aaOnActionOnMeInNetwork(action);
      }
    };
    _.aaSetPartyAIOnDamageFlag = function() {
      if (!this.aaIsHaveAnyABSFollower()) {
        return;
      }
      $gameTemp._aaPartyAI_flag_playerGotDamage = true;
      // * Убираем флаг через время
      setTimeout((function() {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerGotDamage = false : void 0;
      }), 1000);
    };
    _.aaOnActionDamageReceived = function() {
      var e;
      try {
        this.aaSetPartyAIOnDamageFlag();
        if (this.aaInSkillCastingProcess()) {
          return this.aaOnEventWhileCasting('hit');
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnActionOnMeInNetwork = function(action) {
      var e, result;
      try {
        result = this.AABattler().result();
        if (result == null) {
          return;
        }
        if (result.isHit() && result.hpDamage > 0) {
          if (!this.AABattler().isAlive()) {
            return this.aaOnKilledByNetworkChar(action);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnKilledByNetworkChar = function(action) {
      var e, owner;
      try {
        if (action == null) {
          return;
        }
        if (!action.isNetCharActionOwner()) {
          return;
        }
        owner = action.character();
        $gameTemp.aaPvPKilledBy = owner.id;
        return AA.Utils.startCE(AA.PP.getCommonEventOnPlayerDeadInPvP());
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnDefeat = function() {
      var e, motionShowType;
      if (this._aaOnDeathTimer != null) {
        return;
      }
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      // * Если не включён Force dead motion (и подключён AnimaX)
      if (Imported.PKD_AnimaX && AA.PP.getShowDeadMotionOnDeathType() !== 1) {
        try {
          if (this.isAnimX()) {
            // * см. Game_Character_AnimaX.coffee
            this._aaOnGoInDeadAnimaXState();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      motionShowType = AA.PP.getShowDeadMotionOnDeathType();
      // * Показать Dead Motion
      if (Imported.PKD_AnimaX === true) {
        try {
          if (motionShowType === 1 || (motionShowType === 2 && !this.isHaveAnimaXState('dead'))) {
            this.aaRequestMotion('dead');
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      } else {
        if (motionShowType > 0) {
          this.aaRequestMotion('dead');
        }
      }
      if (AA.PP.getCommonEventOnPlayerDeath() > 0) {
        this.followers().aaOnPlayerDeathEvent();
        this._aaOnDeathTimer = 90;
      } else {
        this._aaOnDeathTimer = 10;
      }
    };
    _.aaOnDeath = function() {
      var ce;
      // * Сбрасываем таймер
      this._aaOnDeathTimer = null;
      if ($gameTemp.aaDeathCEExecuted === true) {
        return;
      }
      // * Если живой, то ничего, мало ли, вдруг воскресили
      if (this.AABattler().isAlive()) {
        return;
      }
      ce = AA.PP.getCommonEventOnPlayerDeath();
      // * Если задано общее событие, то выполнить его
      if (AA.Utils.isValidCE(ce)) {
        AA.Utils.startCE(ce);
        $gameTemp.aaDeathCEExecuted = true; // * Иначе Game Over Screen
      } else {
        SceneManager.goto(Scene_Gameover);
      }
    };
    //TODO: А что делать при анимации XAnima??? Надо возвращать из Dead при Revive potion
    //TODO: Сам на себе игрок не может использовать предмет Stimulant, поэтому пока пропуск
    return _.aaOnRevive = function() {
      this.aaClearMotion();
      $gameTemp.aaDeathCEExecuted = false;
      if (Imported.PKD_AnimaX) {
        this._aaAnimaXDeathPlayedFlag = false;
        this.aaUpdateABSAnimaX();
      }
      this.followers().aaOnPlayerRevive();
    };
  })();
  // * Переопределяем
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    if (this.isABS() && ($gameParty.leader() != null)) {
      return $gameParty.leader().aaGetExtendedHitBoxes();
    } else {
      return null;
    }
  };
  _.aaExecuteEncounter = function() {
    var e, spawnEvId;
    try {
      if (!$gameMap.isEventRunning() && this._encounterCount <= 0) {
        this.makeEncounterCount();
        spawnEvId = this.makeEncounterTroopId();
        if (spawnEvId <= 0) {
          return;
        }
        return $gameMap.aaExecuteEncounter(this.regionId(), spawnEvId);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //$[OVER]
  _._aaOnTeleportPerformed = function() {
    uAPI.resetMapScroll();
    return $gameTemp.clearDestination();
  };
  _.aaAfterLoad = function() {
    var e;
    try {
      if (this.aaIsDodging()) {
        return this.aaOnDodgeEnds();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startPerformAASkill, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Выполнить атаку первичным навыком (в первой ячеке E)
  _.aaPerformPlayerAttack01 = function(isSmart = false) {
    //"ATTACK ONLY 01".p()
    return this.aaPerformAttack(true, isSmart);
  };
  // * Выполнить атаку вторичным навыком (во второй ячейке Q)
  _.aaPerformPlayerAttack02 = function(isSmart = false) {
    //"ATTACK ONLY 02".p()
    return this.aaPerformAttack(false, isSmart);
  };
  _.aaPerformAttack = function(isPrimary = true, isSmart = false) {
    var skillId, symbol;
    if (!$gamePlayer.canBeControlled()) {
      return;
    }
    if (isPrimary) {
      symbol = AA.Input.primarySkillSymbol();
    } else {
      symbol = AA.Input.secondarySkillSymbol();
    }
    skillId = this.aaSkillsSet.getSkillForSymbol(symbol);
    if (skillId <= 0) {
      return;
    }
    this.aaTurnTowardTouchInput();
    if (isSmart) {
      this.aaPerformSmartSkillUse(skillId, TouchInput.toMapPoint());
    } else {
      this.aaTryPerformSkill(skillId);
    }
  };
  // * Выполнить "умную" атаку (либо использовать навык, либо подойти ближе)
  _.aaPerformSmartSkillUse = function(skillId, point) {
    var e;
    try {
      if (skillId <= 0) {
        return;
      }
      //@_setAAStateToSmartSkillUse(skillId, point)
      //? Не состоянием, а просто
      if (AATargetsManager.isInSkillRange(this, skillId, point)) {
        this.aaTryPerformSkill(skillId);
      } else {
        $gameTemp.setDestination(point.x, point.y);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Главный метод по выполнению того или иного АБС навыка
  // * Навык должен быть у персонажа
  // * Чтобы выполнить навык, которого нет у персонажа, то можно поставить флаг forced = true
  _.aaTryPerformSkill = function(skillId, forced = false) {
    var e, skill;
    try {
      if (!AA.isABSActive()) {
        return;
      }
      if (skillId == null) {
        return;
      }
      if (skillId <= 0) {
        return;
      }
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      // * Выполняем навык в любом случае (даже если нету или не готов)
      if (forced === true) {
        skill = AA.Utils.getAASkillObject(skillId);
        if (!AA.Utils.isAAObject(skill)) {
          // * Только АБС навык можно выполнить через этот метод
          skill = null;
        }
      } else {
        // * Иначе навык должен быть готов к использованию и выучен
        skill = this.AABattler().getUsableAASkills().find(function(s) {
          return s.idA === skillId;
        });
      }
      if (skill != null) {
        // * Проверяем активный Skill Extension
        skill = this.AABattler().aaCheckAndApplySkillExtension(skill);
      }
      if (skill != null) {
        if (skill.AASkill.isNeedCasting() && this.isMoving()) {
          AA.UI.skillPerformResult(skillId, 0);
          return;
        }
        AA.UI.skillPerformResult(skillId, 1);
        //TODO: perform skill
        "PERFROM SKILL ".p(skillId);
        console.log(skill.name);
        //TODO: нормальный метод на баттлере (или персонаже)
        this.prepareAASkillToExecute(skill);
      } else {
        //TODO: Notify???
        AA.UI.skillPerformResult(skillId, 0);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  
  // * Подготовка навыка к выполнению (сюда передаётся базовый объект навыка)
  _.prepareAASkillToExecute = function(skill) {
    var e, point, targetPoint;
    console.log("Use skill " + skill.name);
    //TODO: А если предмет???
    //TODO: Анимация навыка атаки
    this.onSkillTargetCancel();
    this.setActiveAASkill(skill.idA);
    skill = this.activeAASkill();
    // * Если навык работает по направлению точки (курсора)
    if (skill.isInPoint()) {
      // * Если надо выбирать зону, то выбор зоны
      if (skill.isNeedSelectZone()) {
        // * Сбор целей сразу в точке где сейчас курсор
        AATargetsManager.collectTargetsForPlayerSelector(this.activeAASkill());
        this._setAAStateToSelectSkillTarget();
      } else {
        point = TouchInput.toMapPoint();
        if (skill.isInstant() || skill.isInCertainPoint()) {
          // * Надо проверить находится ли точка в Range навыка
          if (AATargetsManager.isInSkillRange(this, this._activeAASkillId, point)) {
            this.startPerformAASkill(point);
          } else {
            // * NOTHING
            //TODO: Показать область range применения (моргнуть)
            //TODO: Написать Notify (small range)
            AA.UI.skillPerformResult(this._activeAASkillId, 0);
            this.setActiveAASkill(null);
          }
        } else {
          // * Направление по точке
          point.touchXY = {
            x: TouchInput.x,
            y: TouchInput.y
          };
          this.startPerformAASkill(point);
        }
      }
    } else {
      // * Передаём себя в качестве точки (direction == 0 - напрвление персонажа)
      targetPoint = this.toPoint();
      try {
        // * Если homing projectile, пытаемся передать цель под курсором
        if (skill.isHomingProjectile() && ($gameTemp._aaEventUnderCursor != null)) {
          targetPoint = $gameTemp._aaEventUnderCursor;
        }
        this.startPerformAASkill(targetPoint);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
  //@[ALIAS]
  ALIAS__startPerformAASkill = _.startPerformAASkill;
  _.startPerformAASkill = function() {
    ALIAS__startPerformAASkill.call(this, ...arguments);
    return this.aaSetPartyAIOnPlayerMadeActionFlag();
  };
  _.aaSetPartyAIOnPlayerMadeActionFlag = function() {
    if (!this.aaIsHaveAnyABSFollower()) {
      return;
    }
    $gameTemp._aaPartyAI_flag_playerMadeAction = this.activeAASkill().databaseId();
    // * Убираем флаг через время
    setTimeout((function() {
      return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerMadeAction = null : void 0;
    }), 1000);
  };
  // * Обновление навыков для панели задач (при смене лидера)
  // * Также выполняется начальная расстановка навыков
  _.aaRefreshABSSkillsForPanel = function() {
    var ref;
    if (this.AABattler() == null) {
      return;
    }
    if ((ref = this.aaSkillsSet) != null) {
      ref.setPlayerActorId();
    }
    AA.UI.refreshElement('skills');
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Только атака по нажатию LMB или RMB в режиме поворота (Cntr зажата)
  //TODO: Plugin Parameter
  //TODO: Можно DYNAMIC сделать метод (т.е. если параметр отключён, занулить его)
  // см. AASystem -> applyParameters метод (в нём можно занулять)
  _.aaIsStaticAttackInRotation = function() {
    return this.aaInRotation === true && AA.Input.IsStaticAttackWhenRotating === true;
  };
  _._aaUpdatePlayerInput = function() {
    var e;
    if (!$gamePlayer.canBeControlled()) {
      return;
    }
    try {
      this._aaUpdateInput_Rotation();
      //TODO: Action Keys
      //@_aaUpdateInput_ActionKeys()
      this._aaUpdateInput_Dodge();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._aaUpdateInput_Rotation = function() {
    // * Чтобы не поворачивался во время анимации, проверяем и canMove()
    this.aaInRotation = this.canMove() && Input.isPressed(AA.IKey.ROT);
    if (this.aaInRotation) {
      this.turnTowardCharacter(TouchInput.toMapPoint());
    }
  };
  _._aaUpdateInput_Dodge = function() {
    if (!AA.PP.isAllowDodge()) {
      return;
    }
    if (Input.isTriggered(AA.PP.getDodgeSettings().dodgeKey)) {
      if (this.aaIsCanDodgeNow()) {
        this.aaPerformDodge();
      }
    }
  };
  _._aaUpdateInput_ActionKeys = function() {
    if (Input.isTriggered(AA.IKey.REL)) {
      return;
    }
    //TODO: reload firearm
    if (Input.isTriggered(AA.IKey.CMD)) {

    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------
//TODO: AI command menu


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Screen.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Screen.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this, ...arguments);
    this.aaClearBloodSplatterEffect();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    this.aaUpdateBloodSplatterEffect();
  };
})();

// ■ END Game_Screen.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Screen.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Screen.prototype;
  _.aaIsNeedBSEffectShow = function() {
    return this._aaIsBSERequested === true;
  };
  _.aaClearBloodSplatterEffect = function() {
    var _aaBSSettings, e;
    try {
      if (!AA.PP.isShowBloodSplatterEffect()) {
        return;
      }
      this._aaBloodSEThread = new KDCore.TimedUpdate(30, _._aaUpdateBSEThread.bind(this));
      this._aaIsBSERequested = false;
      _aaBSSettings = AA.PP.getBloodSplatterEffectSettings();
      this._aaBSColor = KDCore.Color.FromHex(_aaBSSettings.BS_Color).ARR;
      this._aaBSColor[3] = _aaBSSettings.BS_Opacity;
      this._aaBSHPRate = _aaBSSettings.BS_HpRate / 100;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaBloodSEThread = null;
    }
  };
  _.onAfterLoad = function() {
    var e;
    try {
      return this.aaClearBloodSplatterEffect();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnBeforeSave = function() {
    this._aaBloodSEThread = null;
    return this._aaBloodSEThread2 = null;
  };
  _.aaUpdateBloodSplatterEffect = function() {
    var e, ref, ref1;
    if (this._aaBloodSEThread == null) {
      return;
    }
    try {
      if ((ref = this._aaBloodSEThread) != null) {
        ref.update();
      }
      return (ref1 = this._aaBloodSEThread2) != null ? ref1.update() : void 0;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.aaClearBloodSplatterEffect();
    }
  };
  _._aaUpdateBSEThread = function() {
    var color, e;
    try {
      if (this.aaIsShouldShowBSEffectNow()) {
        this._aaRequestBloodSplatterEffect();
        if (this._aaBSColor != null) {
          if (this._aaBloodSEThread2 == null) {
            color = this._aaBSColor;
            this._aaBloodSEThread2 = new KDCore.TimedUpdate(20, function() {
              return $gameScreen.startFlash(color, 30);
            });
            this._aaBloodSEThread2.once();
          }
          if (!this._aaBloodSEThread2.isAlive()) {
            return this._aaBloodSEThread2 = null;
          }
        }
      } else {
        return this._aaStopBloodSplatterEffect();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e, 'Screen Blood Splatter - update');
      return this._aaBloodSEThread.stop();
    }
  };
  _.aaIsShouldShowBSEffectNow = function() {
    return ($gameParty.leader() != null) && $gameParty.leader().hpRate() <= this._aaBSHPRate && !$gameSystem.absBSEForceDisabled;
  };
  _._aaRequestBloodSplatterEffect = function() {
    return this._aaIsBSERequested = true;
  };
  _._aaStopBloodSplatterEffect = function() {
    return this._aaIsBSERequested = false;
  };
})();

// ■ END Game_Screen.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onAfterLoad, ALIAS__onBeforeSave, _;
  //@[DEFINES]
  _ = Game_System.prototype;
  //@[ALIAS]
  ALIAS__onBeforeSave = _.onBeforeSave;
  _.onBeforeSave = function() {
    var e;
    ALIAS__onBeforeSave.call(this, ...arguments);
    try {
      AA.System.onBeforeGameSave();
      return this.aaOnBeforeGameSaved();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  
  //@[ALIAS]
  ALIAS__onAfterLoad = _.onAfterLoad;
  _.onAfterLoad = function() {
    var e;
    ALIAS__onAfterLoad.call(this, ...arguments);
    try {
      AA.System.onGameLoaded();
      return this.aaOnGameLoaded();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_System.prototype;
  _.aaInitSoundStore = function() {
    if (!this._aaSndStore) {
      return this._aaSndStore = {};
    }
  };
  _.aaSaveBgmState = function(name, pos) {
    $gameTemp.__lastSavedBgmStateName = name;
    this.aaInitSoundStore();
    this._aaSndStore[name] = pos;
  };
  _.aaLoadBgmState = function(name) {
    this.aaInitSoundStore();
    if (this._aaSndStore[name] != null) {
      return this._aaSndStore[name];
    }
  };
  _.aaStoreSuspendedMapBgm = function() {
    var e;
    try {
      this.__aaMapBgm = AudioManager.saveBgm();
      return this.__aaMapBgs = AudioManager.saveBgs();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaRestoreSuspendedMapBgm = function() {
    var e;
    try {
      if (this.__aaMapBgm != null) {
        AudioManager.replayBgm(this.__aaMapBgm);
      } else {
        AudioManager.stopBgm();
      }
      if (this.__aaMapBgs != null) {
        AudioManager.replayBgs(this.__aaMapBgs);
      }
      this.__aaMapBgs = null;
      return this.__aaMapBgm = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_System.prototype;
  (function() {    // * Дополнительные системы АБС (since 0.9)
    // -----------------------------------------------------------------------
    _.aaGetCustomGaugesSystem = function() {
      var e;
      try {
        if (this._aaCGS == null) {
          this._aaCGS = new AACustomGaugesSystem();
        }
        return this._aaCGS;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _.aaUpdateSystems = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaBeforeMapLoaded = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaBeforeMapStopped = function() {
      var e;
      try {
        return this.aaGetCustomGaugesSystem().onBeforeMapStopped();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnMapLoaded = function() {
      var e;
      try {
        return this.aaGetCustomGaugesSystem().onMapLoaded();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnBeforeGameSaved = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.aaOnGameLoaded = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Пользовательские настройки интерфейса
    // -----------------------------------------------------------------------
    _.aaInitUserUISettings = function() {
      return this._aaUserUiSettings = new AAUserUISettings();
    };
    _.aaGetUserUISettings = function() {
      if (this._aaUserUiSettings == null) {
        this.aaInitUserUISettings();
      }
      return this._aaUserUiSettings;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Состояние врагов (сохранение и загрузка здоровья)
    // -----------------------------------------------------------------------
    _.aaSaveEnemiesHpDataForMap = function(mapId, data) {
      if (this._aaEnemiesHPDataStored == null) {
        this._aaEnemiesHPDataStored = {};
      }
      this._aaEnemiesHPDataStored[mapId] = data;
    };
    _.aaGetEnemiesHpDataForMap = function(mapId) {
      if (this._aaEnemiesHPDataStored == null) {
        return null;
      }
      return this._aaEnemiesHPDataStored[mapId];
    };
  })();
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setDestinationMVonly, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_Temp.prototype;
  // * В MV нет метода onMapTouch, делаем перехват только тут
  //@[ALIAS]
  ALIAS__setDestinationMVonly = _.setDestination;
  _.setDestination = function() {
    if ($gameTemp.__isFromMapTouchMethod === true) {
      $gameTemp.__isFromMapTouchMethod = false;
      if (AA.UI.isUITouched()) {
        return;
      }
      if (AA.isABSActive() && KDCore.Utils.isSceneMap()) {
        SceneManager._scene.onMapTouchAA();
        return;
      }
    }
    ALIAS__setDestinationMVonly.call(this, ...arguments);
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setDestination, _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  //@[ALIAS]
  ALIAS__setDestination = _.setDestination;
  _.setDestination = function() {
    ALIAS__setDestination.call(this, ...arguments);
    // * Восстановить камеру при движении (если опция)
    this.aaResetMapScrollOnMoving();
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_Temp.prototype;
  // * Method from MZ
  _.requestAnimation = function(targets, animationId, mirror) {
    var e, i, len, results, t;
    try {
      if (targets == null) {
        return;
      }
      results = [];
      for (i = 0, len = targets.length; i < len; i++) {
        t = targets[i];
        if ((t != null) && (t.requestAnimation != null)) {
          results.push(t.requestAnimation(animationId, true));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.requestBalloon = function(target, balloonId) {
    var e;
    try {
      if (target == null) {
        return;
      }
      return target.requestBalloon(balloonId);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  (function() {    // * АИ обновление
    // -----------------------------------------------------------------------
    _._aaInitAILogicThreads = function() {
      if (this.__aaAILogicThreads == null) {
        return this.__aaAILogicThreads = {};
      }
    };
    _.aaRegisterAILogicThread = function(eventId) {
      var thread, time;
      //"THREAD REGISTERED FOR".p(eventId)
      this._aaInitAILogicThreads();
      time = AA.PP.getAIUpdateIntervalMS() || 100;
      if (time <= 0) {
        time = 1;
      }
      thread = setInterval((function() {
        var ev;
        if (!AA.isABSMap()) {
          return;
        }
        if (eventId > 0) {
          ev = $gameMap.event(eventId);
        } else {
          ev = $gamePlayer.followers().aaGetFollowerByCharId(eventId);
        }
        if (ev != null) {
          return ev.aaUpdateAILogic();
        } else {
          return $gameTemp.aaClearAILogicThread(eventId);
        }
      }), time);
      this.__aaAILogicThreads[eventId] = thread;
    };
    _.aaIsHaveAILogicThreadFor = function(eventId) {
      var e;
      try {
        this._aaInitAILogicThreads();
        return this.__aaAILogicThreads[eventId] != null;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    _.aaClearAILogicThread = function(eventId) {
      var thread;
      this._aaInitAILogicThreads();
      thread = this.__aaAILogicThreads[eventId];
      if (thread != null) {
        clearInterval(thread);
      }
      this.__aaAILogicThreads[eventId] = null;
    };
    return _.aaClearAllAILogicThreads = function() {
      var key, ref, value;
      if (this.__aaAILogicThreads == null) {
        return;
      }
      ref = this.__aaAILogicThreads;
      for (key in ref) {
        value = ref[key];
        this.aaClearAILogicThread(key);
      }
      this.__aaAILogicThreads = {};
    };
  })();
  (function() {    // * Камера
    // -----------------------------------------------------------------------
    _.aaSetMapScrolled = function(_aaIsScrollBeenApplied) {
      this._aaIsScrollBeenApplied = _aaIsScrollBeenApplied;
    };
    _.aaIsMapScrolled = function() {
      return this._aaIsScrollBeenApplied === true;
    };
    _.aaResetMapScrollOnAction = function() {
      // * Сброс камеры (если есть опция) при действии
      if ($gameTemp.aaIsMapScrolled() && AA.PP.getMapScrollingSettings().resetOnAction === true) {
        uAPI.resetMapScroll();
      }
    };
    return _.aaResetMapScrollOnMoving = function() {
      // * Восстановить камеру при движении (если опция)
      if (this.aaIsMapScrolled() && AA.PP.getMapScrollingSettings().resetOnMove === true) {
        uAPI.resetMapScroll();
      }
    };
  })();
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Troop.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //TODO: НЕ, лучше не трогать Game_Troop, так как у нас есть стандартный бой тоже!!!

  // * Через класс Game_Troop мы будем обращаться ко всем АБС врагам (АИ) на карте

  //@[DEFINES]
  _ = Game_Troop.prototype;
})();

// ■ END Game_Troop.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var GaugeController;
  // * Общий контроллер для Sprite_UIGauge (HP, MP, TP, ...)
  //?rev 03.07.21
  GaugeController = class GaugeController extends AA.UIElementController {
    constructor(gaugeSprite) {
      super();
      this.gaugeSprite = gaugeSprite;
    }

    
      // * source - Game_Battler
    // * valueFieldName - название поля (hp)
    //$[OVER]
    setup(source, valueFieldName, maxValueFieldName) {
      this.source = source;
      this.valueFieldName = valueFieldName;
      this.maxValueFieldName = maxValueFieldName;
      this.value = 0;
      this.max = 0;
      this.createThread(10, 4);
    }

    
      // * 0 - value (100), 1 - % (100%), 2 - full (100 / 100)
    setValueTextType(valueTextType) {
      switch (valueTextType) {
        case 1:
          this.getTypedText = this.getValuePercentText;
          break;
        case 2:
          this.getTypedText = this.getValueAndMaxText;
          break;
        default:
          this.getTypedText = this.getValueText;
      }
    }

    refreshGauge() {
      var e;
      if (this.gaugeSprite == null) {
        return;
      }
      try {
        this._refreshValues();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Останавливаем работу метода
        this.refreshGauge = function() {};
      }
    }

    //?DYNAMIC
    // * Этот метод используется чтобы получить текст исходя из настроек контроллера
    // * По стандарту - обычное значение
    getTypedText() {
      return this.getValueText();
    }

    getValueText() {
      return this.value;
    }

    getValueAndMaxText() {
      return this.value + " / " + this.max;
    }

    getValuePercentText() {
      return Math.round((this.value / this.max) * 100) + '%';
    }

  };
  AA.link(GaugeController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.GaugeController.prototype;
  //$[OVER]
  _._refresh = function() {
    var sourceMaxValue, sourceValue;
    sourceValue = this.source[this.valueFieldName];
    sourceMaxValue = this.source[this.maxValueFieldName];
    // * Перерисовываем только если значния изменились
    if (this.value !== sourceValue || this.max !== sourceMaxValue) {
      this.value = sourceValue;
      this.max = sourceMaxValue;
      this.refreshGauge();
    }
  };
  _._refreshValues = function() {
    this.gaugeSprite.drawGauge(this.value / this.max);
    this.gaugeSprite.drawText(this.getTypedText());
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Вспомогательные функции проверки данных и настроек АБС
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ GUARD.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
AA.Utils.Guard = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = AA.Utils.Guard;
  // * Этот метод проверит, можно ли создать АБС событие с этимм врагом из БД
  _.isProperEnemyIdForABSEvent = function(enemyId) {
    return ($dataEnemies[enemyId] != null) && String.any($dataEnemies[enemyId].name);
  };
})();

// ■ END GUARD.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ImageManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = ImageManager;
  _.loadAA = function(filename) {
    return this.loadBitmap('img/Alpha/', filename);
  };
  _.loadAAWeaponMotion = function(filename) {
    return this.loadBitmap('img/weaponsAA/', filename);
  };
})();

// ■ END ImageManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MATH.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Вспомогательные функции математических вычислений
AA.Utils.Math = function() {};

(function() {
  var AP, _;
  //@[DEFINES]
  _ = AA.Utils.Math;
  AP = KDCore.Point;
  _.moveTo = function(p1, p2, step) {
    var e, fx, fy, rotated;
    try {
      rotated = _.rotateTo(new AP(0, step), _.angle(p1, p2));
      fx = fy = 0;
      if (p2.y < p1.y) {
        fy = p1.y - rotated.y;
      } else {
        fy = p1.y + rotated.y;
      }
      if (p2.x < p1.x) {
        fx = p1.x + rotated.x;
      } else {
        fx = p1.x - rotated.x;
      }
      return new AP(fx, fy);
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.moveTo', e);
      return AP.Empty;
    }
  };
  _.rotateTo = function(p1, angle) {
    var e, fx, fy;
    try {
      fx = p1.x * Math.cos(angle) - p1.y * Math.sin(angle);
      fy = p1.y * Math.cos(angle) + p1.x * Math.sin(angle);
      return new AP(fx, fy);
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.rotateTo', e);
      return AP.Empty;
    }
  };
  _.angle = function(p1, p2) {
    var d, e, fx, fy;
    try {
      d = _.getPointDistance(p1, p2);
      fx = Math.abs(p2.x - p1.x);
      fy = Math.abs(p2.y - p1.y);
      if (d === 0 || fx === 0 || fy === 0) {
        return 0;
      }
      return Math.acos((fy * fy + d * d - fx * fx) / (2 * fy * d));
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.angle', e);
      return 0;
    }
  };
  _.getPointDistance = function(p1, p2) {
    var e;
    try {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.getPointDistance', e);
      return 0;
    }
  };
  _.inRect = function(p1, pixiRect) {
    var e;
    try {
      return pixiRect.contains(p1.x, p1.y);
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.inRect', e);
      return false;
    }
  };
  // * Алтернативный метод, расчитаный на более быстрое вычисление (без создания Point)
  // * Используется в проверке коллизий Map AA Skills Projectiles
  _.getXYDistance = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };
  _.getXYDistanceQuick = function(x1, y1, x2, y2) {
    return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
  };
  // * Получить дистанцию между игроком и точкой (в масштабах карты)
  _.getDistanceMapPlayerPoint = function(point) {
    var e;
    try {
      return $gameMap.distance($gamePlayer.x, $gamePlayer.y, point.x, point.y);
    } catch (error) {
      e = error;
      AA.warning(e);
      return 0;
    }
  };
  _.rotateDirsRelativeTo = function(dirSet, direction) {
    var d, e, k, l, len1, len2, rotated;
    try {
      // * Initial 2 (down)
      if ([1, 2, 3].contains(direction)) {
        return dirSet;
      }
      rotated = [];
      // * Reverse
      if ([7, 8, 9].contains(direction)) {
        for (k = 0, len1 = dirSet.length; k < len1; k++) {
          d = dirSet[k];
          rotated.push(10 - d);
        }
        return rotated;
      }
      // * Matrix 90,-90 rotation
      if ([4, 6].contains(direction)) {
        for (l = 0, len2 = dirSet.length; l < len2; l++) {
          d = dirSet[l];
          rotated.push(this.rotateDirectionByDirection(d, direction));
        }
        return rotated;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return dirSet;
  };
  // * Matrix Rotation 90 or -90 degress, just write it static, without calculations
  _.rotateDirectionByDirection = function(d, byDir) {
    var e;
    try {
      switch (byDir) {
        case 6:
          switch (d) {
            case 1:
              return 3;
            case 2:
              return 6;
            case 3:
              return 9;
            case 6:
              return 8;
            case 9:
              return 7;
            case 8:
              return 4;
            case 7:
              return 1;
            case 4:
              return 2;
          }
          break;
        case 4:
          switch (d) {
            case 1:
              return 7;
            case 2:
              return 4;
            case 3:
              return 1;
            case 6:
              return 2;
            case 9:
              return 3;
            case 8:
              return 6;
            case 7:
              return 9;
            case 4:
              return 8;
          }
          break;
        default:
          return d;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return d;
  };
  _.getProjectilePointByDirection = function(startPoint, d) {
    var diagTable, e, horVer, px, py, x, y;
    try {
      //"START POINT".p()
      //console.info(startPoint)
      ({x, y} = startPoint);
      //"FACE DIRECTION".p()
      // * Диагональное направление 8
      if ([1, 3, 7, 9].contains(d)) {
        diagTable = {
          1: [4, 2],
          3: [6, 2],
          7: [4, 8],
          9: [6, 8]
        };
        horVer = diagTable[d];
        px = $gameMap.roundXWithDirection(x, horVer[0]);
        py = $gameMap.roundYWithDirection(y, horVer[1]);
      } else {
        // * Обычное направление 4
        px = $gameMap.xWithDirection(x, d);
        py = $gameMap.yWithDirection(y, d);
      }
      return new KDCore.Point(px, py);
    } catch (error) {
      e = error;
      return KDCore.Point.Empty;
    }
  };
  _.getLeftAndRightPoints = function(x, y, d) {
    var e, points;
    try {
      points = [];
      switch (d) {
        case 4:
        case 6:
          points.push({
            x,
            y: y + 1
          });
          points.push({
            x,
            y: y - 1
          });
          break;
        case 8:
        case 2:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x: x + 1,
            y
          });
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return points;
  };
  _.getNeibPoints = function(x, y, d) {
    var e, points;
    try {
      points = [];
      switch (d) {
        case 4:
        case 6:
        case 2:
        case 8:
          return this.getLeftAndRightPoints(x, y, d);
        case 7:
          points.push({
            x: x + 1,
            y
          });
          points.push({
            x,
            y: y + 1
          });
          break;
        case 9:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x,
            y: y + 1
          });
          break;
        case 1:
          points.push({
            x: x + 1,
            y
          });
          points.push({
            x,
            y: y - 1
          });
          break;
        case 3:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x,
            y: y - 1
          });
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return points;
  };
  //Функция принимает шесть аргументов: три координаты вершин треугольника (x1, y1, x2, y2, x3, y3)
  // и координату, которую нужно проверить на вхождение в треугольник (x, y).
  //Функция возвращает true, если координата находится внутри треугольника
  //@[by CHAT GPT]
  _.isPointInsideTriangle = function(p1, p2, p3, targetPoint) {
    var a, a1, a2, a3, e, x, x1, x2, x3, y, y1, y2, y3;
    try {
      x1 = p1.x;
      x2 = p2.x;
      x3 = p3.x;
      y1 = p1.y;
      y2 = p2.y;
      y3 = p3.y;
      ({x, y} = targetPoint);
      // Вычисляем площади треугольника
      a = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
      // Вычисляем площади треугольников, образованных с заданной координатой
      a1 = Math.abs((x * (y2 - y3) + x2 * (y3 - y) + x3 * (y - y2)) / 2);
      a2 = Math.abs((x1 * (y - y3) + x * (y3 - y1) + x3 * (y1 - y)) / 2);
      a3 = Math.abs((x1 * (y2 - y) + x2 * (y - y1) + x * (y1 - y2)) / 2);
      // Если сумма площадей равна площади треугольника, то координата находится внутри треугольника
      return (a1 + a2 + a3) === a;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // Возвращает координаты вершин треугольника (3 точки)
  _.getTriangleVertixes = function(x, y, d, len, triangleSize) {
    var e, points;
    try {
      points = [];
      points.push({x, y});
      switch (d) {
        case 8:
          points.push({
            x: x - triangleSize,
            y: y - len
          });
          points.push({
            x: x + triangleSize,
            y: y - len
          });
          break;
        case 4:
          points.push({
            x: x - len,
            y: y + triangleSize
          });
          points.push({
            x: x - len,
            y: y - triangleSize
          });
          break;
        case 6:
          points.push({
            x: x + len,
            y: y + triangleSize
          });
          points.push({
            x: x + len,
            y: y - triangleSize
          });
          break;
        case 2:
          points.push({
            x: x - triangleSize,
            y: y + len
          });
          points.push({
            x: x + triangleSize,
            y: y + len
          });
          break;
        default:
          return false;
      }
      return points;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.getPointInRadius = function(x, y, radius) {
    var angle, e, newX, newY;
    try {
      if (radius == null) {
        return AP.Empty;
      }
      if (radius <= 0) {
        return new AP(x, y);
      }
      angle = Math.random() * 2 * Math.PI;
      radius = Math.randomInt(radius - 1) + 1;
      newX = Math.round(radius * Math.cos(angle));
      newY = Math.round(radius * Math.sin(angle));
      return new AP(x + newX, y + newY);
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.getPointInRadius', e);
      return AP.Empty;
    }
  };
  // All in Radius (expect center)
  //@[by CHAT GPT]
  _.getPointsInRadius = function(x, y, radius) {
    var e, i, j, k, l, points, ref, ref1, ref2, ref3;
    try {
      if (radius == null) {
        return [];
      }
      if (radius <= 1) {
        return [];
      }
      points = [];
      for (i = k = ref = x - radius, ref1 = x + radius; (ref <= ref1 ? k <= ref1 : k >= ref1); i = ref <= ref1 ? ++k : --k) {
        for (j = l = ref2 = y - radius, ref3 = y + radius; (ref2 <= ref3 ? l <= ref3 : l >= ref3); j = ref2 <= ref3 ? ++l : --l) {
          if (Math.sqrt((i - x) ** 2 + (j - y) ** 2) <= radius) {
            points.push({
              x: i,
              y: j
            });
          }
        }
      }
      points = points.filter(function(p) {
        return p.x !== x && p.y !== y;
      });
      return points;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Точки на краю круга только
  _.getPointsOutRadius = function(x, y, radius) {
    var e, points;
    try {
      points = this.getPointsInRadius(x, y, radius + 1);
      return points.filter(function(p) {
        return AA.Utils.Math.getXYDistance(x, y, p.x, p.y) > radius;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // Square around X,Y (8 points)
  //@[by CHAT GPT]
  _.getAdjacentPoints = function(x, y) {
    var e, i, j, k, l, points;
    try {
      points = [];
      for (i = k = -1; k <= 1; i = ++k) {
        for (j = l = -1; l <= 1; j = ++l) {
          if (i !== 0 || j !== 0) {
            points.push({
              x: x + i,
              y: y + j
            });
          }
        }
      }
      return points;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.getNextPointByDirection = function(sx, sy, d) {
    var e;
    try {
      switch (d) {
        case 1:
          sx -= 1;
          sy += 1;
          break;
        case 2:
          sy += 1;
          break;
        case 3:
          sx += 1;
          sy += 1;
          break;
        case 4:
          sx -= 1;
          break;
        case 6:
          sx += 1;
          break;
        case 7:
          sx -= 1;
          sy -= 1;
          break;
        case 8:
          sy -= 1;
          break;
        case 9:
          sx += 1;
          sy -= 1;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return {
      x: sx,
      y: sy
    };
  };
})();

// ■ END MATH.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс которые работает с параметрами плагина
(function() {
  var ParamsManager;
  ParamsManager = class ParamsManager extends KDCore.ParamLoader {
    constructor() {
      super("AABSZ");
      this._prepareParameters();
      return;
    }

    // * Данный метод надо вызывать когда игра уже загружена (доступны $gameX объекты)
    applyParameters() {
      if (this.getMapScrollingSettings().isEnabled === false) {
        // * Отключение Scroll камеры, если не задан параметр
        uAPI.disableMapScroll();
      }
    }

    // * ABS SYSETM
    // -----------------------------------------------------------------------
    getCollisionPreccissionLevel() {
      return this.getParam("colPrecissionLevel", 90);
    }

    fonts() {
      return this.getParam("fonts", []);
    }

    isGlobalUserUISettings() {
      return this.getParam("isSaveUIEditsGlobal", false);
    }

    uiData(tag, arg) {
      var method;
      // * Поиск соответсвующих настроек по тэгу элемента
      method = "_getDefaultVisualFor_" + tag;
      if (this[method] != null) {
        return this[method](arg);
      }
      return null;
    }

    // * POP UP
    // -----------------------------------------------------------------------
    isPopUpIsActive() {
      return this.getParam("isShowPopUp", true);
    }

    getTextForPopUpMiss() {
      return this.getParam("popUpTextForMiss", "Miss");
    }

    getExpPopUpSettings() {
      return this.getParam("popUpExpSettings", {
        active: true,
        textFormat: "+%1 exp",
        styleId: "Experience",
        aboveChar: false,
        bindToChar: false
      });
    }

    getGoldPopUpSettings() {
      return this.getParam("popUpGoldSettings", {
        textFormat: "%2%1",
        popUpStyle: {
          id: "gold",
          randDX: 15,
          randDY: 10,
          stayTime: 12,
          noFlyUp: false,
          noFadeOut: false,
          changeFontSize: 16,
          text: {
            visible: true,
            size: {
              w: 0,
              h: 0 // * not used
            },
            margins: {
              x: 0,
              y: 0
            },
            alignment: "right",
            outline: {
              color: null,
              width: 2
            },
            font: {
              face: "AABS_3",
              size: 12,
              italic: false
            },
            textColor: "#e6c42e"
          },
          image: {
            name: "goldPopUpIcon",
            margins: {
              x: 26,
              y: 0
            },
            fadeInSpeed: 20
          }
        },
        bindToChar: false
      });
    }

    //TODO: Всплывающий урон вынести в отдельный плагин
    getPopUpDamageSettings(id) {
      var data, settings;
      settings = this.getParam("popUpDamageTable", []);
      data = settings.getById(id);
      if (data != null) {
        return data;
      } else {
        // * Gold have own default settings (in other parameter)
        // * Потому что золото было позже добавлено
        if (id === 'gold') {
          return this.getGoldPopUpSettings().popUpStyle;
        } else {
          return {
            id: "default",
            randDX: 15,
            randDY: 10,
            stayTime: 12,
            noFlyUp: false,
            noFadeOut: false,
            changeFontSize: 22,
            text: {
              visible: true,
              size: {
                w: 0,
                h: 0 // * not used
              },
              margins: {
                x: 0,
                y: 0
              },
              alignment: "center",
              outline: {
                color: null,
                width: 2
              },
              font: {
                face: "AABS_3",
                size: 18,
                italic: false
              },
              textColor: "#E6E6E6".toCss()
            },
            image: null
          };
        }
      }
    }

    // * BUFFS AND STATES
    // -----------------------------------------------------------------------
    getIsBuffsVisible() {
      return this.getParam("isShowBuffsOnUI", true);
    }

    getIsStatesVisible() {
      return this.getParam("isShowStatsOnUI", true);
    }

    getUIActorBuffsIconsSet() {
      return this.getParam("buffsIconsPositions", [
        {
          x: 4,
          y: 4
        },
        {
          x: 42,
          y: 4
        },
        {
          x: 80,
          y: 4
        },
        {
          x: 118,
          y: 4
        }
      ]);
    }

    getUIActorStatesIconsSet() {
      return this.getParam("statesIconsPositions", [
        {
          x: 4,
          y: 40
        },
        {
          x: 42,
          y: 40
        },
        {
          x: 80,
          y: 40
        },
        {
          x: 118,
          y: 40
        }
      ]);
    }

    getUIEnemyStatesIconsSet() {
      return this.getParam("statesIconsPositionsForEnemy", [
        {
          x: 8,
          y: 64
        },
        {
          x: 28,
          y: 64
        },
        {
          x: 48,
          y: 64
        },
        {
          x: 68,
          y: 64
        }
      ]);
    }

    getUIEnemyStateIconOnUIScale() {
      return this.getParam("stateIconsScaleOnEnUI", 0.6);
    }

    getIsStateIconVisibleAbovePlayer() {
      return this.getParam("isShowStateIconAbvPl", false);
    }

    getIsStateIconVisibleAboveEnemy() {
      return this.getParam("isShowStateIconAbvEnms", true);
    }

    getIsStateIconVisibleAboveAlly() {
      return this.getParam("isShowStateIconAbvAls", true);
    }

    getStateIconOffsets() {
      return this.getParam("stateIconsMargins", {
        x: 0,
        y: -64
      });
    }

    getStateIconScale() {
      return this.getParam("stateIconsScale", 0.7);
    }

    // * Игрок и партия
    // -----------------------------------------------------------------------
    // * Тряска экрана когда игрок получил урон
    isShakeScreenWhenPlayerGetDamage() {
      return this.getParam("isShakeScreenWhenPlayerGetDamage", true);
    }

    // * Эффект экрана при низком значении HP
    isShowBloodSplatterEffect() {
      return this.getParam("isShowBloodSplatterEffect", true);
    }

    getBloodSplatterEffectSettings() {
      return this.getParam("boolSplatterEffectSettings", {});
    }

    // * Общее событие, когда игрок погибает
    getCommonEventOnPlayerDeath() {
      return this.getParam("commonEventOnPlayerDeath", 0);
    }

    // * Режим Dead Motion, когда игрок погибает
    // * 0 - none, 1 - always, 2 - ifNoAnimaX
    getShowDeadMotionOnDeathType() {
      return this.getParam("characterDeadMotionType", 2);
    }

    // * Использовать кастомный Level Up Notification
    isUseCustomLevelUp() {
      return this.getParam("isUseCustomLevelUp", true);
    }

    getCustomLevelUpSettings() {
      return this.getParam("customLevelUpSettings", {
        databaseAnimationId: 0,
        imageSeqAnimationName: "",
        imageSeqAnimationMargins: {
          x: 0,
          y: 0
        },
        extraSE: "",
        isShowPopUp: true,
        popUpText: "Level %1!",
        popUpStyle: {
          id: "levelUp",
          randDX: 0,
          randDY: 10,
          stayTime: 12,
          noFlyUp: false,
          noFadeOut: false,
          changeFontSize: 16,
          text: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            margins: {
              x: 0,
              y: 0
            },
            alignment: "center",
            outline: {
              color: null,
              width: 2
            },
            font: {
              face: "AABS_3",
              size: 12,
              italic: false
            },
            textColor: "#deb521"
          },
          image: null
        },
        commonEvent: 0,
        scriptAction: "" // * Относительно персонажа
      });
    }

    // * Враги
    // -----------------------------------------------------------------------
    getSpawnMapId() {
      return this.getParam("enemies_spawn_mapId", 0);
    }

    isCanSpawnAboveEvents() {
      return this.getParam("enemies_spawn_aboveEvents", false);
    }

    isSpawnRegionCacheAllowed() {
      return this.getParam("enemies_spawn_cacheAllowed", true);
    }

    getSpawnPointSettings(id) {
      return this.getSpawnPoints().getById(id);
    }

    getSpawnPoints() {
      return this.getParam("spawn_points", []);
    }

    //getMapEncounterSpawnMode: -> #TODO:
    // * Never (using as default battle system)
    // * Only if ABS is ON
    // * Always ABS enemies
    //TODO: Map Encounters - отдельный пласт

      // * Глобальные непроходимые участки карты для визоров
    getVisionRestrictedRegions() {
      return this.getParam("enemies_noPassVision", []);
    }

    getVisionRestrictedTerrains() {
      return this.getParam("enemies_noPassVision2", []);
    }

    getAfterDeathBonuses() {
      return this.getParam("enemies_afterDeathBonuses", [
        {
          image: "bonusGreen",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "",
          hpGainE: 25,
          mpGainE: 0,
          expGainE: 0,
          goldGainE: 0
        },
        {
          image: "bonusBlue",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 25, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 0 //@[EVal]
        },
        {
          image: "bonusYellow",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 50 //@[EVal]
        },
        {
          image: "bonusRed",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 10, //@[EVal]
          goldGainE: 0 //@[EVal]
        },
        {
          image: "bonusRed",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "ba_1", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 0 //@[EVal]
        }
      ]);
    }

    getAfterDeathBonus(index) {
      var bonuses, e;
      try {
        if (index <= 0) {
          return null;
        }
        bonuses = this.getAfterDeathBonuses();
        // * Iterate from 1 in game!
        return bonuses[index - 1];
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    // * Карта
    // -----------------------------------------------------------------------

      // * Глобальные непроходимые участки карты для Projectile
    getProjectileRestrictedRegions() {
      return this.getParam("map_noProjectilePass", []);
    }

    getProjectileRestrictedTerrains() {
      return this.getParam("map_noProjectilePass2", []);
    }

    // * Настройки для скролла карты курсором
    getMapScrollingSettings() {
      return this.getParam("mapScrolling", {
        isEnabled: false
      });
    }

    getMiniHpGaugeSettings() {
      return this.getParam("miniHpGaugeSetings", {
        active: true,
        showOnlyOnHover: true,
        showOnDamage: true,
        showWhenNotFull: false
      });
    }

    getAnimationAutoScallingFactor() {
      return this.getParam("mvAnimationAutoScalling", 0.5);
    }

    // * Панель навыков
    // -----------------------------------------------------------------------

      // * Добавлять автоматически новый навык на панель навыков при изучении навыка
    isAddNewSkillsOnPanelOnLearning() {
      return this.getParam("isAddNewSkillsOnPanelOnLearning", true);
    }

    // * Добавлять автоматически АБС предметы на панель навыков
    isAddNewItemOnPanelOnPickup() {
      return this.getParam("isAddNewItemOnPanelOnPickup", true);
    }

    // * Удалять предмет из панели навыков, если количество == 0
    isRemoveItemIfZeroCount() {
      return this.getParam("isRemoveItemFromPanelIfZeroCount", false);
    }

    // * Эффект подсветки слотов навыков на панели
    isUseOutlineEffect() {
      return this.getParam("isUseOutlineEffect", true);
    }

    getSkillPanelItemVisualSettings() { //TODO:
      return {};
    }

    
      // * Все слоты панели навыков
    getUISkillsItems() {
      return this._skillPanelSlots || [];
    }

    // * Настройки слота навыка по его символу
    getUISkillItemSlotSettings(symbol) {
      var items, settings;
      items = this.getUISkillsItems();
      settings = items.getByField('symbol', symbol);
      return settings;
    }

    // * Сетевой режим
    // -----------------------------------------------------------------------
    isNetworkPvPGame() {
      return this.getParam("netGameMode", 'PvE') === 'PvP';
    }

    getCommonEventOnPlayerDeadInPvP() {
      return this.getParam("netPvPKilledCE", 0);
    }

  };
  AA.link(ParamsManager);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  // * Данный метод вызывается при старте системы, $game объекты ещё не доступны
  // * Например для конвертирования каких-либо значений
  _._prepareParameters = function() {
    // * Если эффект отключён, заменяем класс на класс заглушку
    if (this.isUseOutlineEffect() === false) {
      AA.Sprite_SkillPanelOutline = AA.Sprite_SkillPanelOutlineDummy;
    }
    // * Собираем все слоты в один массив
    this._collectAllSkillSlots();
  };
  _._collectAllSkillSlots = function() {
    var primary, secondary, slots;
    primary = this._getPrimarySkillSlot();
    secondary = this._getSecondarySkillSlot();
    slots = this._getSkillSlots();
    this._skillPanelSlots = [primary, secondary, ...slots];
  };
  _._getPrimarySkillSlot = function() {
    return this.getParam("primaryAttackSlot", {
      position: {
        x: 218,
        y: 583
      },
      symbol: "E"
    });
  };
  _._getSecondarySkillSlot = function() {
    return this.getParam("secondaryAttackSlot", {
      position: {
        x: 255,
        y: 583
      },
      symbol: "Q"
    });
  };
  _._getSkillSlots = function() {
    return this.getParam("allSkillSlots", [
      {
        position: {
          x: 302,
          y: 583
        },
        symbol: "1"
      },
      {
        position: {
          x: 339,
          y: 583
        },
        symbol: "2"
      },
      {
        position: {
          x: 376,
          y: 583
        },
        symbol: "3"
      },
      {
        position: {
          x: 413,
          y: 583
        },
        symbol: "4"
      },
      {
        position: {
          x: 450,
          y: 583
        },
        symbol: "5"
      },
      {
        position: {
          x: 487,
          y: 583
        },
        symbol: "6"
      },
      {
        position: {
          x: 524,
          y: 583
        },
        symbol: "7"
      },
      {
        position: {
          x: 561,
          y: 583
        },
        symbol: "8"
      }
    ]);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParamsManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  // * Базовые настройки элементов интерфейса
  // * Эти настройки используется BASIC версия плагина

  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  _.isUseMorePreciseProjectileAnimations = function() {
    return this.getParam("morePreciseProjAnim", true);
  };
  _.isAllowDodge = function() {
    return this.getParam("isAllowDodge", true);
  };
  _.getDodgeSettings = function() {
    return this.getParam("dodgeSettings", {
      dodgeKey: 'f',
      dodgeSwitch: 0, // * If false -> can't dodge now!
      isInvincible: true,
      stepsCount: 2, // * 1 or 2
      delayBetweenStepMS: 100,
      dodgeMoveSpeed: 5,
      dodgeRestVariable: 0,
      dodgeRestTimerFrames: 30
    });
  };
  _.getAIUpdateIntervalMS = function() {
    return this.getParam("enemyAIUpdateThreadMS", 100);
  };
  _.getAIVisionUpdateIntervalFR = function() {
    return this.getParam("enemyAIUpdateVisionIntervalFR", 4);
  };
  _.getPartyExpGainMode = function() {
    return this.getParam("partyExpGainMode", "player");
  };
  _.getDefaultBattleBgm = function() {
    return this.getParam("defaultBattleAutoBgm", {
      name: "",
      delay: 0.5
    });
  };
  _.getCustomGauges = function() {
    return this.getParam("customGaugesSet", []);
  };
  _.getCustomGaugeById = function(gaugeId) {
    var e, gaugeSettings;
    try {
      gaugeSettings = this.getCustomGauges().find(function(item) {
        return item.id === gaugeId;
      });
      if (gaugeSettings != null) {
        gaugeSettings.visible = true;
      }
      return gaugeSettings;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.isUseExtCollisionsSystem = function() {
    return this.getParam("isUseExtCollisionsSystem", false);
  };
  _.getExtCollisionShowLayerKay = function() {
    return this.getParam("getExtCollisionShowLayerKey", '');
  };
  _.getDefaultEventCollider = function() {
    return this.getParam("getDefaultEventCollider", {
      type: 'b',
      dx: 0,
      dy: 0,
      width: 48,
      height: 48,
      radius: 0
    });
  };
  _.getTerrainTagColliders = function() {
    return this.getParam("getTerrainTagColliders", []);
  };
  _.getRegionIdColliders = function() {
    return this.getParam("getRegionIdColliders", []);
  };
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParamsManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  // * Базовые настройки элементов интерфейса
  // * Эти настройки используется BASIC версия плагина

  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  // * HP
  _._getDefaultVisualFor_hpGauge = function() {
    return this.getParam("playerHpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 304,
        y: 560
      },
      label: "Player_HPGaugeLabel",
      labelMargins: {
        x: -33,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_HPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * MP
  _._getDefaultVisualFor_mpGauge = function() {
    return this.getParam("playerMpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 454,
        y: 560
      },
      label: "Player_MPGaugeLabel",
      labelMargins: {
        x: -37,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_MPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * TP
  _._getDefaultVisualFor_tpGauge = function() {
    return this.getParam("playerTpGaugeVisualSettings", {
      visible: false,
      position: {
        x: 454,
        y: 560
      },
      label: "Player_TPGaugeLabel",
      labelMargins: {
        x: -37,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_TPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * EXP
  _._getDefaultVisualFor_expGauge = function() {
    return this.getParam("playerExpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 273,
        y: 528
      },
      label: "",
      labelMargins: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: false,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_ExpGauge",
        foreground: "Player_EXPGaugeForeground",
        mask: "Player_EXPGaugeMask",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * ENEMY MINI HP
  // * Враги имееют параметр miniHpGaugeStyle, поэтому поддерживается выбор из массива настроек
  _._getDefaultVisualFor_enemyMiniHp = function(styleId) {
    var data, item;
    if ((styleId != null) && String.any(styleId) && AA.isPro()) {
      data = this.getParam("enemyMiniHpGaugesCustoms", []);
      item = data.getById(styleId);
      if (item != null) {
        return item.gauge; // * Стандартный
      } else {
        AA.w("Enemy Mini HP gauge style ID " + styleId + " not defined in Plugin Parameters");
        return this._getDefaultVisualFor_enemyMiniHp(null);
      }
    } else {
      // * Стандартная настройка
      return this.getParam("enemyMiniHpGaugeSettings", {
        visible: true,
        position: {
          x: -19,
          y: -56
        },
        label: null,
        labelMargins: {
          x: 0,
          y: 0
        },
        // * TEXT не используется в этой реализации
        text: {
          visible: false,
          size: {
            w: 100,
            h: 20
          },
          alignment: "left",
          font: {
            face: "AABS_0",
            size: 13,
            italic: false
          },
          margins: {
            x: 10,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#edead8".toCss()
        },
        gauge: {
          visible: true,
          fill: "Event_HPGauge2",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 160,
          vertical: false
        }
      });
    }
  };
  // * Иконка для бафов
  _._getDefaultVisualFor_actorBuffIcon = function() {
    return this.getParam("buffIconSettings", {
      visible: true,
      position: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      textFormat: "%1", //%1 меняется на количество секунд
      textFormatA: "A:%1", //%1 меняется на количество действия до завершения состояния
      text: {
        visible: true,
        size: {
          w: 38,
          h: 14
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 16,
          italic: false
        },
        margins: {
          x: -2,
          y: -4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fafdec".toCss()
      },
      icon: {
        visible: true,
        index: 0,
        size: 32
      }
    });
  };
  // * Иконка для состояний (настройки аналогичные)
  _._getDefaultVisualFor_actorStateIcon = function() {
    return this.getParam("statsIconSettings", {
      visible: true,
      position: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      textFormat: "%1", //%1 меняется на количество секунд
      textFormatA: "A:%1", //%1 меняется на количество действия до завершения состояния
      text: {
        visible: true,
        size: {
          w: 38,
          h: 14
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 16,
          italic: false
        },
        margins: {
          x: -2,
          y: -4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fafdec".toCss()
      },
      icon: {
        visible: true,
        index: 0,
        size: 32
      }
    });
  };
  // * Слот навыка
  _._getDefaultVisualFor_skillSlot = function() {
    return this.getParam("skillSlotVisualSettings", {
      visible: true,
      isCanBeEdited: true,
      isHideWithMessage: true,
      outlineMargins: {
        x: -2,
        y: -2
      },
      iconMargins: {
        x: 2,
        y: 2
      },
      outlinePulseSpeed: 40,
      selectedOutlineColor: "#fcba03",
      clickedOutlineColor: "#0b03fc",
      readyOutlineColor: "#21b53c",
      badOutlineColor: "#d61a1a",
      icon: {
        visible: true,
        size: 32,
        index: 0
      },
      symbolText: {
        visible: true,
        size: {
          w: 20,
          h: 20
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 14,
          italic: false
        },
        margins: {
          x: 18,
          y: 22
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#e0cfbf".toCss()
      },
      timeText: {
        visible: true,
        size: {
          w: 32,
          h: 32
        },
        alignment: "center",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 2,
          y: 2
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fcba03".toCss()
      },
      countText: {
        visible: true,
        size: {
          w: 32,
          h: 32
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 0,
          y: -6
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#eb852d".toCss()
      }
    });
  };
  _._getDefaultVisualFor_enemyInfo = function() {
    return this.getParam("enemyInfoVisualSettings", {
      visible: true,
      position: {
        x: 640,
        y: 66
      },
      image: "Enemy_Background",
      isCanBeEdited: true,
      isHideWithMessage: true,
      nameFormat: "%1",
      levelFormat: "Lv. %1",
      hpTextFormat: "%1 / %2", // * %3 - Для процента, %1 - текущее, %2 - максимум
      nameText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_2",
          size: 16,
          italic: false
        },
        margins: {
          x: 10,
          y: 6
        },
        outline: {
          color: null,
          width: 3
        },
        textColor: "#d05816".toCss()
      },
      hpText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 12,
          y: 28
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      levelText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 60,
          y: 4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edeb6a".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_HPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      },
      gaugeMargins: {
        x: 6,
        y: 28
      },
      face: {
        visible: true,
        faceName: "",
        faceIndex: 0,
        mirror: false,
        size: 74,
        margins: {
          x: 92,
          y: 10
        }
      },
      battleState: {
        visible: true,
        image: "Enemy_BattleState_Free",
        margins: {
          x: 142,
          y: 60
        }
      },
      foregroundImage: {
        visible: false,
        image: "",
        margins: {
          x: 0,
          y: 0
        }
      }
    });
  };
})();

// ■ END ParamsManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ PARSER.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Вспомогательные функции для доставания АБС параметров из Note и комментарией
AA.Utils.Parser = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = AA.Utils.Parser;
  // * Преобразовывает значение (строка или цифра)
  //TODO: Пока простой способ
  _.convertParameterValue = function(paramValue) {
    if (isFinite(paramValue)) {
      return Number(paramValue);
    } else {
      if (paramValue === "true") {
        return 1;
      } else if (paramValue === "false") {
        return 0;
      } else {
        return paramValue;
      }
    }
  };
  
  // * Извлекает из строки (линии) имя параметра и его значение
  _.extractABSParameter = function(line) {
    var match, name, value;
    // * Для параметров одиночных < >
    if (line.match(/<.*>/i)) {
      match = line.match(/<(\w+)\s*:\s*(.+)>/i); // * Для параметров в группе (без < > )
    } else {
      match = line.match(/(\w+)\s*:\s*(.+)/i);
    }
    if (match != null) {
      name = match[1];
      value = _.convertParameterValue(match[2]);
      return [name, value];
    } else {
      return null;
    }
  };
  // * Извлекает из строки (линии) значение конкретного параметра
  // * Например используется чтобы достать ID врага из <ABS:X>
  _.extractCertainABSParameter = function(name, line) {
    var param;
    param = _.extractABSParameter(line);
    // * Если в этой строке есть этот параметр, то вернём его значение
    if (param[0] === name) {
      return param[1];
    } else {
      // * Иначе нету ничего
      return null;
    }
  };
  // * Shortcut для проверки ABS событий
  _.getABSEnemyId = function(line) {
    return _.extractCertainABSParameter('ABS', line);
  };
  // *  Извлечь линии (строки) АБС параметров из группы в Note
  _.parseNoteGroup = function(tag, note) {
    var e, eTag, endLineIndex, index, j, len, line, notes, result, sTag, startLineIndex;
    try {
      result = [];
      sTag = "<" + tag;
      eTag = "</" + tag + ">";
      notes = note.split(/[\r\n]+/);
      startLineIndex = -1;
      endLineIndex = -1;
      for (index = j = 0, len = notes.length; j < len; index = ++j) {
        line = notes[index];
        if (line.contains(sTag)) {
          startLineIndex = index + 1; // * Себя не включает начальный таг
        }
        if (startLineIndex >= 0 && line.contains(eTag)) {
          endLineIndex = index;
          break;
        }
      }
      if (startLineIndex > -1 && endLineIndex > -1) {
        result = notes.slice(startLineIndex, endLineIndex);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
    return result;
  };
  // * Для навыков (навыки, оружие, предметы)
  _.processABSSkillsNotetags = function() {
    var item, j, k, len, len1;
//TODO: Оружие не имеет своих ABS параметров, только ссылка на НАВЫК
    for (j = 0, len = $dataSkills.length; j < len; j++) {
      item = $dataSkills[j];
      if (item == null) {
        continue;
      }
      _.processABSSkillParamsInItem(item, false);
    }
    for (k = 0, len1 = $dataItems.length; k < len1; k++) {
      item = $dataItems[k];
      if (item == null) {
        continue;
      }
      _.processABSSkillParamsInItem(item, true);
      _.processABSExtensionItemParamsInItem(item);
    }
    //TODO: checkWeapon aaAttackSkill Note
    _.checkInitialAttackABSSkill();
  };
  
  // * Для врагов
  _.processABSEnemiesNotetags = function() {
    var item, j, len;
    for (j = 0, len = $dataEnemies.length; j < len; j++) {
      item = $dataEnemies[j];
      if (item == null) {
        continue;
      }
      _.processABSEnemyParams(item);
    }
  };
  // * Для персонажей (члены партии)
  _.processABSActorsNotetags = function() {
    var item, j, len;
    for (j = 0, len = $dataActors.length; j < len; j++) {
      item = $dataActors[j];
      if (item == null) {
        continue;
      }
      _.processABSAllyParams(item);
    }
  };
  // * Для состояний
  _.processABSStatesNotetags = function() {
    var item, j, len;
    for (j = 0, len = $dataStates.length; j < len; j++) {
      item = $dataStates[j];
      if (item == null) {
        continue;
      }
      _.processABSStateParamsInItem(item);
    }
  };
  // * Для оржуия AAExt
  _.processABSWeaponsNotetags = function() {
    var e, item, j, len, results;
    try {
      results = [];
      for (j = 0, len = $dataWeapons.length; j < len; j++) {
        item = $dataWeapons[j];
        if (item == null) {
          continue;
        }
        results.push(_.processABSExtensionParamsInWeapon(item));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Навык атаки всегда должен быть АБС 0
  _.checkInitialAttackABSSkill = function() {
    var attackSkill, e;
    try {
      attackSkill = $dataSkills[1];
      // * Если игрок не настроил навык Атаки, то применим стандартные настройки
      if (attackSkill.meta.ABS == null) {
        attackSkill.meta.ABS = true;
        attackSkill.idA = 1;
        attackSkill.AASkill = new AASkill2(attackSkill.idA);
        attackSkill.AASkill.applyDefaultAttack001();
      }
    } catch (error) {
      e = error;
      AA.cre(e, 'Something wrong with Attack skill [1] settings');
    }
  };
  _.processABSSkillParamsInItem = function(item, isItem) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.ABS : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.extractABSParametersFromDBItem(item);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      // * АБС использует свой ID, чтобы предметы и навыки различать
      item.idA = item.id;
      if (isItem === true) {
        item.idA += AA.Utils.ItemsIDStart;
      }
      // * Данные АБС навыка храняться у предмета
      item.AASkill = new AASkill2(item.idA);
      return item.AASkill.setNoteParameters(params);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.processABSExtensionItemParamsInItem = function(item) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.AAExt : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.parseNoteGroup("AAExt", item.note);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      // * Данные АБС навыка храняться у предмета
      item.AAExtItem = new AASkillExtensionItem(item.id);
      return item.AAExtItem.setNoteParameters(params);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.processABSExtensionParamsInWeapon = function(item) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.AAExt : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.parseNoteGroup("AAExt", item.note);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      // * Данные АБС навыка храняться у предмета
      item.AAExtDefinition = new AASkillExtensionDefinition(item.id);
      return item.AAExtDefinition.setNoteParameters(params);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Извлечь группу из объекта ДБ
  _.extractABSParametersFromDBItem = function(item) {
    var e, ref;
    try {
      if (((ref = item.meta) != null ? ref.ABS : void 0) != null) {
        return _.parseNoteGroup("ABS", item.note);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return [];
  };
  // * Извлекает из строки (линии) имя параметра и его значение
  // * Учитывается сложный параметр (массив или строка)
  _.extractABSParameterAny = function(line) {
    var match, name, value;
    match = line.match(/<*(\w+)\s*:\s*([\d,\w\s*]+)>*/i);
    if (match != null) {
      name = match[1];
      value = match[2];
      return [name, value];
    } else {
      return null;
    }
  };
  // * Конвертирует массив из строки 1,2,3 в [1, 2, 3] (цифры)
  _.convertArrayFromParameter = function(values) {
    var e;
    if (values instanceof Array) {
      return values;
    }
    try {
      // * Тут надо toString, так как может быть только цифра одна
      return values.toString().split(",").map(function(i) {
        return parseInt(i.trim());
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Чтение параметров врагов
  _.processABSEnemyParams = function(item) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.ABS : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.extractABSParametersFromDBItem(item);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      return item.AAEnemy = params;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Чтение параметров персонажей
  _.processABSAllyParams = function(item) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.ABS : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.extractABSParametersFromDBItem(item);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      return item.AAAllyChar = params;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Чтение параметров состояний
  _.processABSStateParamsInItem = function(item) {
    var e, j, len, param, paramPair, params, paramsRaw, ref;
    if (((ref = item.meta) != null ? ref.ABS : void 0) == null) {
      return;
    }
    try {
      params = [];
      paramsRaw = _.extractABSParametersFromDBItem(item);
      for (j = 0, len = paramsRaw.length; j < len; j++) {
        param = paramsRaw[j];
        paramPair = _.extractABSParameter(param); //ACore
        if (paramPair != null) {
          params.push(paramPair);
        }
      }
      // * Данные АБС состояния храняться у состояния
      item.AAState = new AAState(item.id);
      return item.AAState.setNoteParameters(params);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END PARSER.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Base.prototype;
})();

// ■ END Scene_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Boot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__loadGameFonts, ALIAS__start, _;
  //@[DEFINES]
  _ = Scene_Boot.prototype;
  // * Загружаем и инициализируем систему АБС
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    AA.System.initSystem();
    if (KDCore.isMV()) {
      // * В MV нету метода loadGameFonts
      AA.System.loadFonts();
    }
  };
  //?MZ only
  // * Загрузка шрифтов системы АБС
  //@[ALIAS]
  ALIAS__loadGameFonts = _.loadGameFonts;
  _.loadGameFonts = function() {
    ALIAS__loadGameFonts.call(this);
    AA.System.loadFonts();
  };
  // * Начальная настройка (и сброс) системы АБС
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    ALIAS__start.call(this);
    AA.System.onGameDataLoaded();
  };
})();

// ■ END Scene_Boot.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__processMapTouch, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //@[ALIAS]
  ALIAS__processMapTouch = _.processMapTouch;
  _.processMapTouch = function() {
    $gameTemp.__isFromMapTouchMethod = true;
    ALIAS__processMapTouch.call(this, ...arguments);
    $gameTemp.__isFromMapTouchMethod = false;
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__checkGameover, ALIAS__create, ALIAS__createSpriteset, ALIAS__onMapLoaded, ALIAS__onMapTouch, ALIAS__stop, ALIAS__update, ALIAS__updateCallMenu, _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.test = function() {
    var i, j;
    console.log("Scene_Map");
    for (i = j = 5; j <= 44; i = ++j) {
      //$gameMap.event(i)?.aaMakePathToCharacter($gamePlayer)
      $gameMap.event(i)._testSmartPath = true;
    }
  };
  //@[ALIAS]
  ALIAS__create = _.create;
  _.create = function() {
    ALIAS__create.call(this);
    AA.EV.subscribeFor("ABSPartyLeaderReady", this.gev_onABSPartyLeaderReady.bind(this));
    AA.EV.subscribeFor("ABSPartyLeaderNone", this.removeABSUI.bind(this));
  };
  //@[ALIAS]
  ALIAS__onMapLoaded = _.onMapLoaded;
  _.onMapLoaded = function() {
    ALIAS__onMapLoaded.call(this);
    AA.System.onMapSceneLoaded();
    this.aaCreateMouseDetectionThread();
    this.aaInitMapScrollSystem();
    this.aaInitExtraControllers();
    this.aaRestoreEnemiesHp();
    this.aaRefreshPartyABSMembers();
    if (!AA.System.isExCollisionActive()) {
      this._aaUpdateColLayerActivation = function() {};
    }
    // * Небольшая задержка на приём визуальных эффектов от сервера
    AA.Utils.callDelayed(function() {
      return $gameTemp._aaCanReceiveVisualFromServer = true;
    }, 100);
  };
  //@[ALIAS]
  // * Создаём интерфейс боевой системы
  ALIAS__createSpriteset = _.createSpriteset;
  _.createSpriteset = function() {
    ALIAS__createSpriteset.call(this);
    this._aaUILayer = new Sprite();
    this.addChild(this._aaUILayer);
  };
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    $gameTemp._aaCanReceiveVisualFromServer = false;
    if ($gamePlayer.aaInSkillCastingProcess()) {
      $gamePlayer.aaOnEventWhileCasting('menu');
    }
    ALIAS__stop.call(this);
    AA.System.onMapSceneStopped();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    $gameSystem.aaUpdateSystems();
    if (AA.isABSActive()) {
      this.updateABS();
    }
    this._aaUpdateColLayerActivation();
  };
  //@[ALIAS]
  ALIAS__onMapTouch = _.onMapTouch;
  // * Сохранение алиаса, чтобы использовать в другом файле
  _.ALIAS__onMapTouch = ALIAS__onMapTouch;
  _.onMapTouch = function() {
    if (AA.UI.isUITouched()) {
      return;
    }
    if (AA.isABSActive()) {
      return this.onMapTouchAA();
    } else {
      return ALIAS__onMapTouch.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__updateCallMenu = _.updateCallMenu;
  _.updateCallMenu = function() {
    if (TouchInput.isCancelled()) {
      //if AA.UI.performCancelActionOnMap()
      if (this.onMapCancelTouchAA()) {
        return;
      }
    }
    //TODO: Меню не вызывается если isMoving, также сделать если игрок в действии (анимация, удар)
    // * Если действие выполненно, то не надо вызывать меню
    return ALIAS__updateCallMenu.call(this);
  };
  //@[ALIAS]
  //$[OVER]
  ALIAS__checkGameover = _.checkGameover;
  _.checkGameover = function() {
    return $gameParty.aaCheckDeath(); // * Другой метод
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------
//ALIAS__checkGameover.call(@, ...arguments)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Scene_Map.prototype;
  // * Method From MZ
  _.onMapTouchAA = function() {
    var x, y;
    x = $gameMap.canvasToMapX(TouchInput.x);
    y = $gameMap.canvasToMapY(TouchInput.y);
    $gameTemp.setDestination(x, y);
  };
  _.ALIAS__onMapTouch = _.onMapTouchAA;
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaInitExtraControllers = function() {
    this.aaSpawnPointsController = new AASpawnPointsController();
    return this.aaLocatorsController = new AAEventLocatorController();
  };
  _.aaUpdateExtraControllers = function() {
    if (AA.Network.isNetworkGame() && !ANGameManager.isMapMaster()) {
      return;
    }
    this.aaSpawnPointsController.update();
    return this.aaLocatorsController.update();
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  (function() {    // * Обработка нажатия мыши (Touch) на карте (Левой)
    // -----------------------------------------------------------------------
    // * ТОЛЬКО левая кнопка мыши
    _.onMapTouchAA = function() {
      //TODO: $gamePlayer.canBeControlled() ??? Надо или нет???
      // * Если игрок в режиме выбора зоны навыка, то активация навыка
      if ($gamePlayer.isInSkillTargetingState()) {
        $gamePlayer.onSkillTargetSelected();
      } else if ($gamePlayer.aaInSkillCastingProcess()) {
        $gamePlayer.aaOnEventWhileCasting('click');
      } else {
        // * Новая система (без выбора целей)
        // * Обновим поиск цели под курсором
        this.aaRefreshMouseDetection();
        // * Статичная атака при повороте
        if ($gamePlayer.aaIsStaticAttackInRotation()) {
          $gamePlayer.aaPerformPlayerAttack01(false);
          return;
        }
        if ($gameTemp._aaEventUnderCursor != null) {
          // * Нажатие по цели
          // * (это используется чтобы не атаковать дружественные цели)
          if (this._aaIsTargetUnserCursorIsAlied()) {
            _.ALIAS__onMapTouch.call(this);
          } else {
            this._aaOnTouchOnTarget();
          }
        } else {
          // * Нажатие по карте (просто)
          this._aaOnTouchOnMapBasic();
        }
      }
    };
    // * Эта проверка предотвращает атаку по дружественной цели
    // * Доп. опции нету, т.к. с зажатым Cntrl можно атаковать и дружественную цель
    _._aaIsTargetUnserCursorIsAlied = function() {
      return !$gamePlayer.AAEntity().isMyEnemy($gameTemp._aaEventUnderCursor.AAEntity());
    };
    _._aaOnTouchOnTarget = function() {
      var char, mode;
      if (AA.isDEV()) {
        char = $gameTemp._aaEventUnderCursor;
        window.__selected = char;
        if (char != null) {
          "SELECTED ON MAP".p(char.AABattler().name());
        }
      }
      mode = AA.Input.LMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          $gamePlayer.aaPerformPlayerAttack01(false);
          break;
        case 1: // * DEFAULT (move)
          _.ALIAS__onMapTouch.call(this);
          break;
        case 2: // * SMART ATTACK
          $gamePlayer.aaPerformPlayerAttack01(true); // * 3, TURN
          break;
        default:
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
      }
    };
    _._aaOnTouchOnMapBasic = function() {
      var mode;
      mode = AA.Input.LMBMapTouchMode;
      if (mode === 0) { // * ATTACK ONLY
        $gamePlayer.aaPerformPlayerAttack01(false);
      } else if (mode === 1) { // * DEFAULT (move)
        _.ALIAS__onMapTouch.call(this); // mode == 2
      } else {

      }
    };
    // * NOTHING, ничего
    _.aaGetABSEntityInPosition = function(point) {
      var candidates, chars, e, events, partyMembers;
      try {
        events = $gameMap.eventsXyAAExt(point.x, point.y);
        if (events.length > 0) {
          return events.first();
        }
        partyMembers = $gameMap.follwersXyAAExt(point.x, point.y);
        if (partyMembers.length > 0) {
          return partyMembers.first();
        }
        if (AA.Network.isNetworkPvPGame()) {
          candidates = $gameMap.netCharsXyAAExt(point.x, point.y);
          chars = candidates.filter(function(char) {
            return char.AAEntity().isMyEnemy($gamePlayer.AAEntity());
          });
          if (chars.length > 0) {
            return chars.first();
          }
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
    return _.aaOnClickOnABSCharacter = function(char) {
      var e;
      try {
        $gamePlayer.aaTrySetTarget(char);
        //? DEBUG ONLY
        if (AA.isDEV()) {
          window.__selected = char;
          if (char != null) {
            return "SELECTED ON MAP".p(char.AABattler().name());
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
  })();
  (function() {    // * Обработка нажатия мыши (Touch) на карте (Правой)
    // -----------------------------------------------------------------------
    // * Если вернуть true - то меню НЕ будет показано
    _.onMapCancelTouchAA = function() {
      var isNotShowMenu;
      if (AA.UI.isAnyUIElementTouchProcess()) {
        // * инвернтарь, Hot бар и т.д.
        return true;
      }
      // * Отмена выбора зоны поражения навыка
      if ($gamePlayer.isInSkillTargetingState()) {
        $gamePlayer.onSkillTargetCancel();
        return true;
      }
      if ($gamePlayer.aaInSkillCastingProcess()) {
        $gamePlayer.aaOnEventWhileCasting('cancel');
        return true;
      }
      // * Новая система (без выбора целей)
      // * Обновим поиск цели под курсором
      this.aaRefreshMouseDetection();
      // * Статичная атака при повороте
      if ($gamePlayer.aaIsStaticAttackInRotation()) {
        $gamePlayer.aaPerformPlayerAttack02(false);
        return true;
      }
      if ($gameTemp._aaEventUnderCursor != null) {
        // * Нажатие по цели
        // * (это используется чтобы не атаковать дружественные цели)
        if (this._aaIsTargetUnserCursorIsAlied()) {
          isNotShowMenu = this._aaOnCancelTouchOnAllyTarget();
        } else {
          isNotShowMenu = this._aaOnCancelTouchOnTarget();
        }
      } else {
        // * Нажатие по карте (просто)
        isNotShowMenu = this._aaOnCancelTouchBasic();
      }
      return isNotShowMenu;
    };
    _._aaOnCancelTouchOnAllyTarget = function() {
      var mode;
      mode = AA.Input.RMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          // * NOTHING
          return true;
        case 1: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 2: // * SMART ATTACK
          // * NOTHING
          return true;
        case 3: // TURN
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
          return true; // * 4, MENU
        default:
          return false;
      }
    };
    _._aaOnCancelTouchOnTarget = function() {
      var mode;
      mode = AA.Input.RMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          $gamePlayer.aaPerformPlayerAttack02(false);
          return true;
        case 1: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 2: // * SMART ATTACK
          $gamePlayer.aaPerformPlayerAttack02(true);
          return true;
        case 3: // TURN
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
          return true; // * 4, MENU
        default:
          return false;
      }
    };
    return _._aaOnCancelTouchBasic = function() {
      var mode;
      mode = AA.Input.RMBMapTouchMode;
      switch (mode) {
        case 0: // * Menu
          return false; // * false - значит меню будет открыто
        case 1: // * Attack Secondary
          $gamePlayer.aaPerformPlayerAttack02(false);
          return true;
        case 2: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 3: // * Turn
          $gamePlayer.turnTowardCharacter(TouchInput.toMapPoint());
          return true; // * Nothing
        default:
          return true;
      }
    };
  })();
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaCreateMouseDetectionThread = function() {
    $gameTemp._aaEventUnderCursor = null;
    return this._aaMouseDetectThread = new KDCore.TimedUpdate(2, this.aaRefreshMouseDetection.bind(this));
  };
  _.aaUpdateMouseDetection = function() {
    return this._aaMouseDetectThread.update();
  };
  // * Этот метод отвечает за "сбор" событий и объектов под курсором
  _.aaRefreshMouseDetection = function() {
    var eventUnderCursor;
    eventUnderCursor = this.aaGetABSEntityInPosition(TouchInput.toMapPoint());
    if (eventUnderCursor != null) {
      if ($gameTemp._aaEventUnderCursor !== eventUnderCursor) {
        $gameTemp._aaEventUnderCursor = eventUnderCursor;
        AA.EV.call("UnderMouseEventChanged");
      }
    } else {
      if ($gameTemp._aaEventUnderCursor != null) {
        $gameTemp._aaEventUnderCursor = null;
        AA.EV.call("UnderMouseEventChanged");
      }
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaInitMapScrollSystem = function() {
    $gameTemp.aaIsMapScrolledByEvent = false;
    this.aaScrollTimer = 0;
    this.aaIsNeedScroll = false;
    this.aaScrollParams = AA.PP.getMapScrollingSettings();
  };
  //@[DYNAMIC]
  _.aaUpdateMapScrlByMouse = function() {
    if ($gameTemp.aaIsMapScrolledByEvent === true) {
      return;
    }
    // * По умолчанию скролл включён
    this.aaUpdateMapScrlByMouseBody();
  };
  _.aaUpdateMapScrlByMouseBody = function() {
    var p, zone;
    if ($gamePlayer.isMoving() || $gameTemp.isDestinationValid()) {
      return;
    }
    // * Когда мышка у края экрана, тогда будет scroll карты
    this.aaIsNeedScroll = false;
    zone = this.aaScrollParams.scrollZone;
    p = TouchInput;
    if (p.y > Graphics.height - zone && p.y <= Graphics.height - 2) {
      this.aaMakeScroll(2);
    } else {

    }
    if (p.y >= 2 && p.y < zone) {
      this.aaMakeScroll(8);
    } else {

    }
    if (p.x >= 2 && p.x < zone) {
      this.aaMakeScroll(4);
    } else {

    }
    if (p.x > Graphics.width - zone && p.x <= Graphics.width - 2) {
      this.aaMakeScroll(6);
    }
    if (!this.aaIsNeedScroll) {
      // * Не применяем, например delay ещё не прошёл
      $gameMap.startScroll(0, 0, 0);
      if (this.aaScrollTimer >= this.aaScrollParams.delay) {
        // * Сброс таймера
        this.aaScrollTimer = 0;
      }
    }
    if (this.aaIsNeedScroll === true) {
      
      // * Было ли движение камеры? (Тут только true может быть)
      $gameTemp.aaSetMapScrolled(true);
    }
  };
  _.aaMakeScroll = function(d) {
    $gameMap.startScroll(d, 1, this.aaScrollParams.speed);
    this.aaScrollTimer++;
    this.aaIsNeedScroll = this.aaScrollTimer >= this.aaScrollParams.delay;
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.addABSUI = function() {
    if (this._aaUI != null) {
      return;
    }
    this._aaUI = new AA.Spriteset_UI();
    this._aaUILayer.addChild(this._aaUI);
  };
  _.removeABSUI = function() {
    if (this._aaUI != null) {
      this._aaUILayer.removeChild(this._aaUI);
    }
    this._aaUI = null;
  };
  _.updateABS = function() {
    this.aaUpdateMouseDetection();
    this.aaUpdateMapScrlByMouse();
    this.aaUpdateExtraControllers();
  };
  _.aaRestoreEnemiesHp = function() {
    var e;
    if ($gameTemp.__aaIsShouldRestoreEnemiesHp == null) {
      return;
    }
    $gameTemp.__aaIsShouldRestoreEnemiesHp = null;
    try {
      return $gameMap.aaRestoreEnemiesHPs();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Т.к. АИ союзников постоянны (создаются один раз), то надо обновлять их после загрузки карты
  _.aaRefreshPartyABSMembers = function() {
    var e;
    try {
      $gamePlayer.followers().aaRefreshABSMemebers();
      return $gameParty.aaRefreshABSStatesSet();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaUpdateColLayerActivation = function() {
    if (Input.isTriggered(AA.PP.getExtCollisionShowLayerKay())) {
      if (Sprite_AACollisionsLayer.Instance() != null) {
        Sprite_AACollisionsLayer.Destroy();
      } else {
        Sprite_AACollisionsLayer.Create();
      }
      Input.clear();
    }
  };
  //@[EVENT]
  _.gev_onABSPartyLeaderReady = function() {
    var e;
    try {
      this.addABSUI();
      return $gamePlayer.initABS();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Title.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__start, _;
  //@[DEFINES]
  _ = Scene_Title.prototype;
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    AA.System.onTitleScreen();
    return ALIAS__start.call(this);
  };
})();

// ■ END Scene_Title.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Сцена игрового визуального редактора интерфейса
(function() {
  var Scene_UIEditor;
  Scene_UIEditor = class Scene_UIEditor extends Scene_Base {
    constructor() {
      super();
      this.elementUnderMouse = null;
      this.isDrag = false;
      this.preEditElementsStates = [];
      return;
    }

    create() {
      super.create();
      // * Запоминаем состояние АБС, так как надо его ставить на паузу
      $gameTemp._needRestoreABSSystemAfterUIEdit = AA.isABSActive();
      AA.System.pauseABS();
      this.createMain(); //# -> 0
      //TODO: Добавить опцию (Показывать ли скрытые в редактре...)
      this.showNotVisibleElements();
      //TODO: Добавить опцию (параметр  Показывать ли..)
      return this.showNotEditableElements();
    }

    // * Элементы, которые нельзя редактировать, мы отмечаем (блюр)
    showNotEditableElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.isCanBeEdited()) {
          this.deactivateElement(e);
        }
      }
    }

    // * Элемнты, которые скрыты, мы показываем прозрачными
    showNotVisibleElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.visible) {
          // * Тут проверяется по флагу visible, а не isActive
          this.transparentElement(e);
        }
      }
    }

    deactivateElement(element) {
      // * Сохраняем значения перед редактированием
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.opacity = 150;
      element.desaturate();
    }

    transparentElement(element) {
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.visible = true;
      element.opacity = 120;
    }

    // * Сбросить значения по умолчанию
    resetElement(element) {
      var user;
      element.reset("position");
      user = $gameSystem.aaGetUserUISettings();
      return user.set(element.tag, "resetPosition");
    }

    // * Сохранить позицию элемента
    saveElementPosition(element) {
      var user, x, y;
      user = $gameSystem.aaGetUserUISettings();
      ({x, y} = element);
      user.set(element.tag, "setPosition", [x, y]);
    }

    elements() {
      return this.uiSpriteset.elements;
    }

    //TODO: Добавить кнопка H - скрыть\показать или скрыть \ показать последний (если не на элементе курсор)
    // Например стоит опция не показывать скрытые

      //TODO: Параметр плагина - OFF, Всегда, Только в режиме разработки

      //TODO: Кнопка - Сбросить до последний позиции???
    update() {
      super.update();
      this.updateMain(); //# -> Mouse
      this.updateExit();
      if (!this.isDrag) {
        // * Обновляем пользовательское управление (если не Drag)
        return this.updateInput();
      }
    }

    updateExit() {
      if (Input.isCancel()) {
        return this.popScene();
      }
    }

    updateInput() {
      // * Сброс позиции по умолчанию
      if (Input.isTriggered('r')) {
        if (this.elementUnderMouse != null) {
          this.resetElement(this.elementUnderMouse);
        }
      }
    }

    stop() {
      var elementData, i, len, ref;
      super.stop();
      if ($gameTemp._needRestoreABSSystemAfterUIEdit === true) {
        AA.System.resumeABS();
      }
      ref = this.preEditElementsStates;
      // * Восстанавливаем прозрачность и видимость которые были перед редактированием
      for (i = 0, len = ref.length; i < len; i++) {
        elementData = ref[i];
        elementData[0].visible = elementData[1];
        elementData[0].opacity = elementData[2];
      }
    }

  };
  AA.link(Scene_UIEditor);
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_UIEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Scene_UIEditor.prototype;
  _.createMain = function() {
    this.createBackground();
    // * Показать что в редакторе находимся
    this.createEditorMark();
    // * Сетки
    this.createGrids();
    this.createUI();
    this.createXYHelpText();
    return this.createTagHelpText();
  };
  // * За заднем плане карта
  _.createBackground = function() {
    this._backgroundSprite = new Sprite(SceneManager.backgroundBitmap());
    this.addChild(this._backgroundSprite);
    return this._backgroundSprite.opacity = 250;
  };
  _.createEditorMark = function() {
    var eLayer, eText, p;
    eLayer = KDCore.Sprite.FromBitmap(Graphics.width, Graphics.height);
    eLayer.fillAll("#C0C0C0".toCss());
    eLayer.opacity = 75;
    p = KDCore.UI.Sprite_UIText.prototype.defaultParams();
    p.size = {
      w: Graphics.width,
      h: 200
    };
    p.font.size = 72;
    eText = new KDCore.UI.Sprite_UIText(p);
    eText.drawText('UI Editor');
    eText.y = Graphics.height / 2 - 100;
    eLayer.addChild(eText);
    return this.addChild(eLayer);
  };
  // * Сетка для визуальной привязки (для шага 10)
  _.createGrids = function() {
    this.xGrid = this.createGridSprite(10);
    return this.addChild(this.xGrid);
  };
  _.createGridSprite = function(size) {
    var drawLineHor, drawLineVert, grid, i, j, k, l, ref, ref1;
    grid = KDCore.Sprite.FromBitmap(Graphics.width, Graphics.height);
    drawLineVert = function(b, i) {
      return b.fillRect(0, i * size, b.width, 1, 'rgba(0, 0, 0, 1)');
    };
    drawLineHor = function(b, i) {
      return b.fillRect(i * size, 0, 1, b.height, 'rgba(0, 0, 0, 1)');
    };
    for (i = k = 0, ref = grid.b().height / size; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      drawLineVert(grid.bitmap, i);
    }
    for (j = l = 0, ref1 = grid.b().width / size; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
      drawLineHor(grid.bitmap, j);
    }
    grid.visible = false;
    grid.opacity = 75;
    return grid;
  };
  // * В этом методе создаётся AA UI (не обновляемый)
  _.createUI = function() {
    this.uiSpriteset = new AA.Spriteset_UI();
    this.uiSpriteset.show(); // * Всегда видимый в редакторе
    this.addChild(this.uiSpriteset);
  };
  _.createXYHelpText = function() {
    var p;
    p = KDCore.UI.Sprite_UITextWithBack.prototype.defaultParams();
    p.text.size.w = 80;
    p.rect.size.w = 80;
    p.rect.borderColor = "";
    p.text.textColor = "#FFFFFF".toCss();
    this.xyText = new KDCore.UI.Sprite_UITextWithBack(p);
    this.xyText.fill("#C0C0C0".toCss());
    return this.addChild(this.xyText);
  };
  _.createTagHelpText = function() {
    var p;
    p = KDCore.UI.Sprite_UITextWithBack.prototype.defaultParams();
    p.text.size.w = 120;
    p.rect.size.w = 120;
    p.rect.borderColor = "";
    p.text.textColor = "#FFFFFF".toCss();
    this.tagText = new KDCore.UI.Sprite_UITextWithBack(p);
    this.tagText.fill("#808080".toCss());
    return this.addChild(this.tagText);
  };
})();

// ■ END Scene_UIEditor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_UIEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Scene_UIEditor.prototype;
  _.updateMain = function() {
    this.updateMouse();
    return this.updateXYText();
  };
  _.updateMouse = function() {
    this.xGrid.visible = false;
    if (this.isDrag === true) {
      this.updateDragEnd();
      return this.updateMouseDrag();
    } else {
      this.updateMouseHover();
      return this.updateDragStart();
    }
  };
  _.updateMouseHover = function() {
    var underMouse;
    this.elementUnderMouse = null;
    underMouse = this.elements().filter(function(e) {
      return e.isUnderMouse();
    });
    if (underMouse.isEmpty()) {
      return;
    }
    return this.elementUnderMouse = underMouse.last();
  };
  _.updateDragStart = function() {
    if (this.elementUnderMouse == null) {
      return;
    }
    if (!this.elementUnderMouse.isCanBeEdited()) {
      return;
    }
    if (TouchInput.isPressed()) {
      this.isDrag = true;
      this._lastElementPosition = this.elementUnderMouse.toPoint();
      // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
      this._deltaXY = this.getDeltaXY();
    }
  };
  _.getDeltaXY = function() {
    var dx, dy, x, y;
    ({x, y} = this.elementUnderMouse);
    dx = TouchInput.x - x;
    dy = TouchInput.y - y;
    return new KDCore.Point(dx, dy);
  };
  _.updateMouseDrag = function() {
    // * Проверка, есть ли элемент
    this.elementUnderMouse.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
    if (Input.isPressed('shift')) {
      this.applyMargin(2);
    } else if (Input.isPressed('control')) {
      this.applyMargin(10);
      this.xGrid.visible = true;
    }
    if (TouchInput.isCancelled()) {
      this.resetAfterDrag();
    }
  };
  // * Применить "привязывание" к координатам
  _.applyMargin = function(delta) {
    var x, y;
    ({x, y} = this.elementUnderMouse);
    while (x % delta !== 0) {
      x += 1;
    }
    while (y % delta !== 0) {
      y += 1;
    }
    return this.elementUnderMouse.move(x, y);
  };
  _.resetAfterDrag = function() {
    this.isDrag = false;
    TouchInput.clear();
    return this.elementUnderMouse.move(this._lastElementPosition);
  };
  _.updateDragEnd = function() {
    if (TouchInput.isReleased()) {
      this.isDrag = false;
      this.saveElementPosition(this.elementUnderMouse); //# -> @
    }
  };
  _.updateXYText = function() {
    var fillColor, t;
    fillColor = "#C0C0C0".toCss();
    this.tagText.visible = false;
    if (this.elementUnderMouse != null) {
      // * Показываем координаты элемента
      t = this.getXYTextFormat(this.elementUnderMouse);
      if (this.isDrag === true) {
        fillColor = "#008040".toCss();
      } else {
        if (this.elementUnderMouse.isCanBeEdited()) {
          fillColor = "#008080".toCss();
        } else {
          fillColor = "#FF8080".toCss();
        }
        this.tagText.draw(this.elementUnderMouse.tag);
        this.tagText.visible = true;
      }
    } else {
      t = this.getXYTextFormat(TouchInput);
    }
    this.xyText.fill(fillColor);
    this.xyText.draw(t);
    return this.moveXYTextHelp();
  };
  _.moveXYTextHelp = function() {
    this.xyText.move(TouchInput.x + 16, TouchInput.y + 16);
    this.tagText.move(this.xyText.x - 20, this.xyText.y + this.xyText.realHeight());
    // * Если слишком низки (за экран выходит)
    if (this.tagText.y + this.tagText.realHeight() > Graphics.height) {
      this.xyText.y = TouchInput.y - 16 - this.xyText.realHeight();
      this.tagText.y = this.xyText.y + this.xyText.realHeight();
    }
  };
  _.getXYTextFormat = function(point) {
    var x, y;
    ({x, y} = point);
    return "X:" + x + " ; Y:" + y;
  };
})();

// ■ END Scene_UIEditor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var Spirte_AASeqMapAnimation;

Spirte_AASeqMapAnimation = class Spirte_AASeqMapAnimation extends Sprite {
  constructor(x, y, imageName) {
    super();
    this._createPosChar(x, y);
    this._setupImage(imageName);
    this.anchor.x = 0.5;
    this.anchor.y = 1;
    this.ox = 0;
    this.oy = 0;
    if (KDCore.isMV()) {
      this.z = 1;
    }
    return;
  }

  setupOffsets(ox = 0, oy = 0) {
    this.ox = ox;
    this.oy = oy;
  }

  linkToMap() {
    var e, spriteset, tilemap;
    try {
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      spriteset = $gameMap.aaSpriteset();
      if (spriteset == null) {
        return;
      }
      tilemap = spriteset._tilemap;
      return tilemap != null ? tilemap.addChild(this) : void 0;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createPosChar(x, y) {
    this.pChar = new Game_Character();
    this.pChar.locate(x, y);
  }

  _setupImage(imageName) {
    var data;
    this._loaded = false;
    this._curFrame = 0;
    this._frameTimer = 0;
    data = AA.Utils.getFramesAndSpeed(imageName);
    this._frames = data.f;
    this._frameSpeed = data.s;
    KDCore.Utils.loadImageAsync('pictures', imageName).then(this._startAnimation.bind(this));
  }

  _startAnimation(bitmap) {
    this.bitmap = bitmap;
    this._updateFrame();
    this._updatePosition();
    this._loaded = true;
  }

  _updatePosition() {
    this.x = this.pChar.screenX() + this.ox;
    this.y = this.pChar.screenY() + this.oy;
  }

  _onEnd() {
    var e;
    this.visible = false;
    this.pChar = null;
    this.removeFromParent();
    try {
      return this.destroy();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  update() {
    super.update();
    if (!this.visible) {
      return;
    }
    if (!this._loaded) {
      return;
    }
    this._updateFrame();
    if (this.pChar != null) {
      this._updatePosition();
    }
  }

  _updateFrame() {
    var ph, pw, sx, sy;
    pw = this.bitmap.width / this._frames;
    ph = this.bitmap.height;
    sx = this._curFrame * pw;
    sy = 0;
    if (this._frameTimer >= this._frameSpeed) {
      this._frameTimer = 0;
      if (this._curFrame >= this._frames - 1) {
        this._onEnd();
      } else {
        this._curFrame += 1;
      }
    }
    this.setFrame(sx, sy, pw, ph);
    this._frameTimer += 1;
  }

};


// Generated by CoffeeScript 2.6.1
var Sprite_AACollider;

Sprite_AACollider = class Sprite_AACollider extends KDCore.Sprite {
  constructor(collider1, config) {
    super();
    this.collider = collider1;
    this.config = config;
    this._create();
  }

  static CreateFor(collider, color = "#FFFFFF", opacity = 150) {
    var e;
    try {
      return new Sprite_AACollider(collider, {color, opacity});
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return new Sprite();
    }
  }

  isValid() {
    return this.collider != null;
  }

  isCircle() {
    return this.isValid() && this.collider.isCircle();
  }

  isBox() {
    return this.isValid() && this.collider.isBox();
  }

  dispose() {
    return this.collider = null;
  }

  update() {
    var e;
    super.update();
    if (this.isValid()) {
      this.visible = true;
    } else {
      this.visible = false;
      return;
    }
    try {
      return this.move(this.collider.px(), this.collider.py());
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _create() {
    var e;
    try {
      if (!this.isValid()) {
        return;
      }
      if (this.isCircle()) {
        return this._createCircleColliderSpr();
      } else {
        return this._createBoxColliderSpr();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createCircleColliderSpr() {
    var colConfig, colliderSpr, color, e, opacity, radius, width;
    try {
      colConfig = this.collider.config;
      ({color, opacity} = this.config);
      ({radius} = colConfig);
      width = radius * 2;
      colliderSpr = new KDCore.Sprite(new Bitmap(width, width));
      colliderSpr.b().drawCircle(radius, radius, radius, color);
      colliderSpr.opacity = opacity;
      return this.addChild(colliderSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createBoxColliderSpr(colliderData, color) {
    var colConfig, colliderSpr, e, height, opacity, width;
    try {
      colConfig = this.collider.config;
      ({width, height} = colConfig);
      ({color, opacity} = this.config);
      colliderSpr = new KDCore.Sprite(new Bitmap(width, height));
      colliderSpr.b().fillAll(color);
      colliderSpr.opacity = opacity;
      return this.addChild(colliderSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
var Sprite_AACollisionsLayer;

Sprite_AACollisionsLayer = class Sprite_AACollisionsLayer extends KDCore.Sprite {
  constructor() {
    super();
    // * Sprites
    this._allCollidersSprites = [];
    // * Colliders
    this._collidersForEvents = {};
    this._collidersForParty = {};
    this._collidersForProjectiles = [];
    this.z = 9;
    this._createStaticMapColliders();
    return;
  }

  static Instance() {
    var e;
    try {
      if (KDCore.Utils.isSceneMap()) {
        return SceneManager._scene._spriteset._aaColsLayer;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  static Create() {
    var e, layer;
    try {
      if (Sprite_AACollisionsLayer.Instance() != null) {
        return;
      }
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      layer = new Sprite_AACollisionsLayer();
      SceneManager._scene._spriteset._aaColsLayer = layer;
      return SceneManager._scene._spriteset._tilemap.addChild(layer);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  static Destroy() {
    var e, layer;
    try {
      if (Sprite_AACollisionsLayer.Instance() == null) {
        return;
      }
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      layer = SceneManager._scene._spriteset._aaColsLayer;
      layer.visible = false;
      layer.removeFromParent();
      return SceneManager._scene._spriteset._aaColsLayer = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  // * --------------------------------------------------------------
  update() {
    super.update();
    return this._updateAllColliders();
  }

  _updateAllColliders() {
    var partyMembers;
    this._updateDynamicColliders($gameMap.events(), '_collidersForEvents', function(item) {
      return item.eventId();
    });
    partyMembers = $gamePlayer.followers()._data;
    partyMembers = partyMembers.concat($gamePlayer);
    this._updateDynamicColliders(partyMembers, '_collidersForParty', function(item) {
      return item.aaCharId();
    });
    this._updateProjectileColliders();
    this._updateStaticColliders();
  }

  _updateDynamicColliders(source, set, getKey) {
    var diff, e, i, item, j, keyId, len, len1, ref, results;
    try {
      results = [];
      for (i = 0, len = source.length; i < len; i++) {
        item = source[i];
        if (item == null) {
          continue;
        }
        keyId = getKey(item);
        if (item.aaIsHaveExColliders()) {
          if (this[set][keyId] == null) {
            this[set][keyId] = [];
          }
          diff = AA.Utils.compareArraysForDiff(item.aaGetAllExColliders(), this[set][keyId]);
          ref = diff.added;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            item = ref[j];
            this._createColliderSpr(item);
            this[set][keyId].push(item);
          }
          results.push((function() {
            var k, len2, ref1, results1;
            ref1 = diff.removed;
            results1 = [];
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              item = ref1[k];
              results1.push(this._destroyColliderSprite(item));
            }
            return results1;
          }).call(this));
        } else {
          if (this[set][keyId] != null) {
            this._destroyCollidersSet(this[set][keyId]);
          }
          results.push(this[set][keyId] = null);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createStaticMapColliders() {
    var e, i, item, len, ref, results;
    try {
      ref = $gameMap.aaGetAllExColliders();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._createColliderSpr(item));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _updateStaticColliders() {
    var e;
    try {
      return $gameMap.aaGetAllExColliders();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _updateProjectileColliders() {
    var e, i, j, len, len1, mapProjectiles, projectile, ref;
    try {
      mapProjectiles = $gameMap.aaMapSkills();
      for (i = 0, len = mapProjectiles.length; i < len; i++) {
        projectile = mapProjectiles[i];
        if (projectile == null) {
          continue;
        }
        if (this._collidersForProjectiles.contains(projectile)) {

        } else {
          // * NOTHING
          this._createColliderSpr(projectile.getCollider());
          this._collidersForProjectiles.push(projectile);
        }
      }
      ref = this._collidersForProjectiles;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        projectile = ref[j];
        if (!mapProjectiles.contains(projectile)) {
          this._destroyColliderSprite(projectile.getCollider());
          this._collidersForProjectiles.delete(projectile);
          break;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  _destroyCollidersSet(set) {
    var c, i, len;
    try {
      if (set == null) {
        return;
      }
      for (i = 0, len = set.length; i < len; i++) {
        c = set[i];
        this._destroyColliderSprite(c);
      }
    } catch (error) {}
  }

  _destroyColliderSprite(collider) {
    var e, spr;
    try {
      spr = this._allCollidersSprites.find(function(s) {
        return s.collider === collider;
      });
      if (spr == null) {
        return;
      }
      console.log("DESTROY");
      spr.visible = false;
      spr.removeFromParent();
      return this._allCollidersSprites.delete(spr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createColliderSpr(col) {
    var color, e, opacity, spr;
    try {
      //console.log("CREATE")
      [color, opacity] = this._getSettingsByFlag(col.flag);
      spr = Sprite_AACollider.CreateFor(col, color, opacity);
      spr.move(-1000, -1000);
      this.addChild(spr);
      this._allCollidersSprites.push(spr);
      return spr;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return new Sprite();
    }
  }

  _getSettingsByFlag(flag) {
    var e;
    try {
      switch (flag) {
        case "terrain":
          return ["#3fd13d", 150];
        case "region":
          return ["#944d80", 150];
        case "char":
        case "player":
          return ["#ffd257", 180];
        case "event":
          return ["#2a93d4", 150];
        case "projectile":
          return ["#e62412", 220];
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return ["#FFF", 150];
  }

};


// Generated by CoffeeScript 2.6.1
var Sprite_AACustomGauge;

Sprite_AACustomGauge = class Sprite_AACustomGauge extends KDCore.Sprite {
  constructor(id) {
    var refreshTime;
    super();
    this.id = id;
    this.gauge = this.getGauge();
    if (this.gauge == null) {
      return;
    }
    if (this.gauge.isDisposed()) {
      return;
    }
    this._create();
    if (this.gauge.isEnemyHpGauge()) {
      refreshTime = 4;
    } else {
      refreshTime = 20;
    }
    this._refreshThread = new KDCore.TimedUpdate(refreshTime, this.refresh.bind(this));
    this.refresh();
    return;
  }

  update() {
    super.update();
    if (this.__disposed != null) {
      return;
    }
    if (this._gaugeSpr == null) {
      return;
    }
    this._updatePosition();
    this._refreshThread.update();
  }

  getGauge() {
    return AACustomGaugesSystem.Instance().getGaugeDataById(this.id);
  }

  _create() {
    var e, text, textFormat;
    try {
      this._createGauge(this.gauge.gaugeParams);
      ({text, textFormat} = this.gauge.gaugeParams);
      if ((text != null) && text.visible === true) {
        this._captionTextFormat = textFormat;
        return this._createGaugeCaptionText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  refresh() {
    var currentValue, e, maxValue, rate, text;
    try {
      if (this._gaugeSpr == null) {
        return;
      }
      if (this.gauge != null) {
        rate = this.gauge.getCurrentRate();
        this._gaugeSpr.draw(rate);
        if (rate === 0 && this.gauge.isEnemyHpGauge()) {
          AACustomGaugesSystem.Instance().removeGauge(this.id);
        }
      } else {
        this._gaugeSpr.draw(0);
      }
      if ((this._textSpr != null) && (this._captionTextFormat != null)) {
        rate = this.gauge.getCurrentRate();
        currentValue = this.gauge.getCurrentValue();
        maxValue = this.gauge.getMaxValue();
        text = this._captionTextFormat.replace("$1", currentValue);
        text = text.replace("$2", maxValue);
        text = text.replace("$3", Math.round(rate * 100));
        this._textSpr.draw(text);
      }
      if (this.gauge.isDisposed()) {
        this.visible = false;
        this.removeFromParent();
        return this.__disposed = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _updatePosition() {
    var e, x, y;
    try {
      if (this._gaugeSpr == null) {
        return;
      }
      ({x, y} = this.gauge.getScreenPos());
      return this.move(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createGauge(p) {
    var e;
    try {
      if (p == null) {
        p = {
          visible: true,
          fill: "Player_HPGauge",
          foreground: "",
          mask: "",
          backColor: "#000000",
          backOpacity: 255,
          vertical: false,
          rootImageFolder: "Alpha"
        };
        AA.w("Parameters for Gauge not found! Used default one");
      }
      this._gaugeSpr = new KDCore.UI.Sprite_UIGauge(p);
      return this.addChild(this._gaugeSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createGaugeCaptionText(p) {
    var e;
    try {
      if (p == null) {
        return;
      }
      this._textSpr = new KDCore.UI.Sprite_UIText(p);
      return this.addChild(this._textSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_AADamagePopUpItem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var Sprite_AADamagePopUpItem;

Sprite_AADamagePopUpItem = class Sprite_AADamagePopUpItem extends KDCore.Sprite {
  constructor(settings1, value1) {
    super();
    this.settings = settings1;
    this.value = value1;
    this._init();
    this._createSprites();
    this._start();
  }

  dispose() {
    var ref;
    this.disposed = true;
    this.visible = false;
    this._removeDynamic();
    if ((ref = this.parent) != null) {
      ref.removeChild(this);
    }
  }

  update() {
    super.update();
    if (this.disposed === true) {
      return;
    }
    if (SceneManager.isSceneChanging()) {
      return;
    }
    this.thread.update();
    this._updateZoom();
    this._updateImageFadeIn();
  }

  // * Установить позицию и применить случайный сдвиг координат
  setStartPoint(x, y) {
    this.move(x, y);
    if (this.settings.randDX > 0) {
      this.x = this.x + Math.randomInt(this.settings.randDX) - Math.randomInt(this.settings.randDX * 2);
    }
    if (this.settings.randDY > 0) {
      this.y = this.y + Math.randomInt(this.settings.randDY);
    }
  }

  // * Привязан, надо удалять себя (aaRemoveDynamicSprite)
  setDynamic() {
    return this._isDynamic = true;
  }

  // * Общие методы создания Pop объекта
  // * Находяться прямо в классе, чтобы не создавать доп. менеджер

    // * Двигается вместе с персонажем (а не экраном)
  static CreateOnCharacterBinded(char, settings, value) {
    var charSprite, dy, e, ph, popDynamicParentSpr, popItem, spriteset, x, y;
    try {
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      if (char == null) {
        return;
      }
      if (settings == null) {
        return;
      }
      spriteset = $gameMap.aaSpriteset();
      charSprite = spriteset.findTargetSprite(char);
      if (charSprite == null) {
        return;
      }
      ({x, y} = charSprite);
      // * Создаётся спрайт "оболочка", которая будет привязана к координатам персонажа
      popDynamicParentSpr = new Sprite();
      popDynamicParentSpr.anchor.set(0.5);
      popItem = new Sprite_AADamagePopUpItem(settings, value);
      ph = charSprite.patternHeight();
      dy = -(ph - $gameMap.tileWidth() / 2);
      try {
        if ((char.AAModel() != null) && char.AAModel().damagePopUpYOffset !== 0) {
          dy = char.AAModel().damagePopUpYOffset;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        dy = 0;
      }
      popItem.setStartPoint(0, dy);
      // * Устанавливаем флаг, чтобы при Dispose удалять себя
      popItem.setDynamic();
      popDynamicParentSpr.addChild(popItem);
      // * Регестрируем как динамический спрайт
      spriteset.aaRegisterDynamicSprite(popDynamicParentSpr, char, 0, dy);
      // * Добавляем на слой PopUp
      return spriteset.aaGetDamagePopUpLayer().addChild(popDynamicParentSpr);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnCharacter(char, settings, value) {
    var charSprite, e, spriteset, x, y;
    try {
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      if (char == null) {
        return;
      }
      spriteset = $gameMap.aaSpriteset();
      charSprite = spriteset.findTargetSprite(char);
      if (charSprite == null) {
        return;
      }
      ({x, y} = charSprite);
      y = y - charSprite.patternHeight() - $gameMap.tileWidth() / 2;
      return Sprite_AADamagePopUpItem.CreateOnScreen(x, y, settings, value);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnMap(x, y, settings, value) {
    var e, screenX, screenY, tempChar;
    try {
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      tempChar = new Game_Character();
      tempChar.setPosition(x, y);
      screenX = tempChar.screenX();
      screenY = tempChar.screenY() - $gameMap.tileWidth();
      return Sprite_AADamagePopUpItem.CreateOnScreen(screenX, screenY, settings, value);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnScreen(x, y, settings, value) {
    var e, popItem, spriteset;
    try {
      if (settings == null) {
        return;
      }
      if (!KDCore.Utils.isSceneMap()) {
        return;
      }
      popItem = new Sprite_AADamagePopUpItem(settings, value);
      popItem.setStartPoint(x, y);
      spriteset = $gameMap.aaSpriteset();
      return spriteset.aaGetDamagePopUpLayer().addChild(popItem);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_AADamagePopUpItem.prototype;
  _._init = function() {
    this.disposed = false;
    this.isNeedZoom = true;
    this.stayTime = 0;
    this.maxStayTime = this.settings.stayTime; // * 60
  };
  _._createSprites = function() {
    var e;
    if (this.settings == null) {
      return;
    }
    // * Используется для расчёта размера текста
    this.bitmap = new Bitmap(50, 50);
    this.anchor.set(0.5);
    try {
      this.bitmap.fontSize = Math.max(this.settings.text.font.size, this.settings.changeFontSize);
      this._createValueText();
      if ((this.settings.image != null) && String.any(this.settings.image.name)) {
        return this._createImage();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._createValueText = function() {
    var e, h, w;
    try {
      w = this.bitmap.measureTextWidth(this.value) + 4;
      h = this.settings.text.font.size + 10;
      // * Присваеваем новые значение (посчитанные)
      this.settings.text.size.w = w;
      this.settings.text.size.h = h;
      this.valueSprite = KDCore.Sprite.FromParams(this.settings.text);
      this.valueSprite.anchor.set(0.5);
      this.valueSprite.onReady(this._drawValue.bind(this));
      return this.add(this.valueSprite);
    } catch (error) {
      e = error;
      AA.w(e);
      return this.valueSprite = new Sprite();
    }
  };
  _._drawValue = function() {
    this.valueSprite.clear();
    return this.valueSprite.drawTextFull(this.value, this.settings.text.alignment);
  };
  _._createImage = function() {
    var e, settings;
    try {
      settings = this.settings.image;
      this.imageSprite = KDCore.Sprite.FromImg(settings.name);
      this.imageSprite.x = settings.margins.x || 0;
      this.imageSprite.y = settings.margins.y || 0;
      this.imageSprite.anchor.set(0.5);
      this.imageSprite.opacity = 0;
      return this.add(this.imageSprite);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._start = function() {
    this.thread = new KDCore.TimedUpdate(2, this._updateLife.bind(this));
  };
  _._updateLife = function() {
    // * Сперва идёт анимация увеличения, затемм только отсчёт таймера
    if (this.isNeedZoom === true) {
      return;
    }
    if (this.disposed === true) {
      return;
    }
    if (SceneManager.isSceneChanging()) {
      return;
    }
    if (this.maxStayTime <= 0) {
      this.dispose();
    } else {
      if (this.stayTime++ < this.maxStayTime) {
        return;
      }
    }
    this._updateOpacity();
    this._updateMoveUp();
    if (this.opacity <= 0) {
      this.dispose();
    }
  };
  _._updateOpacity = function() {
    var e;
    try {
      // * Если не надо, то сразу исчезает
      if (this.settings.noFadeOut === true) {
        this.opacity = 0;
      } else {
        this.opacity -= 25;
      }
    } catch (error) {
      e = error;
    }
  };
  _._updateMoveUp = function() {
    var e;
    if (this.settings.noFlyUp === true) {
      return;
    }
    try {
      this.move(this.x, this.y - 1);
    } catch (error) {
      e = error;
    }
  };
  _._updateZoom = function() {
    var b, e;
    if (!this.isNeedZoom) {
      return;
    }
    try {
      b = this.valueSprite.bitmap;
      if (b.fontSize === this.settings.changeFontSize) {
        this.isNeedZoom = false;
        return;
      }
      if (b.fontSize < this.settings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
      } else if (b.fontSize > this.settings.changeFontSize) {
        b.fontSize = b.fontSize - 1;
      }
      this._drawValue();
    } catch (error) {
      e = error;
    }
  };
  _._updateImageFadeIn = function() {
    var e;
    try {
      if (this.imageSprite == null) {
        return;
      }
      if (this.imageSprite.opacity >= 255) {
        return;
      }
      this.imageSprite.opacity += this.settings.image.fadeInSpeed;
    } catch (error) {
      e = error;
    }
  };
  _._removeDynamic = function() {
    var e, spriteset;
    if (this._isDynamic !== true) {
      return;
    }
    try {
      spriteset = $gameMap.aaSpriteset();
      spriteset.aaRemoveDynamicSprite(this);
      if (this.parent != null) {
        return spriteset.aaRemoveDynamicSprite(this.parent);
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
})();

// ■ END Sprite_AADamagePopUpItem.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_AAMapFlyBonus.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Данный спрайт практически похож на Sprite_AAMapSkill2Projectile
var Sprite_AAMapFlyBonus;

Sprite_AAMapFlyBonus = class Sprite_AAMapFlyBonus extends KDCore.Sprite {
  constructor(mapIndex, isAppear) {
    super();
    this.mapIndex = mapIndex;
    this.obj = $gameMap.aaMapFlyBonuses()[this.mapIndex];
    this._ended = false;
    this._isShouldAppear = isAppear;
    this._initParams();
    this._setupImage();
    this._updatePosition();
    if (this._frames != null) {
      this._updateFrame();
    }
    if (this._isShouldAppear === true) {
      this._setupAppear();
    }
    return;
  }

  // * Завёршён (достиг игрока)
  isEnd() {
    return this._ended === true;
  }

  update() {
    super.update();
    if (this._frames != null) {
      this._updateFrame();
    }
    this._updatePosition();
    if (this._isShouldAppear === false) {
      this._updateDirection();
      if (!this.isEnd()) {
        this._updateHit();
      }
    } else {
      this._updateAppear();
    }
    this._updateMove();
    if (this.isEnd()) {
      this._updateEnd();
    }
  }

  _initParams() {
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
    this.z = 9;
  }

  _setupImage() {
    this._setupAnimatedImg();
    this.bitmap = ImageManager.loadPicture(this.obj.image());
  }

  _setupAnimatedImg() {
    var data;
    this._curFrame = 0;
    this._frameTimer = 0;
    data = AA.Utils.getFramesAndSpeed(this.obj.image());
    this._frames = data.f;
    this._frameSpeed = data.s;
  }

  _updateDirection() {
    var eX, eY, sX, sY, x, y;
    ({x, y} = this.obj.getTargetPoint());
    eX = x;
    eY = y;
    sX = this.obj.x;
    sY = this.obj.y;
    this._angle = Math.atan2(eY - sY, eX - sX) * 180 / Math.PI;
    this.dx = this.obj.speed() * Math.cos(this._angle * Math.PI / 180);
    this.dy = this.obj.speed() * Math.sin(this._angle * Math.PI / 180);
  }

  _updatePosition() {
    this.x = this.obj.x - $gameMap.displayX() * $gameMap.tileWidth();
    this.y = this.obj.y - $gameMap.displayY() * $gameMap.tileWidth();
  }

  _updateMove() {
    this.obj.x += this.dx;
    this.obj.y += this.dy;
  }

  _updateFrame() {
    var ph, pw, sx, sy;
    pw = this.bitmap.width / this._frames;
    ph = this.bitmap.height;
    sx = this._curFrame * pw;
    sy = 0;
    if (this._frameTimer >= this._frameSpeed) {
      this._frameTimer = 0;
      this._curFrame = this._curFrame >= this._frames - 1 ? 0 : this._curFrame + 1;
    }
    this.setFrame(sx, sy, pw, ph);
    this._frameTimer += 1;
  }

  _updateHit() {
    var playerHit;
    if (this.obj.isPhantom()) {
      return;
    }
    playerHit = this._checkHitPlayer();
    if (playerHit === true) {
      this.onHit();
    }
  }

  _updateEnd() {
    this.opacity -= 36;
    if (this.opacity < 50) {
      return this.onEnd();
    }
  }

  onEnd() {
    //"ON END".p()
    this.opacity = 0;
    // * Using the same Event as Skills
    AA.EV.call("MapSkillsRequestsClean");
  }

  _updateAppear() {
    if (this._yUpStep >= 12) {
      this.dy = 0; // * stop moving up
      this._delay++; // * wait a little
      this._updateHit(); // * can check Hit
      if (this._delay > this._delayMax) {
        this._isShouldAppear = false; // * fly to Player
      }
    } else {
      this._yUpStep += 1;
      this.opacity += 20;
    }
  }

  _setupAppear() {
    this._delay = 0;
    this._delayMax = this.obj.delay() / 2 + Math.randomInt(this.obj.delay() + this.obj.delay() / 2);
    this._yUpStep = 0;
    this.dy = -1;
    this.opacity = 0;
    this.dx = 0;
  }

  // * Когда достиг игрока
  _checkHitPlayer() {
    var dist;
    dist = AATargetsManager.getScreenExtDistance($gamePlayer, 0, this.x, this.y);
    return dist < 26;
  }

  onHit() {
    //"ON HIT".p()
    this._ended = true;
    this._isShouldAppear = false;
    this.obj.onHit();
  }

};

// ■ END Sprite_AAMapFlyBonus.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var Sprite_AAMapSkill2Projectile;

Sprite_AAMapSkill2Projectile = class Sprite_AAMapSkill2Projectile extends Sprite {
  constructor(mapIndex) {
    super();
    this.mapIndex = mapIndex;
    this.skill = $gameMap.aaMapSkills()[this.mapIndex];
    this._id = this.skill.id();
    this._ended = false;
    this._hasHit = false;
    this._speed = this.skill.speed();
    if (AA.System.isExCollisionActive()) {
      this._collider = this.skill.createCollider();
      this._checkCollision = this._checkCollisionNew;
    } else {
      this._checkCollision = this._checkCollisionOld;
    }
    if (this.skill.isKeepOutScreen()) {
      this._updateOutOfScreen = function() {};
    } else {
      this._outOfScreenCheckInterval = 0;
    }
    this._initParams();
    this._setupImage();
    this._setupDirection();
    this._speed = 4;
    if (this._speed <= 4) {
      this._collisionDetectionThread = new KDCore.TimedUpdate(2, this._checkCollision.bind(this));
    } else {
      this._collisionDetectionThread = new KDCore.TimedUpdate(0, this._checkCollision.bind(this));
    }
    this._updatePosition();
    if (this._frames != null) {
      this._updateFrame();
    }
    return;
  }

  // * Навык завершён (достиг цели или расстояния)
  isEnd() {
    return this._ended === true;
  }

  update() {
    super.update();
    if (this.skill.isHoming()) {
      this.skill.refreshHomingPoint();
      if (this.skill.isHaveHomingTarget()) {
        this._setupDirection();
      }
    }
    this._updatePosition();
    if (this._frames != null) {
      this._updateFrame();
    }
    if (this._hasHit === true) {
      // * Зануляем принудительно, если достиг цели
      this.skill.totalFlyTime = 0;
      this.skill.offHoming();
    } else {
      this._updateMove();
      this._collisionDetectionThread.update();
      this.skill.totalFlyTime -= 1;
    }
    this._updateOutOfScreen();
    this._updateEnd();
  }

};

(function() {  
  //TODO: СИСТЕМАТИЗАЦИЯ И КОММЕНТАРИИ

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_AAMapSkill2Projectile.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Sprite_AAMapSkill2Projectile.prototype;
  _._initParams = function() {
    var e, evOffset, plOffset, subj;
    this._framesBeforeStartFadeToEnd = 5;
    // * FROM START SUBJECT OFFSET
    this._yOffset = 0;
    try {
      if (this.skill.isSubjectIsEvent()) {
        subj = this.skill.getSubject();
        evOffset = subj._aaMapSkillVectorOffset;
        if ((evOffset != null) && evOffset !== 0 && isFinite(evOffset)) {
          this._yOffset = evOffset;
        }
      } else {
        subj = this.skill.getSubject().AABattler();
        plOffset = subj.aaGetProjectileStartOffset();
        if (plOffset != null) {
          this._yOffset = plOffset;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
      this._yOffset = 0;
    }
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
    this.z = this.skill.zLevel();
    this._hitDist = this.skill.hitOffset();
    this._hitsLeft = this.skill.hitsCount();
    // * Продолжает урон одной и тоже цели если навык всё ещё "в ней" (не пролетел)
    this._hitsContnues = this.skill.isHitsContinues();
  };
  _._setupImage = function() {
    this.image = new KDCore.Sprite();
    this.addChild(this.image);
    this._setupAnimatedImg();
    this.image.anchor.x = 0.5;
    this.image.anchor.y = 0.5;
    this.image.appear(25, 5);
    this.image.bitmap = ImageManager.loadPicture(this.skill.image());
    this.image.bitmap.addLoadListener(() => {
      return this.image.y = this.image.bitmap.height / 2;
    });
  };
  _._setupAnimatedImg = function() {
    var data;
    this._curFrame = 0;
    this._frameTimer = 0;
    data = AA.Utils.getFramesAndSpeed(this.skill.image());
    this._frames = data.f;
    this._frameSpeed = data.s;
  };
  _._setupDirection = function() {
    var a, eX, eY, pi, sX, sY, yo;
    yo = 0;
    eX = this.skill.scX;
    eY = this.skill.scY;
    sX = this.skill.x;
    sY = this.skill.y;
    this._angle = Math.atan2(eY - yo - sY, eX - sX) * 180 / Math.PI;
    pi = Math.PI / 180;
    if (!this.skill.isStaticAngle()) {
      this.rotation = (this._angle + 90) * pi;
    }
    a = this._angle * pi;
    this.dx = this._speed * Math.cos(a);
    this.dy = this._speed * Math.sin(a);
  };
  _._updatePosition = function() {
    this.x = this.skill.x - $gameMap.displayX() * $gameMap.tileWidth();
    this.y = this.skill.y - $gameMap.displayY() * $gameMap.tileWidth() + this._yOffset;
    this.skill.refreshColliderPosition(this.x, this.y);
  };
  _._updateMove = function() {
    this.skill.x += this.dx;
    this.skill.y += this.dy;
  };
  _._updateFrame = function() {
    var ph, pw, sx, sy;
    pw = this.image.bitmap.width / this._frames;
    ph = this.image.bitmap.height;
    sx = this._curFrame * pw;
    sy = 0;
    if (this._frameTimer >= this._frameSpeed) {
      this._frameTimer = 0;
      this._curFrame = this._curFrame >= this._frames - 1 ? 0 : this._curFrame + 1;
    }
    this._setImageFrame(sx, sy, pw, ph);
    this._frameTimer += 1;
  };
  _._setImageFrame = function(sx, sy, pw, ph) {
    var e;
    try {
      return this.image.setFrame(sx, sy, pw, ph);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._updateEnd = function() {
    if (this.skill.totalFlyTime > 0) {
      return;
    }
    this.skill.offHoming();
    if (this._framesBeforeStartFadeToEnd < 0) {
      this.opacity -= 40;
      if (this.opacity <= 0) {
        return this._onTimeEnded();
      }
    } else {
      this._framesBeforeStartFadeToEnd -= 1;
      // * Мнгновенно пропадает, если был "выключен" из сети
      if (this.skill.forceEndFromNetwork === true) {
        this.opacity = 0;
        this._framesBeforeStartFadeToEnd = -1;
      }
    }
  };
  _._updateOutOfScreen = function() {
    var e;
    try {
      this._outOfScreenCheckInterval++;
      if (this._outOfScreenCheckInterval > 30) {
        this._outOfScreenCheckInterval = 0;
        if (this.x < 0 || this.x > Graphics.width || this.y < 0 || this.y > Graphics.height) {
          console.log("PROJECTILE OUT OF SCREEN " + this.skill.uniqueId);
          this._ended = true;
          this.removeFromParent();
          return AA.EV.call("MapSkillsRequestsClean");
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._onTimeEnded = function() {
    var x, y;
    this._ended = true;
    // * Если навык без контактный и его "время" закончено, он должен сработать всё равно
    if (this._hasHit === false && this.skill.isNoContact() && !this.skill.isPhantom()) {
      x = Math.floor(this.skill.x / $gameMap.tileWidth());
      y = Math.floor(this.skill.y / $gameMap.tileWidth());
      this.onHit({x, y});
    }
    this.removeFromParent();
    AA.EV.call("MapSkillsRequestsClean");
  };
  //@[DYNAMIC]
  _._checkCollision = function() {};
  _._checkCollisionOld = function() {
    var event, map, netChar, playerHit, point, x, y;
    if (this.skill.isPhantom()) {
      return;
    }
    if (this.opacity < 255) {
      return;
    }
    playerHit = this._checkHitPlayer();
    if (playerHit === true) {
      //"PLAYER HIT".p()
      this.onHit($gamePlayer);
      return;
    }
    // * Для оптимизации, считаем один раз тут, а не в каждом методе
    x = Math.floor(this.skill.x / $gameMap.tileWidth());
    y = Math.floor(this.skill.y / $gameMap.tileWidth());
    map = this._checkHitMap(x, y);
    if (map === true) {
      //"MAP OBSTCL HIT".p()
      this.onHit({x, y});
      return;
    }
    point = this._checkHitPoint(x, y);
    if (point === true) {
      //"POINT HIT".p()
      this.onHit({x, y});
      return;
    }
    event = this._checkHitEvent();
    if (event != null) {
      //"EVENT HIT".p()
      this.onHit(event);
      return;
    }
    if (AA.Network.isNetworkGame()) {
      netChar = this._checkHitNetworkChar();
      if (netChar != null) {
        this.onHit(netChar);
        return;
      }
    }
  };
  // * Когда достиг игрока
  _._checkHitPlayer = function() {
    var dist;
    if (this.skill.isSubjectIsPlayer()) {
      //TODO: friendlyfier is 1
      return false;
    }
    if (this.skill.isSubjectIsAlly()) {
      return false;
    }
    if ($gamePlayer.aaIsInvincible()) {
      return false;
    }
    dist = AATargetsManager.getScreenExtDistance($gamePlayer, $gameTemp.aaProjYOff, this.x, this.y);
    return dist < this._hitDist && this.isSameMapLevel($gamePlayer._priorityType);
  };
  // * Когда достиг точки на карте (указанной как цель)
  _._checkHitPoint = function(tx, ty) {
    if (!this.skill.isCanHitPoint()) {
      return false;
    }
    return this.skill.tX === tx && this.skill.tY === ty;
  };
  // * Когда препятсвие на карте (Регион или Terrain)
  _._checkHitMap = function(tx, ty) {
    return this.skill.isHaveRegion($gameMap.regionId(tx, ty)) || this.skill.isHaveTerrain($gameMap.terrainTag(tx, ty));
  };
  // * Когда достиг события
  _._checkHitEvent = function() {
    var dist, ev, i, len, ref, subId;
    subId = this.skill.getSubjectEvId();
    ref = $gameMap.events();
    for (i = 0, len = ref.length; i < len; i++) {
      ev = ref[i];
      if (ev == null) {
        continue;
      }
      if (ev.eventId() === subId) {
        // * В себя нельзя попасть
        continue;
      }
      dist = AATargetsManager.getScreenExtDistance(ev, $gameTemp.aaProjYOff, this.x, this.y);
      if (dist < this._hitDist && this.isEventIsObstacle(ev)) {
        return ev;
      }
    }
    return null;
  };
  // * Когда достиг сетевого игрока
  _._checkHitNetworkChar = function() {
    var dist, e, i, id, len, netChar, ref;
    try {
      if (!AA.Network.isNetworkPvPGame()) {
        //TODO: friendlyfier is 1
        return null;
      }
      ref = [...$gameMap.netChars(), $gamePlayer];
      for (i = 0, len = ref.length; i < len; i++) {
        netChar = ref[i];
        if (netChar == null) {
          continue;
        }
        // * В себя нельзя попасть
        // * Тут сложный код, потому что только  на мастере карты выполняется эта проверка
        id = this.skill.getSubjectNetId();
        if (id === -1) {
          if (netChar === $gamePlayer) {
            continue;
          }
        } else {
          if (netChar.id === id) {
            continue;
          }
        }
        dist = AATargetsManager.getScreenExtDistance(netChar, $gameTemp.aaProjYOff, this.x, this.y);
        if (dist < this._hitDist && this.isSameMapLevel(netChar._priorityType)) {
          return netChar;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.isSameMapLevel = function(priorityType) {
    if (this.z <= 2) {
      // * Ниже персонажей
      return priorityType === 0;
    }
    if (this.z <= 4) {
      // * На одном уровне
      return priorityType === 1;
    }
    // * Выше
    return priorityType === 3;
  };
  // * Блокирует ли событие Projectile ?
  _.isEventIsObstacle = function(event) {
    if (event._erased) {
      return false;
    }
    if (event.isThrough()) {
      return false;
    }
    if (this.skill.isDummySubject() && this.skill.isSubjInSamePointWith(event)) {
      return false;
    }
    if (event._aaMapSkillVectorBlockList == null) {
      return this.isSameMapLevel(event._priorityType);
    } else {
      if (event._aaMapSkillVectorBlockList.isEmpty()) {
        return false;
      }
      return !event._aaMapSkillVectorBlockList.contains(this.skill.id());
    }
  };
  _.onHit = function(target) {
    if (this.isHitsContinues === true) {
      this.skill.resetHoming();
      return this.onContinuesHit(target);
    } else {
      return this.onBasicHit(target);
    }
  };
  _.onContinuesHit = function(target) {
    this._hitsLeft -= 1;
    if (this.isShouldEnd()) {
      this._finalizeHit();
    }
    return this._targetHitProcess(target);
  };
  _.onBasicHit = function(target) {
    if (this.isSameTarget(target) && this._hitsLeft > 0) {
      return;
    }
    this._hitsLeft -= 1;
    if (this.isShouldEnd()) {
      this._finalizeHit();
    } else {
      this._lastHittedTarget = target;
    }
    this._targetHitProcess(target);
  };
  _._finalizeHit = function() {
    var e, subject;
    this._hasHit = true;
    this.opacity = 0;
    try {
      if (this.skill.isDummySubject()) {
        subject = this.skill.getSubject();
        if (subject != null) {
          setTimeout((function() {
            var e;
            try {
              return subject != null ? subject.dispose() : void 0;
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }), 1000);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  _._targetHitProcess = function(target) {
    //"HIT".p()
    //console.info(target)
    if (AA.PP.isUseMorePreciseProjectileAnimations() && !AA.Network.isNetworkGame()) {
      target.__aaLastProjectileHitPoint = {
        x: this.x,
        y: this.y
      };
    }
    AABattleActionsManager.applySkillAction(this.skill.getSubject(), target, this.skill.aaSkill);
    // * Vector On Hit Actions работают отдельно, не в AABattleActionsManager
    if (target instanceof Game_Event) {
      target.aaOnVectorHit(this.skill.id());
    }
    if (!this.skill.isPhantom()) {
      AANetworkManager.endAASkillOnMap(this.skill.uniqueId);
    }
  };
  _.isSameTarget = function(target) {
    if (this._lastHittedTarget == null) {
      return false;
    }
    if (target === this._lastHittedTarget) {
      return true;
    }
  };
  _.isShouldEnd = function() {
    return this._hitsLeft <= 0;
  };
})();

// ■ END Sprite_AAMapSkill2Projectile.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var Sprite_AAProjectile;

Sprite_AAProjectile = class Sprite_AAProjectile extends KDCore.Sprite {
  constructor(refId) {
    super();
    this.refId = refId;
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
    this._createVisual();
    this.appear(25);
  }

  projectileData() {
    if (this._projectileData == null) {
      this._projectileData = $gameMap.aaGetProjectileById(this.refId);
    }
    return this._projectileData;
  }

  update() {
    var e, proj;
    super.update();
    try {
      if (this.__disposed === true) {
        return;
      }
      proj = this.projectileData();
      if (proj != null) {
        proj.update();
        this.synchronizeData(proj);
        if (this._frames != null) {
          return this._updateFrame();
        }
      } else {
        /*if proj.isShouldBeDestroyed()
            @_playHitAnimation()
            proj.removeFromMap()
        if proj.isShouldBeFadeOut()
            proj._fadeOutRequested = false
            @disapper(25)*/
        return this.dispose();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  synchronizeData(projectileData) {
    var e;
    try {
      //@x = projectileData.x - $gameMap.displayX() * $gameMap.tileWidth()
      //dy = projectileData.yOffset
      //@y = projectileData.y - $gameMap.displayY() * $gameMap.tileHeight() + dy
      this.x = projectileData.screenX();
      this.y = projectileData.screenY();
      this.rotation = projectileData.rotation;
      return this.z = projectileData.zLevel();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  dispose() {
    var e;
    try {
      console.log("DISPOSE");
      this.visible = false;
      this.removeFromParent();
      this.refId = null;
      return this.__disposed = true;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createVisual() {
    var e, proj;
    try {
      proj = this.projectileData();
      if (proj == null) {
        return;
      }
      return this._setupImage();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _setupImage() {
    var data, image;
    image = this.projectileData().image();
    this._curFrame = 0;
    this._frameTimer = 0;
    data = AA.Utils.getFramesAndSpeed(image);
    this._frames = data.f;
    this._frameSpeed = data.s;
    this.bitmap = ImageManager.loadPicture(image);
  }

  _updateFrame() {
    var e, ph, pw, sx, sy;
    try {
      pw = this.bitmap.width / this._frames;
      ph = this.bitmap.height;
      sx = this._curFrame * pw;
      sy = 0;
      if (this._frameTimer >= this._frameSpeed) {
        this._frameTimer = 0;
        this._curFrame = this._curFrame >= this._frames - 1 ? 0 : this._curFrame + 1;
      }
      this.setFrame(sx, sy, pw, ph);
      return this._frameTimer += 1;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};

/* _playHitAnimation: ->
       try
           proj = @projectileData()
 * * Screen X, Y
           BattleSystem.PlayAnimationOnMap(@x, @y, proj.animationId())
       catch e
           KDCore.warning e */


// Generated by CoffeeScript 2.6.1
// * Класс для показа базовых параметров игрока HP, MP, TP
(function() {
  var Sprite_ActorStateGauge;
  Sprite_ActorStateGauge = class Sprite_ActorStateGauge extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    //%[I] Переделать вывод значения как у Enemy Mini HP
    defaultParams() {
      return AA.PP._getDefaultVisualFor_hpGauge();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    drawGauge(percent) {
      return this.gauge.draw(percent);
    }

    drawText(text) {
      return this.text.draw(text);
    }

  };
  AA.link(Sprite_ActorStateGauge);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_ActorStateGauge.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createGauge();
    this._createText();
    this._createLabel();
    //%[I] Делать eval для позиции
    return this.move(this.params.position);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    return this.add(this.gauge);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._createLabel = function() {
    var label;
    if (String.isNullOrEmpty(this.params.label)) {
      return;
    }
    label = new KDCore.UI.Sprite_UIImage();
    label.draw(this.params.label);
    label.move(this.params.labelMargins);
    return this.add(label);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для показа иконки состояния или баффа игрока
(function() {
  var Sprite_ActorStateIcon;
  //%[I] Улучшенные настройки, чтобы можно было разным цветом рисовать цифры
  // * Можно было у состояния прописать стиль (было в AABS)
  Sprite_ActorStateIcon = class Sprite_ActorStateIcon extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    //@_lastIconIndex = 0
    //@_lastTextValue = null

      //defaultParams: -> AA.PP._getDefaultActorBuffIcon()
    drawBuffInfo(iconIndex, text) {
      this._drawStateIcon(iconIndex);
      this._drawBuffText(text);
    }

    drawStateInfo(iconIndex, text, isActionCounted = false) {
      this.drawBuffInfo(iconIndex, text); // * same
      if (isActionCounted === true) {
        this._drawStateActText(text); // * overwrite time text to action count text
      }
    }

    drawIcon(index) {
      return this.icon.draw(index);
    }

    drawText(text) {
      return this.text.draw(text);
    }

    clear() {
      this.drawIcon(0);
      return this.drawText("");
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

  };
  AA.link(Sprite_ActorStateIcon);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_ActorStateIcon.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createIcon();
    this._createText();
    return this.move(this.params.position);
  };
  _._createIcon = function() {
    this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
    return this.add(this.icon);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._drawStateIcon = function(iconIndex) {
    //return if @_lastIconIndex == iconIndex
    this.drawIcon(iconIndex);
  };
  //@_lastIconIndex = iconIndex
  _._drawBuffText = function(text) {
    var e, time;
    try {
      //return if @_lastTextValue == text
      if ((text != null) && isFinite(text)) {
        time = KDCore.Utils.convertTimeShort(text);
        return this.drawText(this.params.textFormat.replace("%1", time));
      } else {
        return this.drawText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@_lastTextValue = text
  _._drawStateActText = function(text) {
    var e;
    try {
      //return if @_lastTextValueA == text
      if ((text != null) && isFinite(text)) {
        return this.drawText(this.params.textFormatA.replace("%1", text));
      } else {
        return this.drawText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------
//@_lastTextValueA = text


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Animation.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__targetSpritePosition, ALIAS__targetSpritePosition2, _;
  // * MZ only
  if (KDCore.isMV()) {
    return;
  }
  //@[DEFINES]
  _ = Sprite_Animation.prototype;
  //@[ALIAS]
  ALIAS__targetSpritePosition = _.targetSpritePosition;
  _.targetSpritePosition = function(sprite) {
    var e;
    try {
      if (sprite instanceof Sprite_Character && (sprite.parent == null)) {
        if (KDCore.Utils.isSceneMap()) {
          SceneManager._scene._spriteset._tilemap.addChild(sprite);
        } else {
          return {
            x: 0,
            y: 0
          };
        }
      }
      return ALIAS__targetSpritePosition.call(this, sprite);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return {
        x: 0,
        y: 0
      };
    }
  };
  
  //@[ALIAS]
  ALIAS__targetSpritePosition2 = _.targetSpritePosition;
  _.targetSpritePosition = function(sprite) {
    var difX, difY, result, t, x, y;
    result = ALIAS__targetSpritePosition2.call(this, ...arguments);
    if ((sprite != null) && (sprite.__aaExAnimationPos != null) && (sprite._character != null)) {
      ({difX, difY} = sprite.__aaExAnimationPos);
      t = sprite._character;
      x = t.screenX() + difX;
      y = t.screenY() + difY;
      return {x, y};
    }
    return result;
  };
})();

// ■ END Sprite_Animation.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Animation.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Sprite_Animation.prototype;
  _.aaApplyMapScale = function() {
    var scallingFactor;
    scallingFactor = AA.PP.getAnimationAutoScallingFactor();
    if (scallingFactor <= 0) {
      return;
    }
    this.scale.x = scallingFactor;
    this.scale.y = scallingFactor;
  };
})();

// ■ END Sprite_Animation.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startAnimation, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  if (KDCore.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__startAnimation = _.startAnimation;
  _.startAnimation = function() {
    var e, ref;
    ALIAS__startAnimation.call(this, ...arguments);
    // * Применяем масштабирование анимации
    if ((this._character != null) && this._character.__aaIsRequestAnimationScale === true) {
      try {
        this._character.__aaIsRequestAnimationScale = false;
        if ((ref = this._animationSprites.last()) != null) {
          ref.aaApplyMapScale();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__setCharacter, ALIAS__update, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._aaIsShouldCheckVisionDraw = false;
    AA.EV.subscribeFor("PlayerSkillSelector", this.gev_onPlayerSkillSelector.bind(this));
    AA.EV.subscribeFor("UnderMouseEventChanged", this.gev_onUnderMouseEventChanged.bind(this));
  };
  
  //@[ALIAS]
  ALIAS__setCharacter = _.setCharacter;
  _.setCharacter = function() {
    ALIAS__setCharacter.call(this, ...arguments);
    this._aaPrepareMotion();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    // * Если в зоне навыка, подсвечиваться
    this._aaUpdate();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  // * Создать дополнительные спрайты для ABS системы
  _.initABS = function() {
    this._aaSetupExtraInfo();
    this._aaSetupWeaponMotionSprite();
    this._aaSetupStateOverlaySprite();
    this._aaSetupStateIcon();
  };
  _.isPlayer = function() {
    return this._character === $gamePlayer;
  };
  _.isABSEntity = function() {
    return (this._character != null) && this._character.isABS() && (this._character.AABattler() != null);
  };
  _.isAllyParty = function() {
    return this.isABSEntity() && this._character.AAEntity().isAlly();
  };
  _.isEnemy = function() {
    return this.isABSEntity() && this._character.AAEntity().isEnemy();
  };
  _._aaUpdate = function() {
    this._aaUpdateSelectionBlend();
    this._aaUpdateDamagePopUps();
    this._aaUpdateSpriteEffects();
    this._aaUpdateWeaponMotion();
    this._aaUpdateStateOverlay();
    this._aaUpdateStateIcon();
    this._aaUpdateMotion();
    this._aaUpdateExtraInfo();
  };
  _._aaUpdateDamagePopUps = function() {
    var b, data;
    if (!this.isABSEntity()) {
      return;
    }
    b = this._character.AABattler();
    if (!b.isDamagePopupRequested()) {
      return;
    }
    data = AADamagePopUpFactory.createDamagePopUpData(b);
    if (data != null) {
      Sprite_AADamagePopUpItem.CreateOnCharacterBinded(this._character, data.settings, data.value);
      AANetworkManager.showDamagePopUpOnCharacter(this._character, data);
    }
    this._aaRefreshExtraInfoOnDamage();
    b.clearDamagePopup();
    b.clearResult();
  };
  // * Если спрайт в зоне навыка, то подсвечивать его
  //?DYNAMIC
  _._aaUpdateSelectionBlend = function() {}; // * DUMMY
  _._aaUpdateSelectionBlendBody = function() {
    if ($gameTemp._aaSkillSelectorTargets == null) {
      return;
    }
    if ($gameTemp._aaSkillSelectorTargets.contains(this._character)) {
      return this._aaSetSelectionBySkill();
    } else {
      return this._aaResetSelectionBySkill();
    }
  };
  _._aaSetSelectionBySkill = function() {
    // * Сохраняем оригинальный цвет
    if (this.__originalBlend == null) {
      this.__originalBlend = this.getBlendColor();
    }
    this.setBlendColor(this._aaSelectBlendColor);
  };
  _._aaResetSelectionBySkill = function() {
    if (this.__originalBlend == null) {
      return;
    }
    this.setBlendColor(this.__originalBlend);
    return this.__originalBlend = null;
  };
  _.gev_onPlayerSkillSelector = function() {
    var arr;
    if (!$gamePlayer.isInSkillTargetingState()) {
      this._aaResetSelectionBySkill();
      // * Больше этот метод не будет работать
      return this._aaUpdateSelectionBlend = function() {};
    } else {
      //TODO: Один раз цвет конвертировать и сохранять в $gameTemp
      this._aaSelectBlendColor = KDCore.Color.FromHex($gamePlayer.activeAASkill().selectorColor);
      arr = [...this._aaSelectBlendColor.ARR];
      arr[3] = 150;
      this._aaSelectBlendColor = arr;
      // * Подключаем метод обновления
      return this._aaUpdateSelectionBlend = this._aaUpdateSelectionBlendBody;
    }
  };
  _.gev_onUnderMouseEventChanged = function() {
    var e;
    try {
      return this._aaRefreshExtraInfoState();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaPrepareMotion = function() {
    if ((this._character != null) && this._character.aaIsSupportMotion()) {
      return this._aaUpdateMotion = this._aaUpdateMotionBody;
    } else {
      return this._aaUpdateMotion = function() {}; // * EMPTY
    }
  };
  
  //?DYNAMIC
  _._aaUpdateMotion = function() {};
  _._aaUpdateMotionBody = function() {
    var motion;
    if (!this.isABSEntity()) {
      return;
    }
    if (this._character.aaIsMotionRequested()) {
      motion = Sprite_Actor.MOTIONS[this._character.aaMotionType];
      if (motion !== this._aaCurrentMotionType) {
        if (this._aaMotionSprite != null) {
          this._aaClearMotion();
        }
        this._aaSetupMotion(motion);
      }
    } else {
      if (this._aaMotionSprite != null) {
        this._aaClearMotion();
      }
    }
    if (this._aaMotionSprite != null) {
      this._aaUpdateMotionAnimation();
    }
  };
  _._aaSetupMotion = function(motion) {
    var e;
    if (motion == null) {
      return;
    }
    if (this._aaCurrentMotionType === motion) {
      return;
    }
    try {
      // * Sprite creation
      this._aaMotionSprite = new Sprite();
      this._aaMotionSprite.x = 0.5;
      this._aaMotionSprite.y = 1;
      this._aaMotionSprite.bitmap = ImageManager.loadSvActor(this._character.AABattler().battlerName());
      this._aaMotionSprite.scale.set(0.8);
      // * По стандарту, спрайт смотрит влево, перевернём его, если  персонаж смотрел вправо
      if (this._character.direction() === 6) {
        this._aaMotionSprite.scale.x *= -1;
        // * Нужно добавить также сдвиг самого спрайта
        this._aaMotionDX = this.patternWidth();
      } else {
        this._aaMotionDX = 0;
      }
      this.parent.addChild(this._aaMotionSprite);
      // * Motion setup
      this._aaCurrentMotionType = motion;
      this._aaMotionCount = 0;
      this._aaMotionPattern = 0;
      this._character.setTransparent(true);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaMotionSprite = null;
      this._character.aaClearMotion();
    }
  };
  _._aaClearMotion = function() {
    this._aaCurrentMotionType = null;
    this._aaMotionSprite.removeFromParent();
    this._aaMotionSprite.visible = false;
    this._aaMotionSprite = null;
    this._character.setTransparent(false);
  };
  _._aaUpdateMotionAnimation = function() {
    var b, ch, cw, cx, cy, motionIndex;
    b = this._aaMotionSprite.bitmap;
    motionIndex = this._aaCurrentMotionType.index;
    cw = b.width / 9;
    ch = b.height / 6;
    cx = Math.floor(motionIndex / 6) * 3 + this._aaMotionPattern;
    cy = motionIndex % 6;
    this._aaMotionSprite.setFrame(cx * cw, cy * ch, cw, ch);
    this._aaMotionSprite.x = this._character.screenX() + this._aaMotionDX - this.patternWidth() / 2;
    this._aaMotionSprite.y = this._character.screenY() - this.patternHeight();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------
//TODO: animation with delay
//@_aaMotionPattern++
//@_aaMotionPattern = 1 if @_aaMotionPattern > 3
//console.log(@_aaMotionPattern)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaUpdateSpriteEffects = function() {
    this._aaUpdateSpriteEffectValues();
    if (this._character.aaIsShakeRequested()) {
      this._aaUpdateSpriteShakeEffect();
    }
    if (this._character.aaIsShatterRequested()) {
      this._aaStartSpriteShatterEffect();
    }
  };
  // * Применение дополнительных значений к базовым
  _._aaUpdateSpriteEffectValues = function() {
    this.x += this._character.aaMotionDX();
  };
  _._aaUpdateSpriteShakeEffect = function() {
    var remainingTime;
    this._character._aaShakeEffectData[0] -= 1;
    remainingTime = this._character._aaShakeEffectData[0];
    this._character._aaShakeEffectData[1] += Math.round(remainingTime * 0.4 * Math.cos(remainingTime));
    if (this._character._aaShakeEffectData[0] <= 0) {
      // * Возвращаем на 0, когда время вышло
      this._character._aaShakeEffectData[1] = 0;
    }
  };
  _._aaStartSpriteShatterEffect = function() {
    $gameMap.aaSpriteset().aaCreateShatterEffect(this);
    this._character.aaOnShatterEffectCreated();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //TODO: Тут стоит условие return unless @isABSEntity(), возможно если сначала событие было
  // * не АБС, а потом станет АБС, то не будет MiniHP Bar видно, проверить и исправить!
  _._aaSetupExtraInfo = function() {
    if (!this.isABSEntity()) {
      return;
    }
    // * Игрок не имеет дополнительной информации
    if (this.isPlayer()) {
      return;
    }
    this._characterAASettings = this._character.AAEntity().model();
    if (this._characterAASettings == null) {
      return;
    }
    // * Дальше код выполняется только для Enemies Events
    this._aaSetupMiniHpGauge();
    if (this.isEnemy()) {
      this._aaSetupVisionDrawCheck();
    }
  };
  _._aaSetupMiniHpGauge = function() {
    var e, params;
    //TODO: PARTY UPD Другой стиль для союзников???
    if (!AA.PP.getMiniHpGaugeSettings().active) {
      return;
    }
    params = AA.PP.uiData("enemyMiniHp", this._characterAASettings.miniHpGaugeStyle);
    this.aaMiniHPGauge = new AA.Sprite_CharacterMiniGauge(params);
    try {
      //console.log @_characterAASettings.miniHPGaugeOffset
      if ((this._characterAASettings.miniHPGaugeOffset != null) && this._characterAASettings.miniHPGaugeOffset instanceof Array) {
        this.aaMiniHPGauge.setExtraMargins(...this._characterAASettings.miniHPGaugeOffset);
      }
      this.aaMiniHPGauge.refreshPosition(0, 0); // * чтобы Margins применились безопасно
    } catch (error) {
      e = error;
      AA.w(e);
      this.aaMiniHPGauge.setExtraMargins(0, 0);
    }
    this.aaMiniHPGauge.setupController(this._character.AABattler(), "hpRate");
    if (AA.PP.getMiniHpGaugeSettings().showOnlyOnHover === true) {
      this._aaMiniHpShowHideOnHover = true;
      this.aaMiniHPGauge.hideInstant();
    }
    if (AA.PP.getMiniHpGaugeSettings().showWhenNotFull === true) {
      this._aaMiniHpShowWhenNotFull = true;
      // * Эти два параметра не совместимы
      this._aaMiniHpShowHideOnHover = false;
      this.aaMiniHPGauge.hideInstant();
      this._aaMiniHpBattlerHpRateThread = new KDCore.TimedUpdate(10, this._aaCheckBattlerHpRate.bind(this));
    }
    return this.addChild(this.aaMiniHPGauge);
  };
  _._aaRefreshExtraInfoState = function() {
    // * Использую как флаг, что у спрайта есть АБС персонаж
    if (this._characterAASettings == null) {
      return;
    }
    if (!this._aaMiniHpShowHideOnHover) {
      return;
    }
    if ($gameTemp._aaEventUnderCursor != null) {
      if ($gameTemp._aaEventUnderCursor === this._character) {
        this.aaMiniHPGauge.showSlow();
      } else {
        this.aaMiniHPGauge.hideSlow();
      }
    } else {
      this.aaMiniHPGauge.hideSlow();
    }
  };
  _._aaRefreshExtraInfoOnDamage = function() {
    if (this.aaMiniHPGauge == null) {
      return;
    }
    this.aaMiniHPGauge.refreshValues();
    // * Если всегда видно, то нет смысла
    if (AA.PP.getMiniHpGaugeSettings().showOnlyOnHover === false) {
      return;
    }
    // * Если контроллируется по не полному ХП, то тоже нет смысла
    if (this._aaMiniHpShowWhenNotFull === true) {
      return;
    }
    // * Только если опция включена
    if (!AA.PP.getMiniHpGaugeSettings().showOnDamage) {
      return;
    }
    this.aaMiniHPGauge.showAndHide();
  };
  _._aaUpdateExtraInfo = function() {
    this._aaUpdateVisionDraw();
    if (!this.isABSEntity()) {
      return;
    }
    if (!this._aaMiniHpShowWhenNotFull) {
      return;
    }
    return this._aaMiniHpBattlerHpRateThread.update();
  };
  _._aaCheckBattlerHpRate = function() {
    var e;
    if ((this._character == null) || (this._character.AABattler() == null)) {
      this.aaMiniHPGauge.hideInstant();
      return;
    }
    try {
      if (this._character.AABattler().hpRate() !== 1) {
        if (!this.aaMiniHPGauge.isVisible()) {
          this.aaMiniHPGauge.showSlow();
        }
      } else {
        if (!this.aaMiniHPGauge.isVisible()) {
          this.aaMiniHPGauge.hideInstant();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //TODO: НЕ РАБОТАЕТ ПО СЕТИ, двигается вместе со своим персонажем
  _._aaSetupStateOverlaySprite = function() {
    this._aaStateOverlaySprite = new Sprite_StateOverlay();
    this._aaStateOverlaySprite.scale.set(0.8);
    this._aaStateOverlaySprite.z = 3;
    this._aaStateOverlaySprite.setup(this._character.AABattler());
    return this.parent.addChild(this._aaStateOverlaySprite);
  };
  _._aaUpdateStateOverlay = function() {
    if (this._aaStateOverlaySprite == null) {
      return;
    }
    return this._aaStateOverlaySprite.move(this.x, this.y + 12);
  };
  _._aaSetupStateIcon = function() {
    var e, x, y;
    try {
      if (this.isEnemy() && !AA.PP.getIsStateIconVisibleAboveEnemy()) {
        return;
      }
      if (this.isPlayer() && !AA.PP.getIsStateIconVisibleAbovePlayer()) {
        return;
      }
      if (this.isAllyParty() && !AA.PP.getIsStateIconVisibleAboveAlly()) {
        return;
      }
      this._aaStateIcon = new Sprite_StateIcon();
      this._aaStateIcon.setup(this._character.AABattler());
      this._aaStateIcon.scale.set(AA.PP.getStateIconScale());
      ({x, y} = AA.PP.getStateIconOffsets());
      this._aaStateIcon.x = x;
      this._aaStateIcon.y = y;
      this.addChild(this._aaStateIcon);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaStateIcon = null;
    }
  };
  _._aaUpdateStateIcon = function() {}; // * EMPTY
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------
//return unless @_aaStateIcon?


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaSetupVisionDrawCheck = function() {
    this._aaIsShouldCheckVisionDraw = true;
  };
  _._aaIsDrawVision = function() {
    return this._aaIsShouldCheckVisionDraw === true && ($gameSystem.aaDrawEnemyVision != null) && this._character.isABS();
  };
  _._aaUpdateVisionDraw = function() {
    var e;
    if (this._aaIsDrawVision()) {
      try {
        if (this._aaVisionSpr == null) {
          this._aaCreateVisionSprite();
        }
        return this._aaRefreshVisionSprite();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return $gameSystem.aaDrawEnemyVision = null;
      }
    } else {
      if (this._aaVisionSpr != null) {
        this._aaDestroyVisionSprite();
        return this._aaIsShouldCheckVisionDraw = false;
      }
    }
  };
  _._aaDestroyVisionSprite = function() {
    var e;
    if (this._aaVisionSpr == null) {
      return;
    }
    try {
      this._aaVisionSpr.visible = false;
      this._aaVisionSpr.removeFromParent();
      return this._aaVisionSpr = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaCreateVisionSprite = function() {
    var e;
    try {
      this._aaIsVisionIsTriangle = this._characterAASettings.isTVision();
      if (this._aaIsVisionIsTriangle === true) {
        this._aaCreateVisionTriangle();
      } else {
        this._aaCreateVisionCircle();
      }
      this._aaVisionSpr.opacity = $gameSystem.aaDrawEnemyVision.opacity;
      this._aaVisionSpr.z = 0;
      return this.parent.addChild(this._aaVisionSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaCreateVisionTriangle = function() {
    var color, th, tw;
    tw = this._characterAASettings.gViewRadius() * $gameMap.tileWidth();
    th = this._characterAASettings.gTVisor() * $gameMap.tileWidth();
    this._aaVisionSpr = KDCore.Sprite.FromBitmap(tw, th * 4);
    color = $gameSystem.aaDrawEnemyVision.color;
    this._aaVisionSpr.b().drawTriangle(tw, th, color);
    this._aaDrawExtraSideVisors(this._characterAASettings.sideVisor);
  };
  _._aaDrawExtraSideVisors = function(size) {
    var b, color, h, mod, th, tw, w;
    if (size <= 0) {
      return;
    }
    if (size > 1) {
      //TODO: more then 1 not supported
      size = 1;
    }
    color = $gameSystem.aaDrawEnemyVision.color;
    tw = $gameMap.tileWidth();
    th = $gameMap.tileHeight();
    h = th * size;
    w = tw;
    b = this._aaVisionSpr.b();
    b.fillRect(0, (b.width / 2) + tw * 1.5, tw, tw * size, color);
    if (size === 1) {
      mod = 0; // * Not supported by AI logic yet
    } else {
      mod = ((size - 1) * tw) * -1;
    }
    b.fillRect(0, ((b.width / 2) + tw * 0.5) + mod, tw, tw * size, color);
  };
  _._aaCreateVisionCircle = function() {
    var bs, color, cr, cx, r;
    r = this._characterAASettings.gViewRadius();
    bs = (r + 4) * $gameMap.tileWidth();
    cx = bs / 2;
    cr = r * $gameMap.tileWidth();
    color = $gameSystem.aaDrawEnemyVision.color;
    this._aaVisionSpr = KDCore.Sprite.FromBitmap(bs, bs);
    this._aaVisionSpr.b().drawCircle(cx, cx, cr, color);
    this._aaVisionSpr.anchor.set(0.5, 0.5);
  };
  _._aaRefreshVisionSprite = function() {
    var e;
    try {
      this._aaVisionSpr.move(this.x, this.y - this.height / 2);
      if (this._aaIsVisionIsTriangle === true) {
        return this._aaRefershVisionTriangle();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaRefershVisionTriangle = function() {
    var dir, e;
    try {
      dir = this._character.direction();
      this._aaVisionSpr.visible = true;
      if (dir === 4) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = -1;
        return this._aaVisionSpr.rotation = 0;
      } else if (dir === 6) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = 1;
        return this._aaVisionSpr.rotation = 0;
      } else if (dir === 8) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = -1;
        return this._aaVisionSpr.rotation = 1.57;
      } else if (dir === 2) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = 1;
        return this._aaVisionSpr.rotation = 1.57;
      } else {
        return this._aaVisionSpr.visible = false;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaSetupWeaponMotionSprite = function() {
    this._aaSprWeapMotionHolder = new Sprite();
    // * Новый класс используется, он внутри себя содержит и старую и новую реализацию
    this._aaSprWeapon = new AA.Sprite_WeaponMotionSelector();
    this._aaSprWeapMotionHolder.addChild(this._aaSprWeapon);
  };
  _._aaUpdateWeaponMotion = function() {
    var b, direction, e;
    if (!this.isABSEntity()) {
      return;
    }
    if (this._aaSprWeapMotionHolder == null) {
      this._aaSetupWeaponMotionSprite();
    }
    this._aaSprWeapMotionHolder.move(this.x, this.y);
    b = this._character.AABattler();
    if (!b.isWeaponAnimationRequested()) {
      return;
    }
    if (this._aaSprWeapon == null) {
      return;
    }
    try {
      this._aaSprWeapon.setup(b.weaponImageId());
      //@_aaSprWeapon.setup("Motion_Sword(3,12)")
      direction = this._character.direction();
      this._aaSprWeapon.aaSetDirection(direction);
      if (direction === 8) { // * UP
        // * Ниже персонажа, так как персонаж спиной к нам
        this.parent.addChildAt(this._aaSprWeapMotionHolder, 1);
      } else {
        // * Выше персонажа
        this.parent.addChild(this._aaSprWeapMotionHolder);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    } finally {
      b.clearWeaponAnimation();
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для показа полоски здоровья над персонажами на карте
// * Имеет свой встроенный контроллер
(function() {
  var Sprite_CharacterMiniGauge;
  //rev 30.06.2021
  Sprite_CharacterMiniGauge = class Sprite_CharacterMiniGauge extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
      // * По умолчанию нету доп. смещения
      // * (у каждого события может быть своё, это см. в Model)
      this.setExtraMargins(0, 0);
      return;
    }

    setupController(battler, rateGetter) {
      this.battler = battler;
      this.rateGetter = rateGetter;
      // * Если изначально в параметрах visible == false, то ничего
      if (!this.isActive()) {
        return;
      }
      this.visible = this.battler != null;
      this.controllerThread = new KDCore.TimedUpdate(10, this.refreshValues.bind(this));
    }

    defaultParams() {
      return AA.PP._getDefaultVisualFor_enemyMiniHp();
    }

    setExtraMargins(dx, dy) {
      this.dx = dx;
      this.dy = dy;
    }

    refreshPosition(x, y) {
      // * Настройки сперва (смещение)
      this._resetPosition();
      // * Затем координаты на экране
      this.x += x;
      this.y += y;
      // * Теперь дополнительные настройки
      this.x += this.dx;
      this.y += this.dy;
    }

    showInstant() {
      this.visible = true;
      return this.opacity = 255;
    }

    isVisible() {
      return this.visible === true;
    }

    showSlow() {
      if (this.visible === true && this.opacity >= 255) {
        return;
      }
      this.refreshValues();
      this.visible = true;
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(0).to(255).step(35).start();
      this.showHideThread = null;
    }

    hideInstant() {
      return this.visible = false;
    }

    hideSlow() {
      if (this.visible === false) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      if (this.opacity <= 0) {
        return;
      }
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(this.opacity).to(0).step(45).start().done(() => {
        return this.visible = false;
      });
    }

    showAndHide() {
      if (this.visible === true) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      this.showSlow();
      this.showHideThread = new KDCore.TimedUpdate(60, this._hideAfterTime.bind(this));
      this._updateShowHide = this._updateShowHideBody;
    }

    drawGauge(percent) {
      return this.gauge.draw(percent);
    }

    drawText(text) {
      return this.text.draw(text);
    }

    //TODO: Динамическую смену
    refreshValues() {
      var newRate;
      if (this.__prevRate == null) {
        this.__prevRate = this.battler[this.rateGetter]();
        this.drawGauge(this.__prevRate);
      } else {
        newRate = this.battler[this.rateGetter]();
        //TODO: animated?
        //if newRate < @__prevRate
        //    diff = @__prevRate - newRate
        if (newRate !== this.__prevRate) {
          this.__prevRate = newRate;
          this.drawGauge(newRate);
        }
      }
    }

    update() {
      var ref;
      super.update();
      this._updateController();
      this._updateShowHide();
      if ((ref = this.changer) != null) {
        ref.update();
      }
    }

  };
  AA.link(Sprite_CharacterMiniGauge);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_CharacterMiniGauge.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_CharacterMiniGauge.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createGauge();
    this._createText();
    this._createLabel();
    return this.move(this.params.position);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    return this.add(this.gauge);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._createLabel = function() {
    var label;
    if (String.isNullOrEmpty(this.params.label)) {
      return;
    }
    label = new KDCore.UI.Sprite_UIImage();
    label.draw(this.params.label);
    label.move(this.params.labelMargins);
    return this.add(label);
  };
  _._updateController = function() {
    if (!this.isActive()) {
      return;
    }
    if (this.battler == null) {
      return;
    }
    return this.controllerThread.update();
  };
  _._hideAfterTime = function() {
    this.showHideThread = null;
    return this.hideSlow();
  };
  //?DYNAMIC
  _._updateShowHide = function() {}; // * EMPTY
  _._updateShowHideBody = function() {
    var ref;
    return (ref = this.showHideThread) != null ? ref.update() : void 0;
  };
})();

// ■ END Sprite_CharacterMiniGauge.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для отображения информации о враге на экране (портрет, здоровье и т.д.)
(function() {
  var Sprite_EnemyInfo;
  Sprite_EnemyInfo = class Sprite_EnemyInfo extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    defaultParams() {
      return AA.PP._getDefaultVisualFor_enemyInfo();
    }

    //TODO: Уже есть в двух классах, может вынести на UIElement ???
    //(Sprite_CharacterMiniGauge)
    showSlow() {
      if (this.visible === true && this.opacity >= 255) {
        return;
      }
      this.visible = true;
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(0).to(255).step(35).start();
    }

    hideSlow() {
      if (this.visible === false) {
        return;
      }
      if (this.opacity <= 0) {
        return;
      }
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(this.opacity).to(0).step(45).start().done(() => {
        return this.visible = false;
      });
    }

    drawStates(iconsArray) {
      var e, i, iconIndex, index, len, results, stateIcon, statesIcons;
      try {
        if (iconsArray == null) {
          iconsArray = [];
        }
        if (this.stateIconsGroup == null) {
          return;
        }
        statesIcons = this.stateIconsGroup.children;
        results = [];
        for (index = i = 0, len = statesIcons.length; i < len; index = ++i) {
          stateIcon = statesIcons[index];
          iconIndex = iconsArray[index];
          if (iconIndex == null) {
            results.push(stateIcon.draw(0));
          } else {
            results.push(stateIcon.draw(iconIndex));
          }
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    // * Value: level
    drawLevelWithFormat(value) {
      var e, ref, ref1;
      try {
        if (this.params.levelFormat == null) {
          return (ref = this.levelText) != null ? ref.draw(value) : void 0;
        } else {
          return (ref1 = this.levelText) != null ? ref1.draw(this.params.levelFormat.replace("%1", value)) : void 0;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Values: current, max, rate
    drawHpWithFormat(value1, value2, value3) {
      var e, text;
      if (this.hpText == null) {
        return;
      }
      try {
        if (this.params.hpTextFormat == null) {
          this.params.hpTextFormat = "%1";
        }
        text = this.params.hpTextFormat.replace("%1", value1);
        if (value2 != null) {
          text = text.replace("%2", value2);
        }
        if (value3 != null) {
          text = text.replace("%3", value3);
        }
        return this.hpText.draw(text);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Value: name
    drawNameWithFormat(value) {
      var e, ref, ref1;
      try {
        if (this.params.levelFormat == null) {
          return (ref = this.nameText) != null ? ref.draw(value) : void 0;
        } else {
          return (ref1 = this.nameText) != null ? ref1.draw(this.params.nameFormat.replace("%1", value)) : void 0;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    drawFace(faceName, faceIndex) {
      var ref;
      return (ref = this.face) != null ? ref.draw(...arguments) : void 0;
    }

    //TODO: Отрисовка пользовательских картинок цели
    drawCustomImages() {}

    // * удаляются и отрисовываются заного
    update() {
      var ref;
      super.update();
      return (ref = this.changer) != null ? ref.update() : void 0;
    }

  };
  AA.link(Sprite_EnemyInfo);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_EnemyInfo.prototype;
  //$[OVER]
  _._createContent = function() {
    if (!this.isActive()) {
      return;
    }
    this._createBase();
    this._createGauge();
    this._createHpText();
    this._createFaceImage();
    this._createNameText();
    this._createLevelText();
    this._createBattleState();
    this._createStatesIcons();
    // * Слой для статусов и бафов
    this._statesLayer = new Sprite();
    this.addChild(this._statesLayer);
    // * Для пользовательских картинок из параметров конкретного монстра
    this._customImagesLayer = new Sprite();
    this.addChild(this._customImagesLayer);
    this._createForegroundImage();
    return this.move(this.params.position);
  };
  _._createBase = function() {
    this.base = new KDCore.UI.Sprite_UIImage(this.params);
    this.add(this.base);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    this.gauge.move(this.params.gaugeMargins);
    return this.add(this.gauge);
  };
  _._createHpText = function() {
    this.hpText = new KDCore.UI.Sprite_UIText(this.params.hpText);
    return this.add(this.hpText);
  };
  _._createFaceImage = function() {
    this.face = new KDCore.UI.Sprite_UIFace(this.params.face);
    this.face.move(this.params.face.margins);
    return this.add(this.face);
  };
  _._createNameText = function() {
    var e;
    try {
      this.nameText = new KDCore.UI.Sprite_UIText(this.params.nameText);
      return this.add(this.nameText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createLevelText = function() {
    var e;
    try {
      this.levelText = new KDCore.UI.Sprite_UIText(this.params.levelText);
      return this.add(this.levelText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createBattleState = function() {
    this.battleState = new KDCore.UI.Sprite_UIImage(this.params.battleState);
    this.battleState.move(this.params.battleState.margins);
    return this.add(this.battleState);
  };
  _._createStatesIcons = function() {
    var e, i, len, p, ref, stateIcon;
    this.stateIconsGroup = new Sprite();
    ref = AA.PP.getUIEnemyStatesIconsSet();
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      try {
        stateIcon = this._createStateIcon(p.x, p.y);
        this.stateIconsGroup.addChild(stateIcon);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
    this.add(this.stateIconsGroup);
  };
  _._createStateIcon = function(x, y) {
    var icon, p;
    p = {
      visible: true,
      index: 0,
      size: 32
    };
    icon = new KDCore.UI.Sprite_UIIcon(p);
    icon.move(x, y);
    icon.scale.set(AA.PP.getUIEnemyStateIconOnUIScale());
    return icon;
  };
  // * Для пользователя, по умолчанию не используется
  _._createForegroundImage = function() {
    var foregroundImage;
    foregroundImage = new KDCore.UI.Sprite_UIImage(this.params.foregroundImage);
    foregroundImage.move(this.params.foregroundImage.margins);
    return this.add(foregroundImage);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var Sprite_SkillImpactSelector;
  Sprite_SkillImpactSelector = class Sprite_SkillImpactSelector extends KDCore.Sprite {
    constructor() {
      super();
      this.anchor.set(0.5);
      this.visible = false;
      this._createSelector();
      return;
    }

    activate(aaSkill1) {
      this.aaSkill = aaSkill1;
      this.visible = true;
      return this._applyStyle(this.aaSkill);
    }

    deactivate() {
      this.aaSkill = null;
      this.visible = false;
    }

    shake() {
      return this.shakeTime = 20;
    }

    update() {
      super.update();
      if (!this.visible) {
        return;
      }
      this.move(TouchInput);
      if (this.shakeTime >= 0) {
        this._updateShake();
      }
    }

  };
  AA.link(Sprite_SkillImpactSelector);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SkillImpactSelector.prototype;
  // * Используем доп. слой, чтобы воссоздать Shake эффект
  _._createSelector = function() {
    this._selectorSpr = new KDCore.Sprite();
    this._selectorSpr.anchor.set(0.5);
    this.addChild(this._selectorSpr);
  };
  // * Отрисовка зонвы выбора в зависимости от параметров навыка
  _._applyStyle = function(aaSkill) {
    var radius, selectorColor, selectorImg, selectorOpacity;
    ({selectorColor, selectorImg, selectorOpacity} = aaSkill);
    radius = aaSkill.gRadius();
    if (String.any(selectorImg)) {
      KDCore.Utils.loadImageAsync("pictures", selectorImg).then(this._applyImage.bind(this));
    } else {
      this._applyRadius(radius);
      this._applyColor(selectorColor);
    }
    this.opacity = selectorOpacity;
  };
  // * Если не задан параметр картинки, то1 будет просто квадрат
  // * Картинка не растягивается в зависимости от Radius
  // * Предполагается что разработчик сам установит соответствующую картинку
  _._applyImage = function(bitmap) {
    return this._selectorSpr.bitmap = bitmap;
  };
  _._applyRadius = function(radius) {
    if (radius <= 0) {
      this._selectorSpr.bitmap = new Bitmap(0, 0);
    } else {
      this._selectorSpr.bitmap = new Bitmap(radius * $gameMap.tileWidth(), radius * $gameMap.tileHeight());
    }
  };
  _._applyColor = function(selectorColor) {
    return this._selectorSpr.bitmap.fillAll(selectorColor.toCss());
  };
  return _._updateShake = function() {
    this.shakeTime--;
    // * Только по X
    this._selectorSpr.x += Math.round(this.shakeTime * 0.2 * Math.cos(this.shakeTime));
    if (this.shakeTime <= 0) {
      this.shakeTime = 0;
      this._selectorSpr.x = 0;
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс ячейки быстрого доступа для АБС навыка (предмета)
//rev 07.07.21
(function() {
  var Sprite_SKillPanelItem;
  Sprite_SKillPanelItem = class Sprite_SKillPanelItem extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    // * Позиция не определяется, так как каждый элемент имеет свою позицию
    defaultParams() {
      return AA.PP._getDefaultVisualFor_skillSlot();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    //$[OVER]
    isUnderMouse() {
      return this.icon.isUnderMouse() && this.isFullVisible();
    }

    pulseClick() {
      return this.notifyOutline.pulse(this._clickedColor, this.params.outlinePulseSpeed);
    }

    pulseReady() {
      return this.notifyOutline.pulse(this._readyColor, this.params.outlinePulseSpeed);
    }

    pulseAlert() {
      return this.notifyOutline.pulse(this._badColor, this.params.outlinePulseSpeed);
    }

    hideOutline() {
      return this.notifyOutline.hide();
    }

    select() {
      return this.selectionOutline.show(this._selectionColor);
    }

    deselect() {
      return this.selectionOutline.hide();
    }

    clear() {
      this.enable();
      this.drawIcon(0);
      this.drawCount("");
      return this.drawTime("");
    }

    //@disable() #??? or @enable()
    //TODO: hide if option
    drawIcon() {
      return this.icon.draw(...arguments);
    }

    drawSymbol() {
      return this.text.draw(...arguments);
    }

    drawCount(a) {
      return this.countText.draw(...arguments);
    }

    drawTime() {
      return this.timeText.draw(...arguments);
    }

    disable() {
      this.button.disable();
      this.state.visible = true;
    }

    enable() {
      this.button.enable();
      this.state.visible = false;
    }

    switchState(isEnabled) {
      if (isEnabled === true) {
        if (this.isDisabled()) {
          this.enable();
          return true; // * Вновь доступна
        }
      } else {
        if (!this.isDisabled()) {
          this.disable();
        }
      }
      return false;
    }

    isDisabled() {
      return this.state.visible === true;
    }

  };
  AA.link(Sprite_SKillPanelItem);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SKillPanelItem.prototype;
  _._createContent = function() {
    this._initColors();
    this._createOutline();
    this._createMain();
    this._createIcon();
    //@_createImage() #TODO: if item have image instead icon
    // * Disabled darker hover image
    this._createState();
    this._createInfo();
  };
  _._initColors = function() {
    this._tryConvertColor("_selectionColor", "selectedOutlineColor");
    this._tryConvertColor("_clickedColor", "clickedOutlineColor");
    this._tryConvertColor("_readyColor", "readyOutlineColor");
    this._tryConvertColor("_badColor", "badOutlineColor");
  };
  _._tryConvertColor = function(colorFieldName, paramName) {
    var e;
    try {
      this[colorFieldName] = KDCore.Color.FromHex(this.params[paramName]).ARR;
    } catch (error) {
      e = error;
      AA.w(e);
      this[colorFieldName] = [0, 0, 0, 1];
    }
  };
  _._createOutline = function() {
    this.notifyOutline = new AA.Sprite_SkillPanelOutline();
    this.notifyOutline.move(this.params.outlineMargins);
    this.add(this.notifyOutline);
    this.selectionOutline = new AA.Sprite_SkillPanelOutline();
    this.selectionOutline.move(this.params.outlineMargins);
    this.add(this.selectionOutline);
  };
  _._createMain = function() {
    this.button = new KDCore.ButtonM("SkillSlot", false, "Alpha");
    this.button.addClickHandler(() => {
      if (this.isFullVisible()) {
        return $gamePlayer.aaTryPerformSkill(this.skillId);
      }
    });
    return this.add(this.button);
  };
  _._createIcon = function() {
    this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
    this.icon.move(this.params.iconMargins);
    this.add(this.icon);
  };
  /*
  size = @params.icon.size
  if size > 32
      icon_x = @icon
      @button.isUnderMouse = -> icon_x.isUnderMouse()
  */
  _._createState = function() {
    this.state = new KDCore.UI.Sprite_UIImage();
    this.state.draw("SkillSlot_Disabled");
    this.state.visible = false;
    return this.add(this.state);
  };
  _._createInfo = function() {
    this._createTimer();
    this._createCountText();
    return this._createSymbolText();
  };
  _._createTimer = function() {
    this.timeText = new KDCore.UI.Sprite_UIText(this.params.timeText);
    return this.add(this.timeText);
  };
  _._createCountText = function() {
    this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
    return this.add(this.countText);
  };
  _._createSymbolText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.symbolText);
    return this.add(this.text);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс подсветки (вокруг) ячейки быстрого доступа
//rev 07.07.21
(function() {
  var Sprite_SkillPanelOutline;
  Sprite_SkillPanelOutline = class Sprite_SkillPanelOutline extends KDCore.UI.Sprite_UIImage {
    constructor() {
      super(...arguments);
      this.visible = false;
    }

    defaultParams() {
      return {
        visible: true,
        image: "SkillSlot_Outline"
      };
    }

    show(colorArr) {
      this.visible = true;
      if (this._changer != null) {
        this._changer = null;
      }
      this.setBlendColor(colorArr);
      this.opacity = 255;
    }

    hide() {
      if (this._changer != null) {
        this._changer = null;
      }
      return this.visible = false;
    }

    pulse(colorArr, speed) {
      this.show(colorArr);
      this.opacity = 0;
      this._changer = new KDCore.Changer(this);
      this._changer.change('opacity').from(0).to(255).step(speed).repeat(2).reverse();
      this._changer.start().done(() => {
        return this.hide();
      });
    }

    update() {
      var ref;
      super.update();
      return (ref = this._changer) != null ? ref.update() : void 0;
    }

  };
  AA.link(Sprite_SkillPanelOutline);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SkillPanelOutline.prototype;
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс заглушка для подсветки (вокруг) ячейки быстрого доступа
// * Используется если отключён параметр плагина
// * Все методы данного класса ПУСТЫЕ
(function() {
  var Sprite_SkillPanelOutlineDummy;
  Sprite_SkillPanelOutlineDummy = class Sprite_SkillPanelOutlineDummy extends Sprite {
    constructor() {
      super();
    }

    defaultParams() {
      return {};
    }

    show(colorArr) {}

    hide() {}

    pulse(colorArr, speed) {}

  };
  AA.link(Sprite_SkillPanelOutlineDummy);
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_StateOverlay.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateFrame, ALIAS__updatePattern, _;
  //@[DEFINES]
  _ = Sprite_StateOverlay.prototype;
  //@[ALIAS]
  ALIAS__updatePattern = _.updatePattern;
  _.updatePattern = function() {
    if (this._battler != null) {
      this._overlayExtraImage = this._battler.aaGetExtraOverlayImage();
      if (String.any(this._overlayExtraImage)) {
        if (this.__lastOverlayBitmapName !== this._overlayExtraImage) {
          this._aaLoadExtraBitmap();
          this.__lastOverlayBitmapName = this._overlayExtraImage;
        }
      } else {
        this._aaResetExtraBitmap();
      }
    } else {
      if (String.any(this.__lastOverlayBitmapName) || String.any(this._overlayExtraImage)) {
        this._aaResetExtraBitmap();
      }
    }
    ALIAS__updatePattern.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__updateFrame = _.updateFrame;
  _.updateFrame = function() {
    if (String.any(this._overlayExtraImage)) {
      return this._aaUpdateExtraOverlayFrame();
    } else {
      return ALIAS__updateFrame.call(this, ...arguments);
    }
  };
})();

// ■ END Sprite_StateOverlay.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_StateOverlay.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_StateOverlay.prototype;
  _._aaLoadExtraBitmap = function() {
    this.bitmap = ImageManager.loadPicture(this._overlayExtraImage);
    return this._aaUpdateExtraOverlayFrame();
  };
  _._aaResetExtraBitmap = function() {
    this._overlayExtraImage = null;
    this.__lastOverlayBitmapName = null;
    return this.loadBitmap();
  };
  _._aaUpdateExtraOverlayFrame = function() {
    var e, h, sx, sy, w;
    try {
      w = 96;
      h = 96;
      sx = this._pattern * w;
      sy = 0;
      return this.setFrame(sx, sy, w, h);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_StateOverlay.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__update, _;
  //@[DEFINES]
  _ = Sprite_Weapon.prototype;
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    var ref;
    ALIAS__update.call(this);
    if ((ref = this._aaOpChanger) != null) {
      ref.update();
    }
  };
  //$[OVER]
  //TODO: setting for user
  _.animationWait = function() {
    return 6;
  };
})();

// ■ END Sprite_Weapon.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Weapon.prototype;
  // * Настройки анимации оружия для ABS карты
  //TODO: settings to user for each type (scale, dx, dy)
  _.aaSetDirection = function(direction) {
    this._aaApplyScaleAndDir(direction);
    // * Начало в прозрачности (небольшой эффект)
    this._aaPlayOpChanger();
  };
  _._aaApplyScaleAndDir = function(direction) {
    this.scale.x = 0.7;
    this.scale.y = this.scale.x;
    this.x = this.y = 0;
    switch (direction) {
      case 6:
        this.x = 12;
        this.scale.x *= -1;
        break;
      case 4:
        this.x = -12;
        break;
      case 2:
        this.y = 0;
        break;
      default:
        this.y = -10;
    }
  };
  _._aaPlayOpChanger = function() {
    //TODO: тоже опция
    this._aaOpChanger = new KDCore.Changer(this);
    this._aaOpChanger.change('opacity').from(60).to(255).step(20).speed(1);
    this._aaOpChanger.start().done(() => {
      return this._aaOpChanger = null;
    });
  };
})();

// ■ END Sprite_Weapon.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс ячейки для расширения навыка оружия (аммуниция)
(function() {
  var Sprite_WeaponExtensionSlot;
  Sprite_WeaponExtensionSlot = class Sprite_WeaponExtensionSlot extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
      this.reset("position");
      this.refreshActiveExtItem();
      this.tag = "skillExtensionIcon";
      return;
    }

    defaultParams() {
      return $aabsz_WeaponSkillExtensionSlot;
    }

    static Instance() {
      var e;
      try {
        if (AA.UI.isValid()) {
          return AA.UI.uiSet.sActorSkillExtIcon;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    //$[OVER]
    isActive() {
      if (this.params.isVisibleOnlyWhenWeaponHaveExtensionsSupport) {
        if (this.isDisabled()) {
          return false;
        }
      } else {
        return true;
      }
    }

    refresh() {
      return this.refreshActiveExtItem();
    }

    actor() {
      return $gameParty.leader();
    }

    isEnabled() {
      return this._mainButton.isEnabled();
    }

    isDisabled() {
      return this._mainButton.isDisabled();
    }

    disable() {
      if (this.isDisabled()) {
        return;
      }
      return this._mainButton.disable();
    }

    enable() {
      if (this.isEnabled()) {
        return;
      }
      this.visible = true;
      return this._mainButton.enable();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    isMenuIsOpened() {
      return this._isMenuIsOpen === true;
    }

    isValidActiveWeaponExtension() {
      var ref;
      return (this.actor() != null) && ((ref = this.getActiveWeaponExtensionDefinition()) != null ? ref.isValidDefinition() : void 0);
    }

    getActiveWeaponExtensionDefinition() {
      var ref;
      return (ref = this.actor()) != null ? ref.aaGetActiveWeaponExtensionDefinition() : void 0;
    }

    getActiveSkillExtensionItemId() {
      return this.actor().aaGetActiveSkillExtensionItemId();
    }

    refreshActiveExtItem() {
      var def, e, extItemId, item, j, len, ref;
      try {
        if (this.isValidActiveWeaponExtension()) {
          def = this.actor().aaGetActiveWeaponExtensionDefinition();
          this.enable();
          extItemId = this.getActiveSkillExtensionItemId();
          if ((extItemId != null) && extItemId > 0) {
            this.setActiveItem($dataItems[extItemId], def);
          } else {
            this.setActiveItem(0);
          }
        } else {
          this.disable();
          this.setActiveItem(0);
          if (this.params.isVisibleOnlyWhenWeaponHaveExtensionsSupport) {
            this.visible = false;
          }
        }
        if (this.isMenuIsOpened()) {
          ref = this.getAllMenuElements();
          for (j = 0, len = ref.length; j < len; j++) {
            item = ref[j];
            item.refreshItem();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.disable();
        this.setActiveItem(0);
      }
    }

    getAllMenuElements() {
      if (this._extItemsMenu != null) {
        return this._extItemsMenu.children.filter(function(i) {
          return (i != null) && (i.refreshItem != null);
        });
      } else {
        return [];
      }
    }

    closeMenu() {
      var e;
      if (!this.isMenuIsOpened()) {
        return;
      }
      try {
        this._isMenuIsOpen = false;
        this.selectionOutline.hide();
        this._destroyExtItemsMenu();
        return this.refreshActiveExtItem();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    openMenu() {
      var e;
      if (this.isMenuIsOpened()) {
        return;
      }
      try {
        this._isMenuIsOpen = true;
        this.selectionOutline.show(this._pressedColor);
        this._createExtItemsMenu();
        return this.refreshActiveExtItem();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setActiveItem(item, definition) {
      var count, e;
      try {
        if (item == null) {
          return this._clearActiveItem();
        } else {
          this._drawActiveExtItemIcon(item.iconIndex);
          if ((definition != null) && definition.isConsumeExtensionItem()) {
            count = $gameParty.numItems(item);
            return this.countText.draw(count);
          } else {
            return this.countText.draw("");
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      super.update();
      return this._refreshThread.update();
    }

    _prepare() {
      super._prepare();
      this._isMenuIsOpen = false;
      this._initColors();
      this._refreshThread = new KDCore.TimedUpdate(30, this.refreshActiveExtItem.bind(this));
    }

  };
  AA.link(Sprite_WeaponExtensionSlot);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_WeaponExtensionSlot.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_WeaponExtensionSlot.prototype;
  _._initColors = function() {
    return AA.Sprite_SKillPanelItem.prototype._tryConvertColor.call(this, "_pressedColor", "pressedOutlineColor");
  };
  _._createContent = function() {
    var e;
    try {
      this._createActiveItemButton();
      this._createActiveItemIcon();
      this._createActiveItemCountText();
      return this._createSelectionOutline();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemButton = function() {
    var e;
    try {
      this._mainButton = new KDCore.ButtonMU(this.params.buttonImages, true, "Alpha");
      this._mainButton.addClickHandler(this._onMainButtonClick.bind(this));
      return this.add(this._mainButton);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._onMainButtonClick = function() {
    var e;
    try {
      if (this.isMenuIsOpened()) {
        return this.closeMenu();
      } else {
        return this.openMenu();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemIcon = function() {
    var e;
    try {
      this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
      this._mainButton.addChild(this.icon);
      return this.icon.move(this.params.icon.marings);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemCountText = function() {
    var e;
    try {
      this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
      return this._mainButton.addChild(this.countText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createSelectionOutline = function() {
    this.selectionOutline = new AA.Sprite_SkillPanelOutline();
    this.selectionOutline.move(this.params.outlineMargins);
    this.add(this.selectionOutline);
  };
  _._clearActiveItem = function() {
    var e;
    try {
      this.icon.draw(0);
      return this.countText.draw("");
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._drawActiveExtItemIcon = function(iconIndex) {
    var e;
    try {
      return this.icon.draw(iconIndex);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._destroyExtItemsMenu = function() {
    var e, element, j, len, ref;
    try {
      if (this._extItemsMenu == null) {
        return;
      }
      ref = this.getAllMenuElements();
      for (j = 0, len = ref.length; j < len; j++) {
        element = ref[j];
        element.visible = false;
        element.destroyMenuItem();
      }
      this._extItemsMenu.removeFromParent();
      this._extItemsMenu.visible = false;
      return this._extItemsMenu = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createExtItemsMenu = function() {
    var activeItemId, def, e, index, itemId, itemsCandidates, j, len;
    try {
      activeItemId = this.getActiveSkillExtensionItemId();
      this._extItemsMenu = new Sprite();
      this._extItemsMenu.move(this.params.menuItem.xMarginFromParent, this.params.menuItem.yMarginFromParent);
      this._createMenuItemFor(null, 0); // * Nothing
      def = this.getActiveWeaponExtensionDefinition();
      if (def == null) {
        return;
      }
      itemsCandidates = def.extensions;
      index = 1;
      for (j = 0, len = itemsCandidates.length; j < len; j++) {
        itemId = itemsCandidates[j];
        if ($gameParty.numItems($dataItems[itemId]) > 0) {
          // * Not show active item in Menu
          if (itemId !== activeItemId) {
            this._createMenuItemFor($dataItems[itemId], index, def.isConsumeExtensionItem());
            index++;
          }
        }
      }
      return this.add(this._extItemsMenu);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createMenuItemFor = function(item, index, isConsumed) {
    var e;
    try {
      item = new AA.Sprite_WeaponExtensionSlotMenuItem(item, index, this.closeMenu.bind(this), isConsumed);
      return this._extItemsMenu.addChild(item);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_WeaponExtensionSlot.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var Sprite_WeaponExtensionSlotMenuItem;
  Sprite_WeaponExtensionSlotMenuItem = class Sprite_WeaponExtensionSlotMenuItem extends KDCore.Sprite {
    constructor(item, index, onClickHandler, isCounted = true) {
      super();
      this.item = item;
      this.index = index;
      this.onClickHandler = onClickHandler;
      this.isCounted = isCounted;
      this.params = this.defaultParams();
      this._create();
      this.refreshItem();
      this.show();
      return;
    }

    defaultParams() {
      return $aabsz_WeaponSkillExtensionSlot.menuItem;
    }

    isEditorMode() {
      return SceneManager._scene instanceof AA.Scene_UIEditor;
    }

    destroyMenuItem() {
      var e;
      try {
        if ($gameTemp.kdButtonUnderMouse === this._mainButton) {
          $gameTemp.kdButtonUnderMouse = null;
        }
        this._mainButton.visible = false;
        return this._mainButton._updateMain();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    show() {
      var destX, destY, e;
      try {
        destX = this.params.xMarginFromParent * this.index;
        destY = this.params.yMarginFromParent * this.index;
        if (!this.params.isAnimated || this.index === 0) {
          this.move(destX, destY);
        } else {
          this.moveWithAnimation(destX, destY, this.params.animationDurationInFrames);
        }
        this.appear(this.params.fadeInSpeedOf255PerFrame);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.move(0, 0);
      }
    }

    refreshItem() {
      var e, numItems, ref, ref1, ref2, ref3;
      try {
        if (this.item == null) {
          return this._drawEmptyItem();
        } else {
          if ((ref = this.icon) != null) {
            ref.draw(this.item.iconIndex);
          }
          if ((ref1 = this.nameText) != null) {
            ref1.draw(this.item.name);
          }
          numItems = $gameParty.numItems(this.item);
          if (this.isCounted) {
            return (ref2 = this.countText) != null ? ref2.draw(numItems) : void 0;
          } else {
            return (ref3 = this.countText) != null ? ref3.draw("") : void 0;
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawEmptyItem() {
      var e, ref, ref1, ref2;
      try {
        if ((ref = this.icon) != null) {
          ref.draw(this.params.nothingItemIconIndex);
        }
        if ((ref1 = this.countText) != null) {
          ref1.draw("");
        }
        return (ref2 = this.nameText) != null ? ref2.draw(this.params.emptyItemText) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      this._createMainButton();
      this._createIcon();
      this._createNameText();
      if (this.item != null) {
        return this._createCountText();
      }
    }

    _createMainButton() {
      this._mainButton = new KDCore.ButtonMU(this.params.buttonImages, true, "Alpha");
      this._mainButton.addClickHandler(this._onMainButtonClick.bind(this));
      return this.add(this._mainButton);
    }

    _onMainButtonClick() {
      var e, itemId, ref;
      try {
        if (this.isEditorMode()) {
          return;
        }
        itemId = 0;
        if (this.item != null) {
          itemId = this.item.id;
        }
        if ((ref = $gameParty.leader()) != null) {
          ref.aaSetActiveSkillExtensionItemId(itemId);
        }
        return setTimeout((() => {
          if (this.onClickHandler != null) {
            return this.onClickHandler();
          }
        }), 50);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createIcon() {
      var e;
      try {
        this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
        this._mainButton.addChild(this.icon);
        return this.icon.move(this.params.icon.marings);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createCountText() {
      var e;
      try {
        this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
        return this._mainButton.addChild(this.countText);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createNameText() {
      var e;
      try {
        this.nameText = new KDCore.UI.Sprite_UIText(this.params.nameText);
        return this._mainButton.addChild(this.nameText);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  AA.link(Sprite_WeaponExtensionSlotMenuItem);
})();


// Generated by CoffeeScript 2.6.1
// * Новый класс для воспроизведения анимации взмаха оружием, показывает
// * оригинальный Sprite_Weapon или новый Sprite_WeaponMotion в зависимости от типа
(function() {
  var Sprite_WeaponMotionSelector;
  Sprite_WeaponMotionSelector = class Sprite_WeaponMotionSelector extends Sprite {
    constructor() {
      super();
      this._lastMotionSpr = null; // * ссылка на класс, который будет использован
      this._originalSprWeapon = new Sprite_Weapon();
      this.addChild(this._originalSprWeapon);
      this._newSprWeapon = new AA.Sprite_WeaponMotion();
      this.addChild(this._newSprWeapon);
      return;
    }

    setup(motionNameOrWeaponId) {
      // * скрыть предыдущие
      this._newSprWeapon.setup(null);
      this._originalSprWeapon.setup(0);
      // * задать новый класс
      if (!KDCore.SDK.isString(motionNameOrWeaponId)) {
        this._lastMotionSpr = this._originalSprWeapon;
      } else {
        this._lastMotionSpr = this._newSprWeapon;
      }
      this._lastMotionSpr.setup(motionNameOrWeaponId);
    }

    aaSetDirection(d) {
      if (this._lastMotionSpr == null) {
        return;
      }
      this._lastMotionSpr.aaSetDirection(d);
    }

  };
  AA.link(Sprite_WeaponMotionSelector);
})();

(function() {
  var Sprite_WeaponMotion;
  //TODO: Tut ostanovilsia, sm class Sprite_Weapon и менять методы чтобы со своим работать

    // * Новый класс для отдельных файлов анимации оружия
  Sprite_WeaponMotion = class Sprite_WeaponMotion extends Sprite {
    constructor() {
      super();
      this.initMembers();
    }

    initMembers() {
      this._animationWaitTime = 12;
      this._weaponImage = null;
      this._animationCount = 0;
      this._pattern = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 1;
    }

    update() {
      super.update();
      if (!this.isValid()) {
        return;
      }
      this._animationCount++;
      if (this._animationCount >= this.animationWait()) {
        this.updatePattern();
        this.updateFrame();
        this._animationCount = 0;
      }
    }

    isValid() {
      return this._bitmapLoaded === true && this._direction !== -1;
    }

    // * Главный метод
    //%[PREPARE]
    setup(_weaponImage) {
      this._weaponImage = _weaponImage;
      this._animationCount = 0;
      this._bitmapLoaded = false;
      this._direction = -1;
      this._pattern = 0;
      this.loadBitmap();
      this.updateFrame();
    }

    //%[START]
    // * Данный метод запускает саму анимацию
    aaSetDirection(d) {
      switch (d) {
        case 8:
          this._direction = 3;
          break;
        case 2:
          this._direction = 0;
          break;
        case 4:
          this._direction = 1;
          break;
        case 6:
          this._direction = 2;
      }
      this.updateFrame();
    }

    animationWait() {
      return this._animationWaitTime || 12;
    }

    isPlaying() {
      return this._weaponImage != null;
    }

    loadBitmap() {
      var frameData;
      if (String.any(this._weaponImage)) {
        frameData = AA.Utils.getFramesAndSpeed(this._weaponImage);
        this._maxPatternFrames = frameData.f;
        this._animationWaitTime = frameData.s;
        this.bitmap = ImageManager.loadAAWeaponMotion(this._weaponImage);
        this.bitmap.addLoadListener(() => {
          this._wFrameWidth = this.bitmap.width / this._maxPatternFrames;
          this._wFrameHeight = this.bitmap.height / 4;
          return this._bitmapLoaded = true;
        });
      } else {
        this.bitmap = ImageManager.loadSystem("");
      }
    }

    updatePattern() {
      this._pattern++;
      if (this._pattern >= this._maxPatternFrames) {
        this._weaponImage = null;
        this._direction = -1;
      }
    }

    updateFrame() {
      var h, sx, sy, w;
      if (this.isValid()) {
        w = this._wFrameWidth;
        h = this._wFrameHeight;
        sx = this._wFrameWidth * this._pattern;
        sy = h * this._direction;
        return this.setFrame(sx, sy, w, h);
      } else {
        return this.setFrame(0, 0, 0, 0);
      }
    }

  };
  AA.link(Sprite_WeaponMotion);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_WeaponMotion.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_WeaponMotion.prototype;
})();

// ■ END Sprite_WeaponMotion.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createUpperLayer, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_Base.prototype;
  //@[ALIAS]
  ALIAS__createUpperLayer = _.createUpperLayer;
  _.createUpperLayer = function() {
    ALIAS__createUpperLayer.call(this, ...arguments);
    if (AA.PP.isShowBloodSplatterEffect()) {
      this.aaCreateBloodSplatterEffectLayer();
    }
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    return this.aaUpdateBloodSplatterEffectSprite();
  };
})();

// ■ END Spriteset_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Base.prototype;
  _.aaCreateBloodSplatterEffectLayer = function() {
    this._aaBloodSplatterSpriteBase = new Sprite();
    this._aaBloodSplatterSpriteBase.z = 9;
    return this.addChild(this._aaBloodSplatterSpriteBase);
  };
  _.aaCreateBloodSplatterEffectSprite = function() {
    var BS_Picture, pic, ref;
    ({BS_Picture} = AA.PP.getBloodSplatterEffectSettings());
    if ((BS_Picture != null) && String.any(BS_Picture)) {
      pic = ImageManager.loadPicture(BS_Picture);
    } else {
      pic = ImageManager.loadEmptyBitmap();
    }
    this._aaBloodSplatterEffectSpr = new KDCore.Sprite(pic);
    this._aaBloodSplatterEffectSpr.appear(20);
    if ((ref = this._aaBloodSplatterSpriteBase) != null) {
      ref.addChild(this._aaBloodSplatterEffectSpr);
    }
  };
  _.aaRemoveBloodSplatterEffectSprite = function() {
    var ref;
    if ((ref = this._aaBloodSplatterSpriteBase) != null) {
      ref.removeChild(this._aaBloodSplatterEffectSpr);
    }
    this._aaBloodSplatterEffectSpr.visible = false;
    this._aaBloodSplatterEffectSpr = null;
  };
  _.aaUpdateBloodSplatterEffectSprite = function() {
    var e;
    if (this._aaBloodSplatterSpriteBase == null) {
      return;
    }
    try {
      if ($gameScreen.aaIsNeedBSEffectShow()) {
        if (this._aaBloodSplatterEffectSpr == null) {
          return this.aaCreateBloodSplatterEffectSprite();
        }
      } else {
        if (this._aaBloodSplatterEffectSpr != null) {
          return this.aaRemoveBloodSplatterEffectSprite();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this._aaBloodSplatterSpriteBase = null;
    }
  };
})();

// ■ END Spriteset_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createCharacters, ALIAS__createTilemap, ALIAS__createUpperLayer, ALIAS__initialize, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    this._aaMapAnimationSprites = [];
    this._aaMapSpriteEffects = [];
    this._aaMapDynamicSprites = [];
    ALIAS__initialize.call(this);
  };
  //@[ALIAS]
  ALIAS__createUpperLayer = _.createUpperLayer;
  _.createUpperLayer = function() {
    this.aaCreateExtraMapUpLayer();
    this.aaCreateDamagePopUpLayer();
    return ALIAS__createUpperLayer.call(this);
  };
  //@[ALIAS]
  ALIAS__createTilemap = _.createTilemap;
  _.createTilemap = function() {
    ALIAS__createTilemap.call(this);
    this.aaCreateExtraMapDownLayer();
    this.aaCreateSkillImpactSelector();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    this.aaRefreshMapAnimation();
    this.aaUpdateShatterEffect();
    return this.aaUpdateDynamicSprites();
  };
  
  //@[ALIAS]
  ALIAS__createCharacters = _.createCharacters;
  _.createCharacters = function() {
    ALIAS__createCharacters.call(this);
    this.aaCreateMapSkills();
    this.aaCreateMapFlyBonus();
    // * Одно событие для Skills и Бонусов
    AA.EV.subscribeFor("MapSkillsRequestsClean", this._aaClearMapSkills.bind(this));
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  (function() {    // * Анимация на карте
    // -----------------------------------------------------------------------
    //TODO: Учёт позиционированния анимации ??? (см. в редакторе alignBottom)

    //TODO: Через GEvent событие? (оптимизация)
    _.aaRefreshMapAnimation = function() {
      if ($gameMap.aaIsMapAnimationRequested()) {
        this.aaSetupMapAnimation($gameMap.aaMapAnimations.shift());
      } else {
        this.aaClearMapAnimations();
      }
    };
    _.aaSetupMapAnimation = function(animationRequest) {
      var animation, animationId, difX, difY, spr, sx, sy, tempChar, x, y;
      if (animationRequest == null) {
        return;
      }
      ({x, y, animationId, sx, sy} = animationRequest);
      animation = $dataAnimations[animationId];
      if (animation == null) {
        KDCore.warning("Animation with ID " + animationId + " not found!");
        return;
      }
      // * Создаём временного персонажа как координата карты
      tempChar = new Game_Character();
      tempChar.setPosition(x, y);
      spr = new Sprite_Character(tempChar);
      if ((sx != null) && (sy != null)) {
        difX = sx - tempChar.screenX();
        difY = sy - tempChar.screenY();
        spr.__aaExAnimationPos = {difX, difY};
      }
      this._aaMapAnimationSprites.push(spr);
      this._characterSprites.push(spr);
      if (KDCore.isMZ()) {
        this._effectsContainer.addChild(spr);
      } else {
        this._tilemap.addChild(spr);
      }
      AABattleActionsManager.playAnimationOnCharacter(tempChar, animationId);
    };
    // * Очистка анимаций карты
    _.aaClearMapAnimations = function() {
      var i, j, len, len1, ref, ref1, s;
      if (this._aaMapAnimationSprites == null) {
        return;
      }
      if (this._aaMapAnimationSprites.length === 0) {
        return;
      }
      // * Если нет никаких анимаций на карте, то удаляем всех созданных "временных" персонажей для анимаций
      if (KDCore.isMZ()) {
        if (this._animationSprites.length === 0) {
          ref = this._aaMapAnimationSprites;
          for (i = 0, len = ref.length; i < len; i++) {
            s = ref[i];
            this._characterSprites.delete(s);
          }
          this._aaMapAnimationSprites = [];
        }
      } else {
        ref1 = this._aaMapAnimationSprites;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          s = ref1[j];
          if (!s.isAnimationPlaying()) {
            this._tilemap.removeChild(s);
            this._characterSprites.delete(s);
            this._aaMapAnimationSprites.delete(s);
            this.aaClearMapAnimations();
            break;
          }
        }
      }
    };
  })();
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  (function() {    // * Дополнительные слои (под и над персонажами, но на карте)
    // -----------------------------------------------------------------------
    // * Под персонажами
    _.aaCreateExtraMapDownLayer = function() {
      this._aaLayer01 = new Sprite();
      this._aaLayer01.z = 1;
      this._tilemap.addChild(this._aaLayer01);
    };
    // * Над персонажами
    _.aaCreateExtraMapUpLayer = function() {
      this._aaLayer02 = new Sprite();
      this._aaLayer02.z = 4;
      this.addChild(this._aaLayer02);
    };
    _.aaCreateDamagePopUpLayer = function() {
      this._aaPopUpLayer = new Sprite();
      this._aaLayer02.addChild(this._aaPopUpLayer);
    };
    _.aaGetDamagePopUpLayer = function() {
      return this._aaPopUpLayer;
    };
    //TODO: Может над персонажами?
    _.aaCreateSkillImpactSelector = function() {
      this._aaSkillImpactSelector = new AA.Sprite_SkillImpactSelector();
      this._aaLayer01.addChild(this._aaSkillImpactSelector);
      AA.UI.setSkillImpactSelector(this._aaSkillImpactSelector);
    };
  })();
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  (function() {    
    // * Эффект Shatter на карте
    // -----------------------------------------------------------------------
    _.aaCreateShatterEffect = function(characterSprite) {
      var char, effectBase, i, j, k, l, len, maxw, pSize, part, ph, pw, ref, shatterEffectsSet, sx, sx2, sy, sy2, x, y, y3, y_perc;
      char = characterSprite._character;
      effectBase = new Sprite();
      if (characterSprite._character != null) {
        effectBase.z = characterSprite._character.screenZ();
      } else {
        effectBase.z = 1;
      }
      this._tilemap.addChild(effectBase);
      this.aaRegisterDynamicSprite(effectBase, char, -characterSprite.width / 2, -characterSprite.height);
      x = char._aaShatterEffectData[3];
      y = char._aaShatterEffectData[4];
      shatterEffectsSet = [];
      pSize = 8;
      pw = characterSprite.patternWidth();
      ph = characterSprite.patternHeight();
      maxw = Math.floor((pw / pSize) * (ph / pSize));
      if (characterSprite._tileId > 0) {
        sx = (Math.floor(characterSprite._tileId / 128) % 2 * 8 + characterSprite._tileId % 8) * pw;
        sy = Math.floor(characterSprite._tileId % 256 / 8) % 16 * ph;
      } else {
        sx = (characterSprite.characterBlockX() + characterSprite.characterPatternX()) * pw;
        sy = (characterSprite.characterBlockY() + characterSprite.characterPatternY()) * ph;
      }
      for (i = j = 0, ref = maxw; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        shatterEffectsSet[i] = new Sprite(characterSprite.bitmap);
        shatterEffectsSet[i].anchor.set(0.5);
        l = Math.floor(pSize * i / pw);
        x = pSize * i - (l * pw);
        y = Math.floor(l * pSize);
        y_perc = pSize * (i + 1) / Math.floor(pw / pSize) / ph;
        y3 = Math.floor(l * pSize);
        if (y >= ph - pSize) {
          y = ph - pSize;
        }
        sx2 = sx + x;
        sy2 = Math.floor(sy + y);
        shatterEffectsSet[i].x = x;
        shatterEffectsSet[i].y = y;
        shatterEffectsSet[i].y_perc = y_perc;
        shatterEffectsSet[i].setFrame(sx2, sy2, pSize, pSize);
        effectBase.addChild(shatterEffectsSet[i]);
        this._aaCreateShatterPartAnimation(shatterEffectsSet[i], char._aaShatterEffectData[3], char._aaShatterEffectData[4]);
      }
      for (k = 0, len = shatterEffectsSet.length; k < len; k++) {
        part = shatterEffectsSet[k];
        this._aaMapSpriteEffects.push(part);
      }
    };
    _._aaCreateShatterPartAnimation = function(sprite, x, y) {
      var r, sx, sy;
      sx = Math.random() * x + 0.1;
      sy = (Math.random() * 0.3) + 0.7 * y;
      r = Math.randomInt(2);
      if (r !== 0) {
        sx *= -1;
      }
      sprite.sx = sx;
      sprite.sy = sy;
      sprite.op = (Math.random() * 2) + 2.0;
      sprite.sc = 0;
      sprite.rt = (Math.random() + 0.5) * 0.1;
    };
    _._aaUpdateShatterEffectPartSprite = function(part) {
      var g, ground;
      if (part == null) {
        return;
      }
      g = 0.16;
      ground = 24 * (1 - part.y_perc) + 72 * part.y_perc;
      if (part.y < ground) {
        part.sy += g;
        part.rt = (Math.random() + 0.5) * 0.1;
      } else {
        part.sy = Math.min(-2, part.sy * (-0.5));
      }
      part.y += part.sy;
      part.x += part.sx;
      part.opacity -= part.op;
      part.scale.x += part.sc;
      part.scale.y += part.sc;
      part.rotation += part.rt;
    };
    _.aaUpdateShatterEffect = function() {
      var j, len, part, ref;
      ref = this._aaMapSpriteEffects;
      for (j = 0, len = ref.length; j < len; j++) {
        part = ref[j];
        this._aaUpdateShatterEffectPartSprite(part);
        if (part.opacity <= 0) {
          this._aaDeleteShatterEffectPartSprite(part);
          return;
        }
      }
    };
    // * Выход из цикла, так как удалили элемент
    _._aaDeleteShatterEffectPartSprite = function(part) {
      var parent;
      // * Смотрим родителя
      parent = part.parent;
      parent.removeChild(part);
      // * Если у него больше нет частей
      if (parent.children.length === 0) {
        // * Удаляем его из динамических спрайтов
        this._aaMapDynamicSprites.delete(parent);
      }
      this._aaMapSpriteEffects.delete(part);
    };
  })();
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  // * Добавить спрайт нового события
  _.aaAddSpawnedEvent = function(event) {
    var charSpr, e;
    try {
      charSpr = new Sprite_Character(event);
      this._characterSprites.push(charSpr);
      this._tilemap.addChild(charSpr);
      charSpr.update();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Регестрирует спрайт как статический на карте (не движется с экраном)
  // * Требует привязки к персонажу на карте, позволяет задать смещение
  _.aaRegisterDynamicSprite = function(sprite, character, dx = 0, dy = 0) {
    this._aaMapDynamicSprites.push(sprite);
    sprite._aaDynamicParent = character;
    sprite._aaDynX = dx;
    sprite._aaDynY = dy;
  };
  // * Удалить динамический спрайт
  // * Используется также для PopUp, они сами себя удаляют
  _.aaRemoveDynamicSprite = function(sprite) {
    if (this._aaMapDynamicSprites.contains(sprite)) {
      this._aaMapDynamicSprites.delete(sprite);
    }
  };
  // * Обновление динамических спрайтов (обновление позиции относительно камеры)
  _.aaUpdateDynamicSprites = function() {
    var dx, dy, i, len, p, ref, sprite;
    ref = this._aaMapDynamicSprites;
    for (i = 0, len = ref.length; i < len; i++) {
      sprite = ref[i];
      if ((sprite != null) && (sprite._aaDynamicParent != null)) {
        p = sprite._aaDynamicParent;
        dx = sprite._aaDynX;
        dy = sprite._aaDynY;
        sprite.move(p.screenX() + dx, p.screenY() + dy);
      } else {
        this.aaRemoveDynamicSprite(sprite);
      }
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  // * Данные методы аналогичны методам обработки Projectile Skills
  // (см. Spriteset_Map_AASkills)

  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  _.aaCreateMapFlyBonus = function() {
    var i, j, ref;
    this._aaMapFlyBonuses = [];
// * Создаём уже существующие (зарегестрированные) на карте
    for (i = j = 0, ref = $gameMap.aaMapFlyBonuses().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this.aaCreateNewMapFlyBonus(i, false);
    }
  };
  _.aaCreateNewMapFlyBonus = function(index, isAppear = true) {
    var bonus, sprite;
    bonus = $gameMap.aaMapFlyBonuses()[index];
    if (bonus == null) {
      return;
    }
    sprite = new Sprite_AAMapFlyBonus(index, isAppear);
    this._aaMapFlyBonuses[index] = sprite;
    this._tilemap.addChild(sprite);
  };
  
  // * Вызывается из метода _aaClearMapSkills, т.к. используется одно событие
  _._aaClearMapFlyBonuses = function() {
    var e, i, j, ref, results;
    try {
      results = [];
      for (i = j = 0, ref = $gameMap.aaMapFlyBonuses().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (!this._aaMapFlyBonuses[i] || this._aaMapFlyBonuses[i].isEnd()) {
          this._tilemap.removeChild(this._aaMapFlyBonuses[i]);
          this._aaMapFlyBonuses[i] = null;
          results.push($gameMap.aaMapFlyBonuses()[i] = null);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  _.aaCreateMapSkills = function() {
    var i, j, ref;
    this._aaMapSkills = [];
// * Создаём уже существующие (зарегестрированные) на карте
    for (i = j = 0, ref = $gameMap.aaMapSkills().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this.aaCreateNewMapSkill(i);
    }
  };
  _.aaCreateNewMapSkill = function(index) {
    var skill, sprite;
    skill = $gameMap.aaMapSkills()[index];
    if (skill == null) {
      return;
    }
    sprite = new Sprite_AAMapSkill2Projectile(index);
    this._aaMapSkills[index] = sprite;
    this._tilemap.addChild(sprite);
  };
  //@[EVENT]
  _._aaClearMapSkills = function() {
    var i, j, ref;
    this._aaClearMapFlyBonuses();
    for (i = j = 0, ref = $gameMap.aaMapSkills().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      if (!this._aaMapSkills[i] || this._aaMapSkills[i].isEnd()) {
        this._tilemap.removeChild(this._aaMapSkills[i]);
        this._aaMapSkills[i] = null;
        $gameMap.aaMapSkills()[i] = null;
      }
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Интерфейс AABS на карте
(function() {
  var Spriteset_UI;
  Spriteset_UI = class Spriteset_UI extends Sprite {
    constructor() {
      super();
      this._init(); //#Spriteset_UI_0
      this.applyUserSettings(); // * Применить настройки игрока
    }

    static Instance() {
      var e;
      try {
        if (KDCore.Utils.isSceneMap()) {
          return SceneManager._scene._aaUI;
        } else if (SceneManager._scene instanceof AA.Scene_UIEditor) {
          return SceneManager._scene.uiSpriteset;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    isActive() {
      return this.visible === true;
    }

    show() {
      return this.visible = true;
    }

    hide() {
      return this.visible = false;
    }

    terminate() {
      this._terminateElements(); //#Spriteset_UI_0
      this.visible = false;
    }

    // * Обновить все контроллеры и элементы
    refresh() {
      var controller, i, len, ref;
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        controller = ref[i];
        controller.refresh();
      }
    }

    onGameMessageStart() {
      return this.getElementsWithMessageFlag().forEach(function(e) {
        return e.opacity = 50;
      });
    }

    onGameMessageEnd() {
      return this.getElementsWithMessageFlag().forEach(function(e) {
        return e.opacity = 255;
      });
    }

    // * Применить пользовательские настройки ко всем элементам
    applyUserSettings() {
      var e, i, len, ref, user;
      user = $gameSystem.aaGetUserUISettings();
      this._applyVisibility(user);
      ref = this.elements;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (user.isHaveFor(e.tag)) {
          //#Spriteset_UI_0
          this._applyUserSettingsFor(e, user);
        }
      }
    }

    // * Обновить элемент (применить настройки)
    refreshElement(tag) {
      var e, element;
      element = this.getElement(tag);
      if (element == null) {
        return;
      }
      try {
        if (element.refresh != null) {
          element.refresh();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      try {
        this._applyUserSettingsFor(element, $gameSystem.aaGetUserUISettings()); //#Spriteset_UI_0
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }

    // * Обновить контроллер элемента
    refreshController(tag) {
      var controller, e;
      try {
        controller = this.getController(tag);
        if (controller == null) {
          return;
        }
        controller.refresh();
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }

    // * Восстановить настройки элемента
    resetElement(tag) {
      var element;
      element = this.getElement(tag);
      if (element == null) {
        return;
      }
      element.reset("position");
      element.reset("visible");
    }

    getElement(tag) {
      return this.elements.find(function(e) {
        return e.tag === tag;
      });
    }

    getController(tag) {
      return this.controllers.find(function(c) {
        return c.tag === tag;
      });
    }

    // * Данный метод "собирает" один раз
    getElementsWithMessageFlag() {
      if (this._elementsWithMessageFlag == null) {
        this._elementsWithMessageFlag = this.elements.filter(function(e) {
          return e.isHaveHideWithMessageFlag();
        });
      }
      return this._elementsWithMessageFlag;
    }

  };
  AA.link(Spriteset_UI);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._init = function() {
    // * Регестрирует себя в менеджере
    AA.UI.setUI(this);
    // * Набор всех элементов
    this.elements = [];
    // * Набор всех контроллеров
    this.controllers = [];
    // * Набор всех компонентов
    this.uiSets = [];
    //TODO: Загрузка всех компонентов из параметров и подготовка
    return this._create();
  };
  // * Дополнительное закрытие элементов (перед закрытием всего UI)
  _._terminateElements = function() {
    return this._terminateSkillSelectorWindow(); //#Spriteset_UI_SkillsSet
  };
  
  // * Получить все элементы
  // * Обновить элемент по тэгу
  // * (возможно) Обновить все элементы
  // * Получить элемент по тэгу
  _._create = function() {
    this._createLowerUILayer();
    this._createNormalUILayer();
    return this._createElements();
  };
  // * Нижний слой нужен для пользовательских UI элементов, которые должны быть ниже UI
  _._createLowerUILayer = function() {
    this.lowerLayer = new Sprite();
    return this.addChild(this.lowerLayer);
  };
  _._createNormalUILayer = function() {
    this.layer = new Sprite();
    return this.addChild(this.layer);
  };
  _._createElements = function() {
    return this._createDefaultElements();
  };
  //@_createUserElements()
  _._createDefaultElements = function() {
    this._createSkillsSet(); //#Spriteset_UI_SkillsSet
    this._createSkillSelectorWindow(); //#Spriteset_UI_SkillsSet
    this._createActorUI(); //#Spriteset_UI_ActorUI
    return this._createTargetUI(); //#Spriteset_UI_Target
  };
  
  // * Добавить набор и зарегестрировать все элементы и контроллеры из набора
  _._registerUISet = function(uiSet) {
    this.elements.push(...uiSet.elements);
    this.controllers.push(...uiSet.controllers);
    this.uiSets.push(uiSet);
    this._addElementToUI(uiSet);
  };
  // * Добавит и зарегестрировать элемент (чтобы можно было управлять через команды)
  _._registerUIElement = function(sprite) {
    var e;
    try {
      if (sprite == null) {
        return;
      }
      if (sprite.tag == null) {
        console.warn("You try register UI element without TAG");
      }
      this._addElementToUI(sprite);
      return this.elements.push(sprite);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Добавить элемент на обычный слой (выше пользовательских)
  _._addElementToUI = function(sprite) {
    return this.layer.addChild(sprite);
  };
  // * Применить пользовательские настройки к элементу
  _._applyUserSettingsFor = function(element, settings) {
    var key, pos, visible;
    key = element.tag;
    pos = settings.getPositionFor(key);
    if (pos != null) {
      element.move(pos.x, pos.y);
    } else {
      element.reset("position");
    }
    visible = settings.getVisibleFor(key);
    if (visible != null) {
      element.visible = visible;
    } else {
      element.reset("visible");
    }
  };
  
  // * Обновить видимость всего UI
  _._applyVisibility = function(settings) {
    var visible;
    if (!settings.isHaveFor("main")) {
      this.show(); // * По стандарту, всегда видно
      return;
    }
    visible = settings.getVisibleFor("main");
    if (visible != null) {
      if (visible === true) {
        return this.show();
      } else {
        return this.hide();
      }
    } else {
      return this.show(); // * По стандарту, всегда видно
    }
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createActorUI = function() {
    this._createActorGauges();
    this._createActorBuffsIcons();
    this._createActorStatesIcons();
    return this._createActorSkillExtensionMenu();
  };
  _._createActorGauges = function() {
    this.sActorGauges = new AA.UISet_ActorGauges(this);
    return this._registerUISet(this.sActorGauges); //# Spriteset_UI_0
  };
  _._createActorBuffsIcons = function() {
    if (!AA.PP.getIsBuffsVisible()) {
      return;
    }
    this.sActorBuffs = new AA.UISet_ActorBuffsIcons(this);
    return this._registerUISet(this.sActorBuffs); //# Spriteset_UI_0
  };
  _._createActorStatesIcons = function() {
    if (!AA.PP.getIsStatesVisible()) {
      return;
    }
    this.sActorStates = new AA.UISet_ActorStatesIcons(this);
    return this._registerUISet(this.sActorStates); //# Spriteset_UI_0
  };
  _._createActorSkillExtensionMenu = function() {
    this.sActorSkillExtIcon = new AA.Sprite_WeaponExtensionSlot();
    this._registerUIElement(this.sActorSkillExtIcon);
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createSkillsSet = function() {
    this.sSkills = new AA.UISet_Skills(this);
    return this._registerUISet(this.sSkills); //# Spriteset_UI_0
  };
  _._createSkillSelectorWindow = function() {
    var e, h, p, w;
    try {
      p = $aabsz_SkillItemSelectorWindowSettings.windowSize;
      w = p.width || 160;
      h = p.height || 360;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      w = 160;
      h = 360;
    }
    this.fwSkillsSelector = new FWindow_SkillSelect(this, w, h);
    return this._addElementToUI(this.fwSkillsSelector);
  };
  _._terminateSkillSelectorWindow = function() {
    var ref;
    return (ref = this.fwSkillsSelector) != null ? ref.close() : void 0;
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createTargetUI = function() {
    //TODO: А если не активен?
    this.sTargetInfo = new AA.UISet_TargetInfo(this);
    return this._registerUISet(this.sTargetInfo); //# Spriteset_UI_0
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var StatesIconsController;
  
    //%[I] Опция (параметр плагина), чтобы можно было выбрать какие состояния показывать (все или только АБС)

    //%[I] Показывать и количество шагов и количество урона до снятия состояния (разными цветами)

    //%[I] Показывать подсказки при наведении мыши на иконку состояния

    // * Общий контроллер для отрисовки состояний (states) персонажа (игрока)
  //?rev 25.02.22
  StatesIconsController = class StatesIconsController extends AA.BuffIconsController {
    constructor() {
      super(...arguments);
      // * Нет ограничения (8)
      this.maxCount = this.buffSprites.length;
      return;
    }

    collectStates() {
      var i, j, ref, states;
      states = this.source._states.map(function(s) {
        return $dataStates[s];
      });
      // * Отсортировать по Priority
      states.sort(function(a, b) {
        if (a.priority > b.priority) {
          return -1;
        } else {
          return 1;
        }
      });
      // * Режиме редактора, мы дополним состоянием 1, чтобы визуально было видно
      if (AA.System.isUIEditor() && states.length < this.maxCount) {
        for (i = j = 0, ref = this.maxCount - states.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          states.push($dataStates[1]);
        }
      }
      return states;
    }

    getStateObj(stateId) {
      return $dataStates[stateId];
    }

    collectStateTurns(stateId) {
      return this.source.aaStates.getDisplayValueForState(stateId);
    }

    isAAState(state) {
      return AA.Utils.isAAState(state);
    }

    isAAStateIsActionBased(state) {
      return this.isAAState(state) && state.AAState.isActionEndState();
    }

    isAAStateHaveAnyTurns(state) {
      return this.isAAState(state) && (this.isAAStateIsActionBased(state) || state.AAState.isTimeEndState());
    }

  };
  AA.link(StatesIconsController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.StatesIconsController.prototype;
  //$[OVER]
  _._refresh = function() {
    var e, i, j, ref, ref1, state, states;
    states = this.collectStates();
    if (states.isEmpty()) {
      this._clearAll();
    } else {
      for (i = j = 0, ref = this.maxCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        state = states[i];
        if (state != null) {
          try {
            this._drawStateInfo(state, i);
          } catch (error) {
            e = error;
            AA.w(e);
          }
        } else {
          if ((ref1 = this.buffSprites[i]) != null) {
            ref1.clear();
          }
        }
      }
    }
  };
  _._drawStateInfo = function(state, i) {
    var icon, isAction, isShouldHaveText, ref, text, turns;
    icon = state.iconIndex;
    isAction = false;
    text = "";
    if (this.isAAState(state)) {
      isShouldHaveText = this.isAAStateHaveAnyTurns(state);
      if (isShouldHaveText === true) {
        isAction = this.isAAStateIsActionBased(state);
        turns = this.collectStateTurns(state.id);
        if (turns > 0) {
          text = turns;
        }
      }
    }
    return (ref = this.buffSprites[i]) != null ? ref.drawStateInfo(icon, text, isAction) : void 0;
  };
  _._clearAll = function() {
    var e, j, len, ref, results, spr;
    try {
      ref = this.buffSprites;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        spr = ref[j];
        results.push(spr != null ? spr.clear() : void 0);
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный набор вспомогательных функций для пользователя
var uAPI;

uAPI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = uAPI;
  (function() {    // * Панель навыков
    // -----------------------------------------------------------------------
    // * Добавить навык на панель навыков
    // * 0 - убрать из слота
    // * slotSymbol == null - в любое не занятое место
    _.setSkillToPanel = function(skillId, slotSymbol) {
      var e, ref, ref1, ref2;
      try {
        if (slotSymbol != null) {
          slotSymbol = slotSymbol.toString();
        }
        if (skillId <= 0) { // * Удаляем навык из панели
          if (AA.Utils.isSkillPanelSymbol(slotSymbol)) {
            if ((ref = $gamePlayer.aaSkillsSet) != null) {
              ref.setSymbolForSkill(0, slotSymbol, null); // * Устанавливаем навык на панель
            }
          }
        } else {
          // * Если НАВЫК, то должен быть изучен
          if (AA.Utils.isAASkill(skillId)) {
            if (!$gamePlayer.aaIsHaveABSSkill(skillId)) {
              return;
            }
          }
          // * Предметы можно устанавливать, даже если нет в инвентаре (будет 0)
          if (AA.Utils.isSkillPanelSymbol(slotSymbol)) {
            if ((ref1 = $gamePlayer.aaSkillsSet) != null) {
              ref1.setSymbolForSkill(skillId, slotSymbol, null); // * Если символ не указан (или указан неверно, то устанавливаем в свободное место)
            }
          } else {
            if ((ref2 = $gamePlayer.aaSkillsSet) != null) {
              ref2.setSkillInEmptySlot(skillId);
            }
          }
        }
        AA.UI.refreshElement('skills');
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Добавить предмет на панель навыков, поддерживает как обычные ID, так и idA
    _.setItemToPanel = function(itemId, slotSymbol) {
      var e;
      try {
        // * Автоматическое преобразование в ID предмета
        if (itemId > 0 && !AA.Utils.isAAItem(itemId)) {
          itemId += AA.Utils.ItemsIDStart;
        }
        this.setSkillToPanel(itemId, slotSymbol);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Если навыка нет или неверно указан slotSymbol - будет возвращён 0
    _.getSkillIdFromPanel = function(slotSymbol) {
      var ref;
      if (slotSymbol != null) {
        slotSymbol = slotSymbol.toString();
      }
      return (ref = $gamePlayer.aaSkillsSet) != null ? ref.getSkillForSymbol(slotSymbol) : void 0;
    };
    // * Безопасно обновить панель навыков
    return _.refreshSkillPanelSafe = function() {
      setTimeout((function() {
        var e;
        try {
          if (KDCore.Utils.isSceneMap() && !SceneManager.isSceneChanging()) {
            AA.UI.refreshElement('skills');
            return AA.UI.refreshElement('skillExtensionIcon');
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 1);
    };
  })();
  (function() {    // * Система АБС (Общее)
    // -----------------------------------------------------------------------
    _.pauseABS = function() {
      return AA.System.pauseABS();
    };
    _.resumeABS = function() {
      return AA.System.resumeABS();
    };
    // * Вызвать Script Action
    _.scriptAction = function(scriptAction, char = null, delay = 0) {
      var e;
      try {
        if (!String.any(scriptAction)) {
          return;
        }
        // * Это будет вызываться из событий скорее всего, поэтому преобразуем в Event
        // * Преобразуем наперёд, чтобы delayed можно было вызвать
        if (char instanceof Game_Interpreter) {
          if (char.eventId() > 0) {
            char = $gameMap.event(char.eventId());
          } else {
            char = null;
          }
        }
        if (delay <= 0) {
          return AA.SAaction.execute(scriptAction, char);
        } else {
          return AA.Utils.callDelayed(function() {
            return AA.SAaction.execute(scriptAction, char);
          }, delay);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Последний Game_Character, которого нашёл локатор
    _.lastLocatorTarget = function() {
      return $gameTemp.aaLastLocatorTarget;
    };
    // * Последнее событие локатор, которое было активированно
    _.lastActivatedLocator = function() {
      return $gameTemp.aaLastActivatedLocator;
    };
    // * Воспроизвести доп. анимацию навыка
    _.playExtraAnimation = function(x, y, extraAnimation, seName = "", ox = 0, oy = 0) {
      var animationSprite, e;
      try {
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        if (!String.any(extraAnimation)) {
          return;
        }
        animationSprite = new Spirte_AASeqMapAnimation(x, y, extraAnimation);
        animationSprite.setupOffsets(ox, oy);
        animationSprite.linkToMap();
        return KDCore.Utils.playSE(seName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Рисовать область видимости врагов
    _.drawEnemyVisors = function(isDraw, opacity = 100, color = "#d14532") {
      var e;
      try {
        if (isDraw === true) {
          return $gameSystem.aaDrawEnemyVision = {opacity, color};
        } else {
          return $gameSystem.aaDrawEnemyVision = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Музыка для битвы (или другая), с задержкой в секундах!
    _.playBattleBgm = function(name, delay = 0) {
      var e;
      try {
        return AudioManager.aaPlayBattleBgm(name, delay * 60);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.stopBattleBgm = function(delay) {
      var e;
      try {
        return AudioManager.aaStopBattleBgm(delay * 60);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Действия игрока
    // -----------------------------------------------------------------------
    return _.makePlayerDodge = function(isForce = false) {
      var e;
      try {
        if (isForce === true) {
          return $gamePlayer.aaPerformDodge();
        } else {
          if (!AA.PP.isAllowDodge()) {
            return;
          }
          if ($gamePlayer.aaIsCanDodgeNow()) {
            return $gamePlayer.aaPerformDodge();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Интерфейс АБС
    // -----------------------------------------------------------------------
    _.editUI = function() {
      var e;
      try {
        if (!AA.isPro()) {
          window.alert("UI Editor available only in [PRO] version of plugin");
          return;
        }
        if (AA.isMap()) {
          return SceneManager.push(AA.Scene_UIEditor);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.controlUIElement = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        user.set(...arguments);
        return AA.UI.refreshElement(arguments[0]);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showUI = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        // * Просто удаляем настройки, так как по умолчанию интерфейс всегда видно
        // * других настроек у интерфейса нету
        user.set("main", "clear");
        return AA.UI.show();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: Кнопки нажимаются напанели, даже если скрытый интерфейс
    //TODO: Надо метод isValid дополнить (который в AA.UI) и делать проверки
    _.hideUI = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        user.set("main", "setVisible", false);
        return AA.UI.hide();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: Этот метод добавить в SActions !!!
    _.showPopUpOnChar = function(charId, styleId, value, isForceString = false) {
      var char, e;
      try {
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        charId = KDCore.Utils.getEValue(charId);
        if (!isForceString) {
          value = KDCore.Utils.getEValue(value);
        }
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        return uAPI._showPopUpGlobal("char", char, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._showPopUpGlobal = function(type, charOrPos, styleId, value) {
      var e, settings;
      try {
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        settings = AA.PP.getPopUpDamageSettings(styleId);
        if (settings == null) {
          AA.w("PopUp settings with ID " + styleId + " not found!");
          settings = AA.PP.getPopUpDamageSettings("default");
        }
        if (settings == null) {
          return;
        }
        switch (type) {
          case "char":
            return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(charOrPos, settings, value);
          case "map":
            return Sprite_AADamagePopUpItem.CreateOnMap(charOrPos.x, charOrPos.y, settings, value);
          case "screen":
            return Sprite_AADamagePopUpItem.CreateOnScreen(charOrPos.x, charOrPos.y, settings, value);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showPopUpOnMap = function(x, y, styleId, value, isForceString = false) {
      var e;
      try {
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        if (!isForceString) {
          value = KDCore.Utils.getEValue(value);
        }
        x = KDCore.Utils.getEValue(x);
        y = KDCore.Utils.getEValue(y);
        return uAPI._showPopUpGlobal("map", {x, y}, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showPopUpOnScreen = function(x, y, styleId, value, isForceString = false) {
      var e;
      try {
        if (!KDCore.Utils.isSceneMap()) {
          return;
        }
        if (!isForceString) {
          value = KDCore.Utils.getEValue(value);
        }
        x = KDCore.Utils.getEValue(x);
        y = KDCore.Utils.getEValue(y);
        return uAPI._showPopUpGlobal("screen", {x, y}, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.resetUserUISettings = function() {
      var user;
      user = $gameSystem.aaGetUserUISettings();
      user.settings = {}; // * reset all
      user.saveGlobalSettings();
    };
    //#AA.UI.refreshAllElements()
    return _.setBloodSplatterEffectVisible = function(isEnabled = true) {
      var e;
      try {
        if (isEnabled === true) {
          return $gameSystem.absBSEForceDisabled = null;
        } else {
          return $gameSystem.absBSEForceDisabled = true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Камера
    // -----------------------------------------------------------------------
    // * Активировать скролл камеры
    _.enableMapScroll = function() {
      var e;
      try {
        Scene_Map.prototype.aaUpdateMapScrlByMouse = Scene_Map.prototype.aaUpdateMapScrlByMouseBody;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Отключить скролл камеры
    _.disableMapScroll = function() {
      var e;
      try {
        if ((typeof $gameTemp !== "undefined" && $gameTemp !== null) && $gameTemp.aaIsMapScrolled()) {
          this.resetMapScroll();
        }
        Scene_Map.prototype.aaUpdateMapScrlByMouse = function() {}; // * EMPTY
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Сбросить скролл камеры (на центр - игрок)
    return _.resetMapScroll = function() {
      var e;
      try {
        $gamePlayer.center($gamePlayer.x, $gamePlayer.y);
        $gameTemp.aaSetMapScrolled(false);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Управление объектами
    // -----------------------------------------------------------------------
    // * Получить опыт за врага по номеру в БД (isVisible == true -> PopUp)
    _.gainExpForEnemyDb = function(enemyId, isVisible = true) {
      var e, enemy, expValue;
      try {
        enemy = $dataEnemies[enemyId];
        if (enemy == null) {
          return;
        }
        expValue = AA.Utils.getExpFromAAEnemy(enemy);
        $gameParty.aaGainExpForParty(expValue, isVisible);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Получить опыт за врага по номеру события
    _.gainExpForEnemyEv = function(eventId, isVisible = true) {
      var e, event, expValue, expVarId;
      try {
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        // * Событие не АБС и не было АБС ранее
        if (event.aaEventSettings == null) {
          return;
        }
        // * Если есть специальная переменная для опыта, сразу из неё
        expVarId = event.aaEventSettings.getExpVarId();
        if (expVarId > 0) {
          expValue = $gameVariables.value(expVarId);
          $gameParty.aaGainExpForParty(expValue, isVisible);
        } else {
          this.gainExpForEnemyDb(event.aaEventSettings.getEnemyId());
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Изменить (дать) здоровье напрямую (с вспылвающим PopUp)
    _.gainHpForBattler = function(charId, value, isCrit = false) {
      var e;
      try {
        uAPI._gainHpOrMpForBattler(charId, value, 'hp', isCrit);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Изменить (дать) ману напрямую (с вспылвающим PopUp)
    _.gainMpForBattler = function(charId, value, isCrit = false) {
      var e;
      try {
        uAPI._gainHpOrMpForBattler(charId, value, 'mp', isCrit);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _._gainHpOrMpForBattler = function(charId, value, type, isCrit) {
      var battler, e, event;
      try {
        //TODO: Получение по charId вынести в Utils (много где используется)
        if (charId > 0) {
          event = $gameMap.event(charId);
          if (event == null) {
            return;
          }
          if (!event.isABS()) {
            return;
          }
          battler = event.AABattler();
        } else {
          battler = $gameParty.leader();
        }
        if (battler == null) {
          return;
        }
        if (type === 'hp') {
          return battler.aaGainHpWithPopUp(value, isCrit);
        } else {
          return battler.aaGainMpWithPopUp(value, isCrit);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Дать опыт (с PopUp)
    _.gainExpForParty = function(value) {
      var e;
      try {
        if (value == null) {
          return;
        }
        if (value <= 0) {
          return;
        }
        return $gameParty.aaGainExpForParty(value, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Дать золото (с PopUp)
    _.gainGoldForParty = function(value) {
      var e;
      try {
        if (value == null) {
          return;
        }
        return $gameParty.aaGainGoldForParty(value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Получить одного врага по метке (первый)
    //?Может вернуть NULL
    _.getEnemyByLabel = function(label = "") {
      var e;
      try {
        return this.getEnemiesByLabel(label).first();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    // * Получить всех врагов по метке (массив)
    _.getEnemiesByLabel = function(label = "") {
      var e;
      try {
        return $gameMap.eventAAWithLabel(label);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    // * Сбросить сохранённое состояние здоровья врага (врагов, всей карты, вообще)
    _.resetHpForEnemy = function(mapId, eventId = 0) {
      var e;
      try {
        if ($gameSystem._aaEnemiesHPDataStored == null) {
          return;
        }
        if ((mapId == null) || mapId === 0) {
          $gameSystem._aaEnemiesHPDataStored = null;
          return;
        }
        if ((eventId == null) || eventId <= 0) {
          $gameSystem._aaEnemiesHPDataStored[mapId] = null;
          delete $gameSystem._aaEnemiesHPDataStored[mapId];
          return;
        }
        return delete $gameSystem._aaEnemiesHPDataStored[mapId][eventId];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Спавн "летающего" бонуса (от события) до игрока
    // * bonusIds - array
    //TODO: Добавить SAction
    _.spawnFlyingBonus = function(eventId, bonusIds) {
      var bonusData, e, event, i, id, len, results;
      try {
        if (bonusIds == null) {
          return;
        }
        if (bonusIds.length === 0) {
          return;
        }
        // * Проверка, что событие существует
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        results = [];
        for (i = 0, len = bonusIds.length; i < len; i++) {
          id = bonusIds[i];
          bonusData = AA.PP.getAfterDeathBonus(id);
          if (bonusData == null) {
            continue;
          }
          results.push($gameMap.aaRequestFlyBonusSpawn(eventId, bonusData));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCustomGaugeForVariable = function(parametersId, variableId, bindedEventId, x, y, isGlobal) {
      var e, parameters, system;
      try {
        system = AACustomGaugesSystem.Instance();
        if (system == null) {
          return;
        }
        // * Не стал убирать возможность создавать много gauge для одной переменной
        //if system.isExistsGaugeForVariable()
        //    @removeVariableCustomGauge(variableId)
        parameters = AA.PP.getCustomGaugeById(parametersId);
        return system.addGauge(variableId, parameters, x, y, bindedEventId, 0, isGlobal);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCustomGaugeForEnemy = function(parametersId, enemyEventId, bindedEventId, x, y) {
      var e, parameters, system;
      try {
        system = AACustomGaugesSystem.Instance();
        if (system == null) {
          return;
        }
        parameters = AA.PP.getCustomGaugeById(parametersId);
        return system.addGauge(0, parameters, x, y, bindedEventId, enemyEventId, false);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.removeVariableCustomGauge = function(variableId) {
      var e, ref;
      try {
        return (ref = AACustomGaugesSystem.Instance()) != null ? ref.removeGaugeByVarId(variableId) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.removeEnemyCustomGauge = function(enemyEventId) {
      var e, ref;
      try {
        return (ref = AACustomGaugesSystem.Instance()) != null ? ref.removeGaugeByEnemyId(enemyEventId) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Спавн врагов
    // -----------------------------------------------------------------------
    // * Спавн врага в точке {X, Y} или в случайной точке в регионе Х
    //?Все аргументы - Extended Values
    _.spawnEnemy = function(id, xOrRegion, y) {
      var e, e2;
      $gameTemp.aaLastSpawnedEvent = null;
      if (!DataManager.aaIsSpawnMapValid()) {
        console.warn("You try spawn Enemy, but not setup Spawn Map ID in Plugin Parameters");
      } else {
        try {
          id = KDCore.Utils.getEValue(id);
          xOrRegion = KDCore.Utils.getEValue(xOrRegion);
          y = KDCore.Utils.getEValue(y);
          if (y != null) {
            $gameMap.aaSpawnEnemyInPoint(id, xOrRegion, y);
          } else {
            $gameMap.aaSpawnEnemyInRegion(id, xOrRegion);
          }
          try {
            // * Spawn Animation
            if ($gameSystem.aaEnemySpawnAnimationId > 0 && this.isEnemyBeenSpawned()) {
              $gameMap.aaPlaySpawnAnimation(this.getLastSpawnedEnemy(), $gameSystem.aaEnemySpawnAnimationId);
            }
          } catch (error) {
            e2 = error;
            KDCore.warning(e2);
          }
          AANetworkManager.spawnEnemy(id, xOrRegion, y);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
    };
    // * Спавн врага (без проверок)
    _.spawnEnemyForced = function() {
      $gameTemp.aaIsForceSpawn = true;
      uAPI.spawnEnemy(...arguments);
    };
    // * Возвращает событие, которое было отспавнено последним
    //?Может вернуть NULL
    _.getLastSpawnedEnemy = function() {
      return $gameTemp.aaLastSpawnedEvent;
    };
    // * Был ли отспавнен враг после последней команды спавна?
    _.isEnemyBeenSpawned = function() {
      return uAPI.getLastSpawnedEnemy() != null;
    };
    // * Спавн врага в случайном месте вокруг точки {X, Y} (в пределах радиуса)
    _.spawnEnemyAround = function(id, x, y, radius) {
      var e, p;
      $gameTemp.aaLastSpawnedEvent = null;
      if (!DataManager.aaIsSpawnMapValid()) {
        console.warn("You try spawn Enemy, but not setup Spawn Map ID in Plugin Parameters");
      } else {
        try {
          // * ID не надо, так как идёт вызов spawnEnemy, где преобразование
          //id = KDCore.Utils.getEValue(id)
          x = KDCore.Utils.getEValue(x);
          y = KDCore.Utils.getEValue(y);
          radius = KDCore.Utils.getEValue(radius);
          if ((id != null) && (x != null) && (y != null) && (radius != null) && radius > 0) {
            p = $gameMap.aaGetRandomSpawnPointInRadius(x, y, radius);
            if (p != null) {
              uAPI.spawnEnemy(id, p.x, p.y);
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
    };
    // * Спавн врага вокруг игрока (на максимальном расстоянии maxDistance)
    _.spawnEnemyNearPlayer = function(id, maxDistance = 2) {
      var e;
      try {
        return uAPI.spawnEnemyAround(id, $gamePlayer.x, $gamePlayer.y, maxDistance);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.spawnEnemyAroundForced = function() {
      $gameTemp.aaIsForceSpawn = true;
      uAPI.spawnEnemyAround(...arguments);
    };
    // * Вернуть всех отспавненных врагов (объекты)
    _.getSpawnPointSpawnedEnemies = function(spawnPointId) {
      var e;
      try {
        return $gameMap.eventsAA().filter(function(ev) {
          return ev instanceof Game_AASpawnedEvent && ev._aaSpawnPointRelativeId === spawnPointId;
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    // * Вернуть число (общее) отспавненных врагов точкой спавна
    _.getSpawnPointSpawnedTotal = function(spawnPointId) {
      var e;
      try {
        return $gameMap.event(spawnPointId)._aaSpawnPointSpawnedCount;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
    };
    // * Вернуть число (общее) живых на данных момент отспавленных врагов точкой спавна
    _.getSpawnPointSpawnedAlive = function(spawnPointId) {
      var e, spawnedAlive;
      try {
        spawnedAlive = this.getSpawnPointSpawnedEnemies(spawnPointId).filter(function(ev) {
          return ev.AABattler().isAlive();
        });
        return spawnedAlive.length;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
    };
    
    // * Вернуть общее число живых врагов (которые были отспавнены)
    _.getSpawnEnemiesAlive = function() {
      var e, events;
      try {
        events = $gameMap.eventsAA().filter(function(ev) {
          return ev instanceof Game_AASpawnedEvent && ev.isABS() && ev.AABattler().isAlive();
        });
        if (events != null) {
          return events.length;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    // * Вернуть количество отспавненных врагов по Map Encounters (для текущей карты)
    _.getSpawnedByEncountersCount = function() {
      var e;
      try {
        return $gameMap.aaGetEncountersCount();
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    // * Установить анимацию спавна для след. спавн врага
    // * 0 или null - очистить
    return _.setSpawnEnemyAnimation = function(animationId = 0) {
      var e;
      try {
        $gameSystem.aaEnemySpawnAnimationId = 0;
        if (animationId == null) {
          animationId = 0;
        }
        if (animationId <= 0) {
          return;
        }
        if ($dataAnimations[animationId] == null) {
          return;
        }
        return $gameSystem.aaEnemySpawnAnimationId = animationId;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Навыки
    // -----------------------------------------------------------------------
    //ownerId, skillId, x, y - EValues
    _.executeAASkillOnMap = function(ownerId, teamId, skillId, x, y) {
      var aaSkill, e, subject;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'OnMap')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, x, y);
        if (subject == null) {
          return;
        }
        AABattleActionsManager.startAASkill(aaSkill, subject, {x, y});
        subject.dispose(); // * Сразу Dispose, чтобы память не отнимал
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    //Projectile из точки по направлению
    //Projectile из точки в точку
    // * xOrD - направление или X цели
    // * tY - Y цели, если не указывать, то будет по направлению только
    _.executeAASkillOnMapProjFromPoint = function(ownerId, teamId, skillId, x, y, xOrD, tY = null) {
      var aaSkill, direction, e, subject, targetPoint;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'ByDirection')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          return;
        }
        if ((xOrD != null) && (tY == null)) {
          direction = xOrD;
        } else {
          direction = null;
        }
        subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, x, y, direction);
        if (subject == null) {
          return;
        }
        targetPoint = subject;
        if ((xOrD != null) && (tY != null)) {
          targetPoint = {
            x: xOrD,
            y: tY
          };
        }
        return AABattleActionsManager.startAASkill(aaSkill, subject, targetPoint);
      } catch (error) {
        // * Dispose будет вызван в классе Sprite_AAMapSkill2Projectile
        e = error;
        return KDCore.warning(e);
      }
    };
    _.executeAASkillOnChar = function(ownerId, teamId, skillId, charId) {
      var char, e;
      try {
        charId = KDCore.Utils.getEValue(charId);
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        if (char == null) {
          return;
        }
        uAPI.executeAASkillOnMap(ownerId, teamId, skillId, char.x, char.y);
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    //Projectile из СОБЫТИЯ по ЕГО направлению
    //Projectile из  СОБЫТИЯ в точку [(tX, tY)]
    _.executeAASkillOnMapProjFromChar = function(ownerId, teamId, skillId, charId, tX, tY) {
      var aaSkill, char, e, subject, targetPoint;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'ByDirection')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          return;
        }
        charId = KDCore.Utils.getEValue(charId);
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        if (char == null) {
          return;
        }
        if ((tX != null) && (tY != null)) {
          targetPoint = {
            x: tX,
            y: tY
          };
        } else {
          targetPoint = char;
        }
        if (char.isABS()) {
          subject = char;
        } else {
          subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, char.x, char.y, char.direction());
        }
        if (subject == null) {
          return;
        }
        AABattleActionsManager.startAASkill(aaSkill, subject, targetPoint);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Последний использованный навык
    _.lastUsedSkill = function() {
      var e;
      try {
        if ($gameTemp.aaLastUsedAction != null) {
          return $gameTemp.aaLastUsedAction.item();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    // * Последняя цель на который был использован навык
    _.lastUsedSkillTarget = function() {
      return $gameTemp.aaLastUsedActionTarget;
    };
    // * Кто использовал последний навык
    return _.lastSkillUser = function() {
      var e, ref;
      try {
        if ($gameTemp.aaLastUsedAction != null) {
          return (ref = $gameTemp.aaLastUsedAction.subject()) != null ? ref.AACharacter() : void 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
  })();
  (function() {    // * Для сетевого режима
    // -----------------------------------------------------------------------
    //? byWhat: actor, actorId, netId, actorName, playerName, playerIndex, info
    // * IS OUTER used for server synchronization
    _.setTeamIdFor = function(byWhat, value, teamId, isOuter = false) {
      var actor, e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        actor = nAPI.getPlayerInfo('actor', byWhat, value);
        if (actor == null) {
          return console.warn("Actor by " + byWhat + " with value " + value + " not found");
        } else {
          actor.aaNetSetupTeamId(teamId);
          if (!isOuter) {
            return AANetworkManager.setActorNetworkTeamId(actor.actorId(), teamId);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setPvPMode = function() {
      var e;
      try {
        AA.Network.setPvPMode();
        return AANetworkManager.refreshPvPGameModeState();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setPvEMode = function() {
      var e;
      try {
        AA.Network.setPvEMode();
        return AANetworkManager.refreshPvPGameModeState();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * what can be: actor, actorId, netId, actorName, playerName, playerIndex, info
    return _.getWhoKillMeInPvP = function(what = "actorId") {
      var e;
      if (!AA.Network.isNetworkPvPGame()) {
        return null;
      }
      if ($gameTemp.aaPvPKilledBy == null) {
        return null;
      }
      try {
        return nAPI.getPlayerInfo(what, 'netId', $gameTemp.aaPvPKilledBy);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все иконки баффов игрока
(function() {
  var UISet_ActorBuffsIcons;
  UISet_ActorBuffsIcons = class UISet_ActorBuffsIcons extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    refresh() {
      var e, ref;
      try {
        return (ref = this.controllers[0]) != null ? ref.setup($gameParty.leader()) : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_ActorBuffsIcons);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorBuffsIcons.prototype;
  _._create = function() {
    var data, i, icons, index, len;
    icons = AA.PP.getUIActorBuffsIconsSet();
    for (index = i = 0, len = icons.length; i < len; index = ++i) {
      data = icons[index];
      this._createBuffIcon(data, index);
    }
    return this._createControllers();
  };
  _._createBuffIcon = function(data, index) {
    var buffItem, e, p;
    try {
      p = AA.PP.uiData("actorBuffIcon");
      buffItem = new AA.Sprite_ActorStateIcon(p);
      buffItem.tag = "buffItem_" + index;
      buffItem.move(data.x, data.y);
    } catch (error) {
      e = error;
      AA.w(e);
      buffItem = null;
    }
    if (buffItem == null) {
      return;
    }
    this.addChild(buffItem);
    this.elements.push(buffItem);
  };
  _._createControllers = function() {
    var buffsCnt;
    buffsCnt = new AA.BuffIconsController(this.elements);
    buffsCnt.tag = "buffs";
    this.controllers.push(buffsCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все gauge игрока, отвечает за их работу
(function() {
  var UISet_ActorGauges;
  // * В качестве аргумента получает класс интерфейса
  UISet_ActorGauges = class UISet_ActorGauges extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    refresh() {
      var e, ref, ref1, ref2, ref3;
      try {
        if ((ref = this.hpGauge) != null) {
          ref.setup($gameParty.leader(), 'hp', 'mhp');
        }
        if ((ref1 = this.mpGauge) != null) {
          ref1.setup($gameParty.leader(), 'mp', 'mmp');
        }
        if ((ref2 = this.tpGauge) != null) {
          ref2.setup($gameParty.leader(), 'tp', 'mtp');
        }
        return (ref3 = this.expGauge) != null ? ref3.setup($gameParty.leader(), 'cexp', 'nexp') : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_ActorGauges);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorGauges.prototype;
  _._create = function() {
    this.hpGauge = this._createGauge("hpGauge");
    this.tpGauge = this._createGauge("tpGauge");
    this.mpGauge = this._createGauge("mpGauge");
    return this.expGauge = this._createGauge("expGauge");
  };
  _._createGauge = function(tag) {
    var e, gauge, gaugeCnt, p;
    try {
      p = AA.PP.uiData(tag);
      gauge = new AA.Sprite_ActorStateGauge(p);
      gauge.tag = tag;
      gaugeCnt = new AA.GaugeController(gauge);
      gaugeCnt.tag = tag;
      this.controllers.push(gaugeCnt);
      this.elements.push(gauge);
      this.addChild(gauge);
      return gaugeCnt;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все иконки состояний игрока
(function() {
  var UISet_ActorStatesIcons;
  UISet_ActorStatesIcons = class UISet_ActorStatesIcons extends AA.UISet_ActorBuffsIcons {
    constructor() {
      super();
    }

  };
  AA.link(UISet_ActorStatesIcons);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorStatesIcons.prototype;
  //$[OVER]
  _._create = function() {
    var data, i, icons, index, len;
    icons = AA.PP.getUIActorStatesIconsSet();
    for (index = i = 0, len = icons.length; i < len; index = ++i) {
      data = icons[index];
      this._createStateIcon(data, index);
    }
    return this._createControllers();
  };
  _._createStateIcon = function(data, index) {
    var e, p, stateItem;
    try {
      p = AA.PP.uiData("actorStateIcon");
      stateItem = new AA.Sprite_ActorStateIcon(p);
      stateItem.tag = "stateItem_" + index;
      stateItem.move(data.x, data.y);
    } catch (error) {
      e = error;
      AA.w(e);
      stateItem = null;
    }
    if (stateItem == null) {
      return;
    }
    this.addChild(stateItem);
    this.elements.push(stateItem);
  };
  //$[OVER]
  _._createControllers = function() {
    var statesCnt;
    statesCnt = new AA.StatesIconsController(this.elements);
    statesCnt.tag = "states";
    this.controllers.push(statesCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все ячейки навыков (предметов) на интерфейсе
(function() {
  var UISet_Skills;
  // * В качестве аргумента получает класс интерфейса
  UISet_Skills = class UISet_Skills extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    // * Этот метод нужен обязательно
    refresh() {
      var e;
      try {

      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_Skills);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_Skills.prototype;
  _._create = function() {
    var i, item, len, ref;
    ref = AA.PP.getUISkillsItems();
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item != null) {
        this._createSkillItem(item);
      }
    }
    this._createController();
  };
  _._createSkillItem = function(itemSettings) {
    var def, e, p, skillItem;
    try {
      def = AA.PP.uiData("skillSlot");
      if ((itemSettings.style != null) && itemSettings.style !== "") {
        p = itemSettings.style;
      } else {
        p = def;
      }
      try {
        skillItem = new AA.Sprite_SKillPanelItem(p);
      } catch (error) {
        e = error;
        AA.w(e);
        skillItem = new AA.Sprite_SKillPanelItem(def);
      }
      skillItem.tag = "skillItem_" + itemSettings.symbol;
      skillItem.move(itemSettings.position);
      skillItem.drawSymbol(itemSettings.symbol);
      skillItem.symbol = itemSettings.symbol;
    } catch (error) {
      e = error;
      AA.w(e);
      skillItem = null;
    }
    if (skillItem == null) {
      return;
    }
    this.addChild(skillItem);
    this.elements.push(skillItem);
  };
  _._createController = function() {
    var skillsCnt;
    skillsCnt = new UISkillsItemsController(this.elements);
    skillsCnt.tag = "skills";
    this.controllers.push(skillsCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс харинт UI выбранной (под курсором) цели и контроллеры
(function() {
  var UISet_TargetInfo;
  UISet_TargetInfo = class UISet_TargetInfo extends Sprite {
    constructor() {
      super();
      // * Эти два поля обязательные для набора элементов интерфейса
      // * Они используются в методе _registerUISet в Spriteset UI
      this.controllers = [];
      this.elements = [];
      //TODO: register global event
      this._create();
      return;
    }

    refresh() {}

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_TargetInfo);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ UISet_TargetInfo.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_TargetInfo.prototype;
  _._create = function() {
    this.infoSpr = new AA.Sprite_EnemyInfo();
    this.infoSpr.tag = "targetInfo"; // * Это надо для управленя элементов через uAPI и редактор
    this.infoSprCnt = new UITargetInfoController(this.infoSpr);
    this.infoSprCnt.tag = "targetInfo";
    this.controllers.push(this.infoSprCnt);
    this.elements.push(this.infoSpr);
    return this.addChild(this.infoSpr);
  };
})();

// ■ END UISet_TargetInfo.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Данный класс работает только на Game_Player
var UISkillsItemsController;

UISkillsItemsController = class UISkillsItemsController {
  constructor(skillItems) {
    this.skillItems = skillItems;
    // * Очищаем тело метода, если отключён соответствующий параметр плагина
    // (для экономии производительности)
    if (!AA.PP.isRemoveItemIfZeroCount()) {
      this._checkResetItemFromPanel = function() {}; // * EMPTY
    }
    this.setup();
    return;
  }

  setup() {
    this.battler = $gamePlayer.AABattler();
    this.skillSet = $gamePlayer.aaSkillsSet;
    this._updThread = new KDCore.TimedUpdate(20, this._updateItemsStates.bind(this));
    this._updThreadItemCount = new KDCore.TimedUpdate(30, this._updateItemsCount.bind(this));
    this._updThreadTimers = new KDCore.TimedUpdate(2, this._updateItemsTimers.bind(this));
    this.refresh();
  }

  onSkillPerformResult(skillId, result) {
    var e, item;
    try {
      item = this._getItemForSkillId(skillId);
      if (item == null) {
        return;
      }
      if (result === 0) {
        return item.pulseAlert();
      } else {
        return item.pulseClick();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  refresh() {
    var i, item, j, len, len1, panelItems, ref, skill;
    this._clearItems();
    if (this.battler == null) {
      return;
    }
    ref = this.battler.getAASkills();
    for (i = 0, len = ref.length; i < len; i++) {
      skill = ref[i];
      this._setupItem(skill);
    }
    // * Предметы отдельно, так как могут быть не в наличии
    panelItems = this.skillSet.getAllItemsFromPanel().map(function(id) {
      return AA.Utils.getAASkillObject(id);
    });
    for (j = 0, len1 = panelItems.length; j < len1; j++) {
      item = panelItems[j];
      this._setupItem(item);
    }
    // * Все слоты у которых нет навыка, очищаем уже
    this._checkAndClearEmptyItems();
    this._updateItemsCount(); // * Сразу обновим количество
  }

  update() {
    var ref, ref1, ref2;
    if ((ref = this._updThread) != null) {
      ref.update();
    }
    if ((ref1 = this._updThreadTimers) != null) {
      ref1.update();
    }
    if ((ref2 = this._updThreadItemCount) != null) {
      ref2.update();
    }
    this._updateInput();
  }

  getItemUnderMouse() {
    return this.skillItems.find(function(item) {
      return item.isUnderMouse();
    });
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = UISkillsItemsController.prototype;
  _._updateItemsStates = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemState(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._updateItemsTimers = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemTimer(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._updateItemsCount = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemCount(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Обновить состояние (таймер, доступность)
  _._updateItemState = function(item) {
    var e, useCases;
    try {
      if (AA.isABSActive()) {
        useCases = this.battler.getUsableAASkills().map(function(skill) {
          return skill.idA;
        });
      } else {
        useCases = [];
      }
      this._updateItemUseState(item, useCases);
    } catch (error) {
      e = error;
      AA.w(e);
      this._updThread = null;
    }
  };
  // * Обновить таймер для навыка
  _._updateItemTimer = function(item) {
    var parts, tStr, time;
    if (item.isDisabled() && item.skillId > 0) {
      time = $gamePlayer.AABattler().aaGetRemainTimeForSkill(item.skillId);
      if (time > 0) {
        //TODO: BAD performance, BAD BAD BAD way
        tStr = "" + time;
        if (tStr.contains(".")) {
          parts = tStr.split(".");
          if (parts[1].length > 0) {
            tStr = parts[0] + "." + parts[1][0];
          }
        }
        return item.drawTime(tStr);
      } else {
        return item.drawTime("");
      }
    } else {
      return item.drawTime("");
    }
  };
  // * Обновить количество (для предметов)
  _._updateItemCount = function(item) {
    var count;
    // * Навыки пропускаем
    if (AA.Utils.isAASkill(item.skillId)) {
      return;
    }
    count = $gameParty.numItems(AA.Utils.getAASkillObject(item.skillId));
    item.drawCount(count);
    this._checkResetItemFromPanel(item, count);
  };
  //@[DYNAMIC]
  _._checkResetItemFromPanel = function(item, count) {
    var e;
    try {
      if (count <= 0) {
        uAPI.setItemToPanel(0, item.symbol);
      }
    } catch (error) {
      e = error;
      this._checkResetItemFromPanel = function() {}; // * EMPTY
      AA.w(e);
    }
  };
  _._updateItemUseState = function(item, useable) {
    if (item.skillId === 0) {
      if (item.isDisabled()) {
        // * Доп. проверочка isDisabled, а то мерцает
        item.enable();
      }
    } else {
      // * Если состояние было включено на Enabled, значит даём сигнал
      if (item.switchState(useable.contains(item.skillId))) {
        item.pulseReady();
      }
    }
  };
  _._clearItems = function() {
    var i, item, len, ref;
    ref = this.skillItems;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      //item.clear() # * Не очищаем, чтобы не было мерцания картинки (если используется)
      item.skillId = 0;
    }
  };
  _._checkAndClearEmptyItems = function() {
    var e, i, item, len, ref;
    try {
      ref = this.skillItems;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.skillId <= 0) {
          item.clear();
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  
  // * Задать навык в ячейку
  _._setupItem = function(skill) {
    var iconIndex, item, symb;
    if (skill == null) {
      return;
    }
    symb = this.skillSet.getSymbolForSkill(skill.idA);
    // * Нету символа для навыка (т.е. навык не находится в ячейках)
    if (symb == null) {
      return;
    }
    item = this._getItemForSymbol(symb);
    if (item == null) {
      return;
    }
    item.skillId = skill.idA;
    if (item.skillId === this.battler.attackSkillId()) {
      iconIndex = AA.Utils.getAttackSkillWeaponIconIndex(item, this.battler);
      item.drawIcon(iconIndex);
    } else {
      iconIndex = AA.Utils.getSkillSlotImgOrIcon(skill);
      item.drawIcon(iconIndex);
    }
    // * Сразу обновляем состояние
    this._updateItemState(item);
  };
  // * symbol назначается при создании в UISet_Skills из параметров
  _._getItemForSymbol = function(symb) {
    return this.skillItems.find(function(item) {
      return item.symbol === symb;
    });
  };
  // * Получить ячейку по ID навыка (устанавливается в методе _setupItem)
  _._getItemForSkillId = function(id) {
    return this.skillItems.find(function(item) {
      return item.skillId === id;
    });
  };
  // * Этот метод работает с клавиатуры, а не при клике мышкой
  _._updateInput = function() {
    var inputSymbol, item;
    inputSymbol = AA.Input.getTriggeredSkillSymbol();
    if (inputSymbol != null) {
      item = this._getItemForSymbol(inputSymbol);
      if (item != null) {
        $gamePlayer.aaTryPerformSkill(item.skillId);
      }
    }
  };
  // * Обработка нажатия правкой кнопкой мыши по слоту (вызывается из AA.UI)
  _.handleSkillSelectorProcess = function() {
    var symbol;
    if (AA.UI.isSkillSelectorOpen()) {
      AA.UI.closeSkillSelector();
      // * Если было нажатие на другой слот, то сразу открываем его
      symbol = this._getSkillSymbolSelectorHandled();
      if ((symbol != null) && $gameTemp.__aaLastSkillSelectorSymbol !== symbol) {
        return this.handleSkillSelectorProcess(); // * Если было нажатие на слот, но этот же, закрываем его
      } else {
        $gameTemp.__aaLastSkillSelectorSymbol = null;
        return true;
      }
    } else {
      symbol = this._getSkillSymbolSelectorHandled();
      if ((symbol != null) && AA.Input.isEditableSymbol(symbol)) {
        AA.UI.openSkillSelectorFor(symbol);
        $gameTemp.__aaLastSkillSelectorSymbol = symbol;
        return true;
      }
    }
    return false;
  };
  // * Возвращает symbol слота, если было открыто меню выбора навыка (правой кнопкой по слоту)
  _._getSkillSymbolSelectorHandled = function() {
    var item;
    // * Только по правой кнопке мыши (всегда)
    if (TouchInput.isCancelled()) {
      item = this._getItemUnderCursor();
      if (item != null) {
        return item.symbol;
      }
    }
    return null;
  };
  
  // * Получить Skill Item под курсором
  _._getItemUnderCursor = function() {
    return this.skillItems.find(function(item) {
      return item.isUnderMouse();
    });
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//TODO: Систематизация класса
var UITargetInfoController;

UITargetInfoController = class UITargetInfoController {
  constructor(targetInfoSpr) {
    this.targetInfoSpr = targetInfoSpr;
    AA.EV.subscribeFor("UnderMouseEventChanged", this.gev_onUnderMouseEventChanged.bind(this));
    this._createSoControllers();
    this.targetInfoSpr.visible = false;
    return;
  }

  refresh() {
    return this.gev_onUnderMouseEventChanged();
  }

  setup(target1) {
    this.target = target1;
    if (this.target == null) {
      this.hideTargetInfo();
    }
    this.gaugeCnt.setup(this.target.AABattler(), "hp", "mhp");
    this.showTargetInfo();
  }

  hideTargetInfo() {
    this.targetInfoSpr.hideSlow();
    this.target = null;
    this.statesRefreshThread = null;
  }

  showTargetInfo() {
    var battler, e, model;
    try {
      model = this.target.AAEntity().model();
      if (model == null) {
        return;
      }
      if (model.UIInfo === 0) {
        return;
      }
      battler = this.target.AABattler();
      //TODO: Values from enemy
      this.targetInfoSpr.drawNameWithFormat(battler.name());
      //TODO: level from what?
      this.targetInfoSpr.drawLevelWithFormat(1);
      this.targetInfoSpr.drawFace(model.faceName, model.faceIndex);
      //TODO: battle state show and refresh by AI state
      this.targetInfoSpr.showSlow();
      this.statesRefreshThread = new KDCore.TimedUpdate(40, this.refreshTargetStates.bind(this));
      this.refreshTargetStates();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.hideTargetInfo();
    }
  }

  refreshTargetStates() {
    var battler, e;
    if (this.target == null) {
      return;
    }
    try {
      battler = this.target.AABattler();
      if (battler == null) {
        this.targetInfoSpr.drawStates(null);
        return;
      }
      if (battler.isAlive()) {
        this.targetInfoSpr.drawStates(battler.allIcons());
      } else {
        this.targetInfoSpr.drawStates(null);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  update() {
    var ref;
    if (!this.targetInfoSpr.visible) {
      return;
    }
    this.gaugeCnt.update();
    if ((ref = this.statesRefreshThread) != null) {
      ref.update();
    }
  }

  gev_onUnderMouseEventChanged() {
    if (this.isValidTargetToShow($gameTemp._aaEventUnderCursor)) {
      if (this.target !== $gameTemp._aaEventUnderCursor) {
        this.setup($gameTemp._aaEventUnderCursor);
      }
    } else {
      this.hideTargetInfo();
    }
  }

  isValidTargetToShow(target) {
    var e;
    if (target == null) {
      return false;
    }
    try {
      if (target instanceof Game_Event) {
        return target.isABS();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  }

  _createSoControllers() {
    this.gaugeCnt = new AA.GaugeController(this.targetInfoSpr.gauge);
    // * Используется свой метод для отрисовки значения (с форматом)
    this.gaugeCnt.targetInfoSpr = this.targetInfoSpr;
    this.gaugeCnt._refreshValues = function() {
      var rate;
      rate = this.value / this.max;
      this.gaugeSprite.drawGauge(rate);
      return this.targetInfoSpr.drawHpWithFormat(this.value, this.max, rate);
    };
  }

};


// Generated by CoffeeScript 2.6.1
// * Данный класс содержит пользовательские (временные) настройки UI элементов

//@[GLOBAL]
//@[STORABLE]
var AAUserUISettings;

AAUserUISettings = class AAUserUISettings {
  constructor() {
    if (this.isGlobalUsage()) {
      this.settings = ConfigManager.aaUserUISettings || {};
    } else {
      this.settings = {};
    }
    return;
  }

  // * Сохранять (загружать) изменения в Config Manager (глобально)
  isGlobalUsage() {
    return AA.PP.isGlobalUserUISettings();
  }

  isHaveFor(key) {
    return this.settings[key] != null;
  }

  createFor(key) {
    return this.settings[key] = {};
  }

  //?[UNSAFE]
  //? Cперва надо сделать проверку isHaveFor
  // * Если поля нету, возращают null, значит вообще не учитывать пользовательскую настройку
  // * return KDCore.Point
  getPositionFor(key) {
    var e, ref;
    try {
      return (ref = this.settings[key]) != null ? ref.position : void 0;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  //?[UNSAFE]
  getVisibleFor(key) {
    var e, state;
    try {
      if (this.settings[key] == null) {
        return null;
      }
      state = this.settings[key].visible;
      if (state != null) {
        return state;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  set(key, command, value) {
    var e;
    if (!this.isHaveFor(key)) {
      // * Создаём для элемента данные, если нету ещё
      this.createFor(key);
    }
    try {
      switch (command) {
        case "setPosition":
          // * Значние должно быть массивом
          this.settings[key].position = KDCore.Utils.jsonPos(value).simple();
          break;
        case "setVisible":
          // * Значение должно быть bool
          this.settings[key].visible = value;
          break;
        case "resetPosition":
          // * Нет значения, просто сброс
          this.settings[key].position = null;
          break;
        case "clear":
          // * Нет значения, удаление всех настроек
          delete this.settings[key];
          break;
        default:
          KDCore.warning('Unknown command ' + command);
      }
      this.saveGlobalSettings();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  saveGlobalSettings() {
    var e;
    try {
      if (!this.isGlobalUsage()) {
        return;
      }
      // * Не обязательно, но лучше переопределить
      ConfigManager.aaUserUISettings = this.settings;
      ConfigManager.save();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_Base.prototype;
  _.aaDrawAnyIcon = function(imageOrIcon, x, y, size) {
    var e;
    try {
      if (imageOrIcon == null) {
        return;
      }
      if (imageOrIcon === 0) {
        return;
      }
      if (!String.any(imageOrIcon)) {
        return;
      }
      if (isFinite(imageOrIcon)) {
        return this.drawIcon(imageOrIcon, x, y);
      } else {
        return this._aaDrawAsyncImage(x, y, imageOrIcon, size);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaDrawAsyncImage = function(x, y, imageName, size = 0) {
    var drawAsyncImageBody, e;
    try {
      drawAsyncImageBody = (x1, y1, size1, b) => {
        var e;
        try {
          if (size1 === 0) {
            size1 = b.width;
          }
          return this.contents.drawIcon(x1, y1, b, size1, false);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      };
      return KDCore.Utils.loadImageAsync("Alpha", imageName).then(drawAsyncImageBody.bind(this, x, y, size));
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Window_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleSkill.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__includes, _;
  //@[DEFINES]
  _ = Window_BattleSkill.prototype;
  // * Прячем ABS навыки из битвы со специальным флагом hideOutsideABS == 1
  //@[ALIAS]
  ALIAS__includes = _.includes;
  _.includes = function(item) {
    var isInclude;
    isInclude = ALIAS__includes.call(this, item);
    if (isInclude === true) {
      if (AA.Utils.isAAObject(item)) {
        if (item.AASkill.hideOutsideABS === 1) {
          return false;
        }
      }
    }
    return isInclude;
  };
})();

// ■ END Window_BattleSkill.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Message.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startMessage, ALIAS__terminateMessage, _;
  //@[DEFINES]
  _ = Window_Message.prototype;
  //@[ALIAS]
  ALIAS__startMessage = _.startMessage;
  _.startMessage = function() {
    ALIAS__startMessage.call(this);
    return AA.UI.onGameMessageStart();
  };
  
  //TODO: Тут мерцание происходит. Как быть? Timeout?
  //@[ALIAS]
  ALIAS__terminateMessage = _.terminateMessage;
  _.terminateMessage = function() {
    ALIAS__terminateMessage.call(this);
    return AA.UI.onGameMessageEnd();
  };
})();

// ■ END Window_Message.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//TODO: Добавить настройки, чтобы и размер иконок и текста можно было менять
var Window_SkillSelectorList;

Window_SkillSelectorList = class Window_SkillSelectorList extends Window_Selectable {
  constructor(rect) {
    super(...arguments);
    this.setBackgroundType(2);
    this.catIndex = -1;
    this.skillSymbol = null;
    return;
  }

  getSettings() {
    return $aabsz_SkillItemSelectorWindowSettings.itemsSkillsListWindow;
  }

  // * При нажатии на окно выбора навыков
  onClick() {
    var e, hitIndex, skillId, x, y;
    if (this.skillSymbol == null) {
      return;
    }
    if (this.catIndex < 0) {
      return;
    }
    if (KDCore.isMZ()) {
      hitIndex = this.hitIndex();
    } else {
      x = this.canvasToLocalX(TouchInput.x);
      y = this.canvasToLocalY(TouchInput.y);
      hitIndex = this.hitTest(x, y);
    }
    if (hitIndex < 0) {
      return;
    }
    try {
      skillId = this._skills[hitIndex].id;
      if (this.catIndex === 0) {
        uAPI.setSkillToPanel(skillId, this.skillSymbol);
      } else {
        uAPI.setItemToPanel(skillId, this.skillSymbol);
      }
      if (skillId > 0) {
        SoundManager.playEquip();
        // * Если навык был установлен (а не удалён)
        AA.UI.closeSkillSelector();
        // * Чтобы персонаж не пошёл к точку карты после закрытия окна
        TouchInput.clear();
      } else {
        SoundManager.playCursor();
        this.refresh();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  // * 0 - Skills
  // * 1 - Items
  setCategory(catIndex) {
    this.catIndex = catIndex;
    this.refresh();
    if (KDCore.isMZ()) {
      this.scrollTo(0, 0);
    }
  }

  // * Символ навыка, чтобы установить (убрать) на панель
  setSymbol(skillSymbol) {
    this.skillSymbol = skillSymbol;
  }

  // * Всегда можно прокручивать, так как окно не будет Active
  //$[OVER]
  isScrollEnabled() {
    return true;
  }

  maxCols() {
    return this.getSettings().maxCols;
  }

  lineHeight() {
    return this.getSettings().lineHeight;
  }

  maxItems() {
    if (this._skills != null) {
      return this._skills.length;
    } else {
      return 0;
    }
  }

  refresh() {
    this._prepareSkillsList();
    Window_Selectable.prototype.refresh.call(this);
  }

  drawItem(index) {
    var e, iconIndex, item, rect;
    this.__drawIndex = index;
    item = this._skills[index];
    if (item == null) {
      return;
    }
    rect = this.itemLineRect(index);
    try {
      // * Тут TryCatch так как есть системный placeholder вместо Item
      // * и модифицированный другими плагинами метод drawItemName
      // * может не найти поле необходимое, которое есть у Game_Items
      iconIndex = AA.Utils.getSkillSlotImgOrIcon(item);
      // * Если навык атаки, то надо рисовать иконку оружия
      if (this._isAttackSkill(index)) {
        iconIndex = AA.Utils.getAttackSkillWeaponIconIndex(item, $gameParty.leader());
      }
      this.aaDrawAnyIcon(iconIndex, rect.x, rect.y, this.getSettings().iconSize);
      this.__aaDrawItemName(item, rect);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  __aaDrawItemName(item, rect) {
    var e, iconY, itemWidth, size, textMargin, width, x, y;
    try {
      size = this.getSettings().iconSize;
      ({x, y, width} = rect);
      iconY = y + (this.lineHeight() - size) / 2;
      textMargin = size + 4;
      itemWidth = Math.max(0, width - textMargin);
      this.resetTextColor();
      return this.drawText(item.name, x + textMargin, y, itemWidth);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  //$[OVER]
  resetFontSettings() {
    var p;
    p = this.getSettings().itemNameTextSettings;
    if (KDCore.isMV()) {
      this.contents.fontFace = p.font || this.standardFontFace();
      this.contents.fontSize = p.size;
    } else {
      this.contents.fontFace = p.font || $gameSystem.mainFontFace();
      this.contents.fontSize = p.size;
    }
    this.resetTextColor();
  }

  resetTextColor() {
    var p;
    super.resetTextColor();
    if (this.catIndex < 0) {
      return;
    }
    p = this.getSettings();
    if (this.__drawIndex === 0) {
      return this.changeTextColor(p.removeCommand.textColor); // * [Remove]
    // * Атака может быть только в категории навыков
    // * А может и не быть (если установлена)
    } else if (this._isAttackSkill(this.__drawIndex)) {
      return this.changeTextColor(p.attackSkillTextColor); // * Attack
    } else {
      //TODO: Items name color plugin compatability
      if (this.catIndex === 0) {
        return this.changeTextColor(p.skillsNamesTextColor);
      } else {
        return this.changeTextColor(p.itemsNamesTextColor);
      }
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Window_SkillSelectorList.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Window_SkillSelectorList.prototype;
  _._prepareSkillsList = function() {
    var e, skills;
    this._skills = [];
    // * ID навыка атаки в списке, если == 0 - нет навыка
    this._attackSkillId = 0;
    if (this.catIndex < 0) {
      return;
    }
    try {
      if (this.catIndex === 0) { // * Skills only
        skills = $gameParty.leader().getAASkills();
        // * Так как метод getAASkills возвращает все навыки (включая предметы)
        // * то дополнительный фильтр от предметов
        skills = skills.filter(function(s) {
          return AA.Utils.isAASkill(s.idA); // * Items only
        });
      } else {
        skills = $gameParty.leader().getAAItems();
      }
      this._skills = skills;
      this._removeAlreadyInPanelSkills();
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
    if (this.catIndex === 0) {
      this._checkAttackSkillInList();
    }
    this._skills.unshift(this._removeCommandItem());
  };
  _._removeCommandItem = function() {
    var p;
    p = this.getSettings().removeCommand;
    return {
      id: 0,
      idA: 0,
      iconIndex: p.iconIndex,
      name: p.title
    };
  };
  // * Удаляет из списка навыков те, что уже установленны на панель навыков
  _._removeAlreadyInPanelSkills = function() {
    var e, i, len, notInPanelSkills, ref, s, skillPanel;
    try {
      notInPanelSkills = [];
      skillPanel = $gamePlayer.aaSkillsSet;
      if (skillPanel == null) {
        return;
      }
      ref = this._skills;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        if (skillPanel.getSymbolForSkill(s.idA) == null) {
          notInPanelSkills.push(s);
        }
      }
      this._skills = notInPanelSkills;
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
  };
  _._checkAttackSkillInList = function() {
    var attackSkill, attackSkillId, e;
    try {
      attackSkillId = $gameParty.leader().attackSkillId();
      attackSkill = this._skills.find(function(s) {
        return s.id === attackSkillId;
      });
      if (attackSkill != null) {
        this._skills.delete(attackSkill);
        // * Запоминаем ID (значит есть в списке)
        this._attackSkillId = attackSkillId;
        // * Ставим на первое место в список
        this._skills.unshift(attackSkill);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
  };
  _._isAttackSkill = function(index) {
    var e, ref;
    try {
      if (this.catIndex === 0 && this._attackSkillId > 0) {
        if (((ref = this._skills[index]) != null ? ref.id : void 0) === this._attackSkillId) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
})();

// ■ END Window_SkillSelectorList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_AAMapSkill2Projectile.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_AAMapSkill2Projectile.prototype;
  _._checkCollisionNew = function() {
    var c, collider, e, event, i, len, map, mapColliders, netChar, partyMember, point, x, y;
    try {
      if (this.skill.isPhantom()) {
        return;
      }
      if (this.opacity < 255) {
        return;
      }
      // * CHECK COLLISIONS WITH CHARS, EVENTS, MAP REGIONS
      x = Math.floor(this.skill.x / $gameMap.tileWidth());
      y = Math.floor(this.skill.y / $gameMap.tileWidth());
      this.skill.refreshColliderPosition(this.x, this.y);
      partyMember = this._checkHitPartyMemberNew(x, y);
      if (partyMember != null) {
        this.onHit(partyMember);
        return;
      }
      // * OLD SYSTEM, regionId or Terrain Tag (based on Skill)
      map = this._checkHitMap(x, y);
      if (map === true) {
        this.onHit({x, y});
        return;
      }
      // * OLD SYSTEM, hit point by XY
      point = this._checkHitPoint(x, y);
      if (point === true) {
        this.onHit({x, y});
        return;
      }
      // * NEW SYSTEM, regionId or Terrain Tag colliders
      mapColliders = $gameMap.aaGetExCollidersWithin(x, y, 2);
      collider = this.skill.getCollider();
      for (i = 0, len = mapColliders.length; i < len; i++) {
        c = mapColliders[i];
        if (collider.isCollideWith(c)) {
          this.onHit({x, y});
          return;
        }
      }
      // * NEW SYSTEM, events by Colliders
      event = this._checkHitEventNew(x, y);
      if (event != null) {
        this.onHit(event);
        return;
      }
      
      //TODO: Network chars too NEW!!q
      if (AA.Network.isNetworkGame()) {
        netChar = this._checkHitNetworkChar();
        if (netChar != null) {
          this.onHit(netChar);
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._checkHitEventNew = function(x, y) {
    var collider, ev, events, i, len, subId;
    subId = this.skill.getSubjectEvId();
    events = $gameMap.aaGetEventCollidersWithin(x, y, 3);
    collider = this.skill.getCollider();
    for (i = 0, len = events.length; i < len; i++) {
      ev = events[i];
      if (ev == null) {
        continue;
      }
      if (ev.eventId() === subId) {
        // * В себя нельзя попасть
        continue;
      }
      if (ev.aaIsCollideWith(collider) && this.isEventIsObstacle(ev)) {
        return ev;
      }
    }
    return null;
  };
  _._checkHitPartyMemberNew = function() {
    var collider, follower, i, len, ref;
    if (this.skill.isSubjectIsPlayer()) {
      //TODO: friendlyfier is 1
      return null;
    }
    if (this.skill.isSubjectIsAlly()) {
      return null;
    }
    collider = this.skill.getCollider();
    if (!$gamePlayer.aaIsInvincible() && $gamePlayer.aaIsCollideWith(collider)) {
      if (this.isSameMapLevel($gamePlayer._priorityType)) {
        return $gamePlayer;
      }
    }
    ref = $gamePlayer.aaGetABSFollowers();
    for (i = 0, len = ref.length; i < len; i++) {
      follower = ref[i];
      if (follower.aaIsCollideWith(collider)) {
        return follower;
      }
    }
    return null;
  };
})();

// ■ END Sprite_AAMapSkill2Projectile.coffee
//---------------------------------------------------------------------------

//Plugin Alpha_ABSZ builded by PKD PluginBuilder 2.2.1 - 20.06.2024