/*:
 * @target MZ
 * @plugindesc v1.2 자동 전체화면 + 첫입력 보장 재시도 + 화면스케일 보정
 * @author AutoGenerated
 *
 * @param StartMode
 * @text 시작 모드
 * @type select
 * @option 자동시도 후 실패 시 대기(권장) @value auto
 * @option 사용자 첫 입력에서만 실행 @value onTap
 * @default auto
 *
 * @param LockOrientation
 * @text 세로/가로 고정
 * @type select
 * @option 없음 @value none
 * @option 세로 @value portrait
 * @option 가로 @value landscape
 * @default none
 *
 * @param RememberSuccess
 * @text 성공 후 재시도 생략
 * @type boolean
 * @on 예
 * @off 아니오
 * @default true
 *
 * @help
 * ■ 설명
 * 이 플러그인은 웹브라우저 환경에서 RPG Maker MZ 게임을
 * 자동으로 전체화면으로 전환합니다. 브라우저 정책으로 인해
 * 자동 요청이 거부될 경우 첫 입력 시 재요청하며,
 * 성공 후에는 캔버스를 화면 해상도에 맞춰 보정합니다.
 *
 * ■ 사용 방법
 * - js/plugins/AutoFullscreenPlusMZ.js 로 저장 후
 *   플러그인 관리에서 활성화하십시오.
 * - StartMode: 'auto' 는 게임 시작 시 전체화면을 시도하고
 *   실패하면 첫 입력에서 재시도합니다. 'onTap' 은 항상
 *   첫 입력에서만 전체화면을 요청합니다.
 * - LockOrientation: 필요한 경우 화면 방향을 고정합니다.
 * - RememberSuccess: 한 번 성공하면 이후 자동 재요청을
 *   생략합니다.
 *
 * ■ 주의 사항
 * - 모바일 WebView/브라우저 정책에 따라 자동 전체화면은
 *   사용자 제스처가 필요할 수 있습니다.
 * - 다른 화면/해상도 조정 플러그인보다 아래쪽에 배치하세요.
 */

(() => {
  const parameters = PluginManager.parameters('AutoFullscreenPlusMZ');
  const START_MODE = String(parameters.StartMode || 'auto');
  const LOCK_ORI = String(parameters.LockOrientation || 'none');
  const REMEMBER = parameters.RememberSuccess === 'true';
  const LS_KEY = 'afp_fullscreen_done_v12';

  const isNWjs = () => {
    return typeof require === 'function' && typeof process === 'object' && process.versions && process.versions.nw;
  };

  const canRequest = () => {
    const el = document.documentElement;
    return !!(el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen);
  };

  const requestFS = async el => {
    try {
      const fn = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
      if (fn) {
        await fn.call(el);
        return true;
      }
    } catch (_) {}
    return false;
  };

  const isFS = () => {
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
  };

  const onFSChange = fn => {
    ['fullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'].forEach(ev => {
      document.addEventListener(ev, fn, { passive: true });
    });
  };

  const lockOrientation = async () => {
    if (!screen.orientation || LOCK_ORI === 'none') return;
    try {
      await screen.orientation.lock(LOCK_ORI);
    } catch (_) {}
  };

  const adjustCanvas = () => {
    try {
      const W = window.innerWidth;
      const H = window.innerHeight;
      const canvas = Graphics._canvas;
      if (!canvas) return;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      canvas.width = W;
      canvas.height = H;
      Graphics._width = W;
      Graphics._height = H;
      Graphics._boxWidth = W;
      Graphics._boxHeight = H;
      if (Graphics._updateAllElements) Graphics._updateAllElements();
      if (Graphics._onResize) Graphics._onResize();
      window.scrollTo(0, 1);
      document.body.style.overflow = 'hidden';
    } catch (_) {}
  };

  const tryFullscreen = async reason => {
    if (isNWjs()) {
      if (Graphics._requestFullScreen) Graphics._requestFullScreen();
      setTimeout(adjustCanvas, 50);
      return true;
    }
    if (!canRequest()) {
      adjustCanvas();
      return false;
    }
    if (REMEMBER && localStorage.getItem(LS_KEY) === '1') {
      adjustCanvas();
      return true;
    }
    const ok = await requestFS(document.documentElement);
    if (ok) {
      await lockOrientation();
      setTimeout(adjustCanvas, 50);
      if (REMEMBER) localStorage.setItem(LS_KEY, '1');
      return true;
    }
    if (reason === 'auto') installFirstInput();
    return false;
  };

  let firstHandlerSet = false;
  const installFirstInput = () => {
    if (firstHandlerSet) return;
    firstHandlerSet = true;
    const handler = async () => {
      document.removeEventListener('pointerdown', handler, true);
      document.removeEventListener('keydown', handler, true);
      await tryFullscreen('tap');
    };
    document.addEventListener('pointerdown', handler, true);
    document.addEventListener('keydown', handler, true);
    const hint = document.createElement('div');
    hint.textContent = '화면을 터치하면 전체화면으로 전환됩니다';
    Object.assign(hint.style, {
      position: 'fixed',
      left: '50%',
      top: '12px',
      transform: 'translateX(-50%)',
      zIndex: 99999,
      padding: '6px 10px',
      background: 'rgba(0,0,0,.6)',
      color: '#fff',
      fontSize: '12px',
      borderRadius: '6px',
      pointerEvents: 'none'
    });
    document.body.appendChild(hint);
    setTimeout(() => hint.remove(), 2000);
  };

  onFSChange(() => setTimeout(adjustCanvas, 50));
  window.addEventListener('resize', () => setTimeout(adjustCanvas, 50), { passive: true });

  const startPlugin = () => {
    if (!document.querySelector('meta[name="viewport"]')) {
      const m = document.createElement('meta');
      m.name = 'viewport';
      m.content = 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover';
      document.head.appendChild(m);
    }
    if (START_MODE === 'onTap') {
      installFirstInput();
      adjustCanvas();
    } else {
      tryFullscreen('auto');
    }
  };

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(startPlugin, 0);
  } else {
    document.addEventListener('DOMContentLoaded', startPlugin, { once: true });
  }
})();